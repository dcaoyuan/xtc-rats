// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 2.3.1,
// (C) 2004-2012 Robert Grimm,
// on Sunday, March 3, 2013 at 9:53:31 PM.
// Edit at your own risk.
// ===========================================================================

package xtc.lang.blink;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Action;
import xtc.util.Pair;

import xtc.tree.Node;
import xtc.tree.GNode;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import xtc.lang.CParserState;

/**
 * Packrat parser for grammar <code>xtc.lang.blink.Command</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 2.3.1, (C) 2004-2012 Robert Grimm.
 */
public final class CommandParser extends ParserBase {

  /** The RELOCATE flag. */
  public static final boolean RELOCATE = true;

  /** The C_KEYWORDS set. */
  public static final Set<String> C_KEYWORDS = new HashSet<String>();

  /** The GCC flag. */
  public static final boolean GCC = true;

  /** The JAVA_KEYWORDS set. */
  public static final Set<String> JAVA_KEYWORDS = new HashSet<String>();

  /** The C99 flag. */
  public static final boolean C99 = true;

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fMetaVariable;
    Result fUnambiguousCommand;
    Result fRestOfLine;
    Result fConstant;
    Result fCConstant$Exponent;
    Result f$$Shared27;
    Result fBinaryExponent;
    Result fCConstant$CharacterLiteral;
    Result fCConstant$StringConstant;
    Result fCConstant$StringConstant$$Plus1;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fCConstant$StringLiteral;
    Result fSymbol;
    Result fCIdentifier$Identifier;
    Result fKeyword;
    Result fCIdentifier$Word;
    Result fResultType;
    Result fType;
    Result fJavaType$TypeName;
    Result fPrimitiveType;
    Result fDimensions;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fDimensions$$Plus1;
    Result fLiteral;
    Result fIntegerLiteral;
    Result fQualifiedIdentifier;
    Result fQualifiedIdentifier$$Star1;
    Result fJavaIdentifier$Identifier;
    Result fJavaIdentifier$Word;
    Result fJeannieC$DeclarationSpecifiers;
    Result fJeannieC$InitializedDeclaratorList;
    Result fJeannieC$InitializedDeclaratorList$$Star1;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fJeannieC$SpecifierQualifierList;
    Result fJeannieC$AttributedDeclarator;
    Result fJeannieC$Declarator;
    Result fJeannieC$Pointer;
    Result fJeannieC$VariableLength;
    Result fJeannieC$ParameterTypeList;
    Result fJeannieC$AbstractDeclarator;
    Result f$$Shared9;
    Result fJeannieC$TypeName;
    Result fJeannieC$AttributeSpecifierList;
  }

  /** Chunk 5 of memoized results. */
  static final class Chunk5 {
    Result fJeannieC$AttributeSpecifier;
    Result f$$Shared10;
    Result fJeannieC$Statement;
    Result fJeannieC$CompoundStatement;
    Result fJeannieC$CommaExpression;
    Result fJeannieC$AssignmentExpression;
    Result f$$Shared11;
    Result fJeannieC$ConditionalExpression;
    Result fJeannieC$LogicalOrExpression;
    Result f$$Shared12;
  }

  /** Chunk 6 of memoized results. */
  static final class Chunk6 {
    Result f$$Shared13;
    Result f$$Shared14;
    Result f$$Shared15;
    Result f$$Shared16;
    Result fJeannieC$CastExpression;
    Result fJeannieC$UnaryExpression;
    Result f$$Shared17;
    Result fJeannieC$ExpressionList;
    Result fJeannieC$ExpressionList$$Star1;
    Result fJeannieC$AssemblyOperands;
  }

  /** Chunk 7 of memoized results. */
  static final class Chunk7 {
    Result fJeannieC$AssemblyOperands$$Star1;
    Result fJeannieC$AssemblyOperand;
    Result f$$Shared18;
    Result f$$Shared25;
    Result fJeannieC$CInCBlock;
    Result fJeannieC$CInCBlock$$Star1;
    Result fJeannieC$CInCBlock$$Star2;
    Result fJeannieC$JavaThrows;
    Result fCommandC$DeclarationSpecifiers;
    Result fCommandC$InitializedDeclaratorList;
  }

  /** Chunk 8 of memoized results. */
  static final class Chunk8 {
    Result fCommandC$InitializedDeclaratorList$$Star1;
    Result fCommandC$SpecifierQualifierList;
    Result fCommandC$AttributedDeclarator;
    Result fCommandC$Declarator;
    Result fCommandC$Pointer;
    Result fCommandC$VariableLength;
    Result fCommandC$ParameterTypeList;
    Result fCommandC$AbstractDeclarator;
    Result fCommandC$TypeName;
    Result fCommandC$AttributeSpecifierList;
  }

  /** Chunk 9 of memoized results. */
  static final class Chunk9 {
    Result fCommandC$AttributeSpecifier;
    Result fCommandC$Statement;
    Result fCommandC$CompoundStatement;
    Result fCommandC$CommaExpression;
    Result fCommandC$AssignmentExpression;
    Result fCommandC$ConditionalExpression;
    Result fCommandC$LogicalOrExpression;
    Result fCommandC$CastExpression;
    Result fCommandC$UnaryExpression;
    Result fCommandC$ExpressionList;
  }

  /** Chunk 10 of memoized results. */
  static final class Chunk10 {
    Result fCommandC$ExpressionList$$Star1;
    Result fCommandC$AssemblyOperands;
    Result fCommandC$AssemblyOperands$$Star1;
    Result fCommandC$AssemblyOperand;
    Result fCommandC$CInCBlock;
    Result fCommandC$CInCBlock$$Star1;
    Result fCommandC$CInCBlock$$Star2;
    Result fCommandC$JavaThrows;
    Result fJeannieJava$Modifiers;
    Result fJeannieJava$FormalParameters;
  }

  /** Chunk 11 of memoized results. */
  static final class Chunk11 {
    Result fJeannieJava$FormalParameters$$Star1;
    Result fJeannieJava$Declarators;
    Result fJeannieJava$Declarators$$Star1;
    Result fJeannieJava$Block;
    Result fJeannieJava$ParExpression;
    Result fJeannieJava$CatchClause;
    Result fJeannieJava$Expression;
    Result f$$Shared21;
    Result fJeannieJava$ConditionalExpression;
    Result fJeannieJava$LogicalOrExpression;
  }

  /** Chunk 12 of memoized results. */
  static final class Chunk12 {
    Result fJeannieJava$RelationalExpression;
    Result f$$Shared22;
    Result f$$Shared23;
    Result fJeannieJava$VariableInitializer;
    Result f$$Shared26;
    Result fJeannieJava$JavaInJavaBlock;
    Result fJeannieJava$JavaInJavaBlock$$Star1;
    Result fCommandJava$Modifiers;
    Result fCommandJava$FormalParameters;
    Result fCommandJava$FormalParameters$$Star1;
  }

  /** Chunk 13 of memoized results. */
  static final class Chunk13 {
    Result fCommandJava$Declarators;
    Result fCommandJava$Declarators$$Star1;
    Result fCommandJava$Block;
    Result fCommandJava$ParExpression;
    Result fCommandJava$CatchClause;
    Result fCommandJava$Expression;
    Result fCommandJava$ConditionalExpression;
    Result fCommandJava$LogicalOrExpression;
    Result fCommandJava$RelationalExpression;
    Result fCommandJava$VariableInitializer;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class CommandParserColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
    Chunk5 chunk5;
    Chunk6 chunk6;
    Chunk7 chunk7;
    Chunk8 chunk8;
    Chunk9 chunk9;
    Chunk10 chunk10;
    Chunk11 chunk11;
    Chunk12 chunk12;
    Chunk13 chunk13;
  }

  // =========================================================================

  /** The global state object. */
  protected final xtc.lang.CParserState yyState;

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public CommandParser(final Reader reader, final String file) {
    super(reader, file);
    yyState = new xtc.lang.CParserState();
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public CommandParser(final Reader reader, final String file, final int size) {
    super(reader, file, size);
    yyState = new xtc.lang.CParserState();
  }

  // =========================================================================

  protected Column newColumn() {
    return new CommandParserColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.MetaVariable.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMetaVariable(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fMetaVariable) 
      yyColumn.chunk1.fMetaVariable = pMetaVariable$1(yyStart);
    return yyColumn.chunk1.fMetaVariable;
  }

  /** Actually parse xtc.lang.blink.Command.MetaVariable. */
  private Result pMetaVariable$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('$' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pJavaIdentifier$Identifier(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("MetaVariable", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("meta variable expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.CCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pCCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pCCommandNoSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.CCommandNoSpacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCCommandNoSpacing(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Unambiguous>.

    yyResult = pUnambiguousCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Print>.

    yyResult = pPrintCExpressionCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Watch>.

    yyResult = pWatchCExpressionCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.JavaCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pJavaCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pJavaCommandNoSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.JavaCommandNoSpacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJavaCommandNoSpacing(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Unambiguous>.

    yyResult = pUnambiguousCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Print>.

    yyResult = pPrintJavaExpressionCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Watch>.

    yyResult = pWatchJavaFieldCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.UnambiguousCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnambiguousCommand(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fUnambiguousCommand) 
      yyColumn.chunk1.fUnambiguousCommand = pUnambiguousCommand$1(yyStart);
    return yyColumn.chunk1.fUnambiguousCommand;
  }

  /** Actually parse xtc.lang.blink.Command.UnambiguousCommand. */
  private Result pUnambiguousCommand$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pBreakClassCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pBreakFileCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pBreakFunctionCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pC2jCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pContinueCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pDeleteCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pDownCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pExitCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pGdbCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyResult = pHelpCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 11.

    yyResult = pInfoBreakCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 12.

    yyResult = pInfoWatchCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 13.

    yyResult = pInitJCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 14.

    yyResult = pJ2cCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 15.

    yyResult = pJdbCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 16.

    yyResult = pJRetCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 17.

    yyResult = pListCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 18.

    yyResult = pLocalsCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 19.

    yyResult = pNextCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 20.

    yyResult = pRunCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 21.

    yyResult = pStatCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 22.

    yyResult = pStepCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 23.

    yyResult = pUpCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 24.

    yyResult = pWhereCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 25.

    yyResult = pBreakClassMethodCommand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.BreakClassCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBreakClassCommand(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("stop")) {

      yyBase   = yyResult.index;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("at")) {

        yyResult = pQualifiedIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(":")) {

            yyResult = pLineNumber(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final String v$g$2 = yyResult.semanticValue();

              yyResult = pSpacing(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = GNode.create("BreakClassCommand", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'at' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("break class command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.BreakClassMethodCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBreakClassMethodCommand(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("stop")) {

      yyBase   = yyResult.index;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("in")) {

        yyResult = pQualifiedIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyResult = pSpacing(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = GNode.create("BreakClassMethodCommand", v$g$1);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } else {
        yyError = yyError.select("'in' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("break class method command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.BreakFileCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBreakFileCommand(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("break")) {

      yyResult = pCommand$FileName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyResult = pSpacing(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(":")) {

            yyResult = pLineNumber(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final String v$g$2 = yyResult.semanticValue();

              yyResult = pSpacing(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyValue = GNode.create("BreakFileCommand", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("break file command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.BreakFunctionCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBreakFunctionCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("break")) {

      yyResult = pJavaIdentifier$Identifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyResult = pSpacing(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("BreakFunctionCommand", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("break function command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.FileName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommand$FileName(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;
        if (('$' == yyC) ||
            (('.' <= yyC) && (yyC <= '9')) ||
            (('A' <= yyC) && (yyC <= 'Z')) ||
            ('_' == yyC) ||
            (('a' <= yyC) && (yyC <= 'z'))) {

          yyRepetition1 = yyIndex;
          yyRepeated1   = true;
          continue;
        }
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if ('-' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyRepetition1 = yyIndex;
        yyRepeated1   = true;
        continue;
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = difference(yyStart, yyRepetition1);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("file name expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.C2jCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pC2jCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("c2j")) {

      yyValue = GNode.create("C2jCommand", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("c2j command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.ContinueCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pContinueCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("continue")) {

      yyValue = GNode.create("ContinueCommand", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("continue command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.DeleteCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeleteCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("delete")) {

      yyResult = pIntegerLiteral(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("DeleteCommand", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("delete command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.DownCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDownCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("down")) {

      yyResult = pIntegerLiteral(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("DownCommand", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("down command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.ExitCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExitCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("exit")) {

      yyValue = GNode.create("ExitCommand", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("exit command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.GdbCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pGdbCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("gdb")) {

      yyResult = pRestOfLine(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyResult = pSpacing(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("GdbCommand", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("gdb command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.RestOfLine.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRestOfLine(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fRestOfLine) 
      yyColumn.chunk1.fRestOfLine = pRestOfLine$1(yyStart);
    return yyColumn.chunk1.fRestOfLine;
  }

  /** Actually parse xtc.lang.blink.Command.RestOfLine. */
  private Result pRestOfLine$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\n':
      case '\r':
        /* No match. */
        break;

      default:
        {
          yyResult = pRestOfLine(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = difference(yyStart, yyResult.index);

            return yyResult.createValue(yyValue, yyError);
          }
        }
      }
    }

    // Alternative 2.

    yyValue = "";

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.HelpCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHelpCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("help")) {

      yyValue = GNode.create("HelpCommand", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("help command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.InfoBreakCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInfoBreakCommand(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("info")) {

      yyBase   = yyResult.index;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("break")) {

        yyValue = GNode.create("InfoBreakCommand", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'break' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("info break command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.InfoWatchCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInfoWatchCommand(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("info")) {

      yyBase   = yyResult.index;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("watch")) {

        yyValue = GNode.create("InfoWatchCommand", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'watch' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("info watch command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.InitJCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInitJCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("initj")) {

      yyValue = GNode.create("InitJCommand", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("init j command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.J2cCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJ2cCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("j2c")) {

      yyValue = GNode.create("J2cCommand", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("j2c command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.JdbCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJdbCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("jdb")) {

      yyResult = pRestOfLine(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyResult = pSpacing(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("JdbCommand", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("jdb command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.JRetCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJRetCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("jret")) {

      yyValue = GNode.create("JRetCommand", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("j ret command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.ListCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pListCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("list")) {

      yyValue = GNode.create("ListCommand", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("list command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.LocalsCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalsCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("locals")) {

      yyValue = GNode.create("LocalsCommand", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("locals command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.NextCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pNextCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("next")) {

      yyValue = GNode.create("NextCommand", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("next command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.RunCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRunCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("run")) {

      yyValue = GNode.create("RunCommand", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("run command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.PrintCExpressionCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrintCExpressionCommand(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase   = yyResult.index;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("print")) {

        yyResult = pCommandC$CommaExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyValue = GNode.create("PrintCExpressionCommand", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'print' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.PrintJavaExpressionCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrintJavaExpressionCommand(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase   = yyResult.index;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("print")) {

        yyResult = pCommandJava$Expression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyValue = GNode.create("PrintJavaExpressionCommand", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'print' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.StatCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("stat")) {

      yyValue = GNode.create("StatCommand", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("stat command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.StepCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStepCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("step")) {

      yyValue = GNode.create("StepCommand", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("step command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.UpCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUpCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("up")) {

      yyResult = pIntegerLiteral(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("UpCommand", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("up command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.WatchCExpressionCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWatchCExpressionCommand(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase   = yyResult.index;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("watch")) {

        yyResult = pCommandC$CommaExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyValue = GNode.create("WatchCExpressionCommand", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'watch' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.WatchJavaFieldCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWatchJavaFieldCommand(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase   = yyResult.index;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("watch")) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pWatchKind(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final String v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$1.
          final String v$g$1 = yyOpValue1;

          yyResult = pQualifiedIdentifier(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("WatchJavaFieldCommand", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } // End scope for v$g$1.
      } else {
        yyError = yyError.select("'watch' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.WatchKind.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWatchKind(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWatchKind$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.WatchKind$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWatchKind$$Choice1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('c' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('c' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('s' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('s' == yyC) {
                yyIndex = yyIndex + 1;
                yyValue = "access";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }
            }
          }
        }
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('a' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('l' == yyC) {
          yyIndex = yyIndex + 1;
          yyValue = "all";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("watch kind expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.Command.WhereCommand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWhereCommand(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("where")) {

      yyValue = GNode.create("WhereCommand", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("where command expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.Constant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstant(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fConstant) 
      yyColumn.chunk1.fConstant = pConstant$1(yyStart);
    return yyColumn.chunk1.fConstant;
  }

  /** Actually parse xtc.lang.CConstant.Constant. */
  private Result pConstant$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFloatingConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pIntegerConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pCConstant$CharacterConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pCConstant$StringConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.IntegerConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerConstant(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Hex>.

    yyResult = pHexConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("IntegerConstant", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Octal>.

    yyResult = pOctalConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("IntegerConstant", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Decimal>.

    yyResult = pDecimalConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("IntegerConstant", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.DecimalConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalConstant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
                {
                  yyRepetition1 = yyIndex;
                  continue;
                }

              default:
                /* No match. */
              }
            }
            break;
          }

          yyOption1  = yyRepetition1;

          yyResult = pIntegerSuffix(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          yyValue = difference(yyStart, yyOption1);

          return new SemanticValue(yyValue, yyOption1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("decimal constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.HexConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexConstant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pHexPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
          case 'A':
          case 'B':
          case 'C':
          case 'D':
          case 'E':
          case 'F':
          case 'a':
          case 'b':
          case 'c':
          case 'd':
          case 'e':
          case 'f':
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyOption1  = yyRepetition1;

        yyResult = pIntegerSuffix(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("hex constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.HexPrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexPrefix(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (-1 != yyC) {
        yyIndex = yyIndex + 1;

        switch (yyC) {
        case 'X':
        case 'x':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        default:
          /* No match. */
        }
      }
    }

    // Done.
    yyError = yyError.select("hex prefix expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.OctalConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOctalConstant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
            {
              yyRepetition1 = yyIndex;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      yyOption1  = yyRepetition1;

      yyResult = pIntegerSuffix(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }

      yyValue = difference(yyStart, yyOption1);

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("octal constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.IntegerSuffix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerSuffix(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLongLongSuffix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case 'U':
        case 'u':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyValue = null;

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'L':
      case 'l':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case 'U':
            case 'u':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case 'U':
      case 'u':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case 'l':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('l' == yyC) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case 'L':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('L' == yyC) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case 'L':
            case 'l':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 3.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("integer suffix expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.LongLongSuffix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLongLongSuffix(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'l':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('l' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case 'L':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('L' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("long long suffix expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.FloatingConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatingConstant(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Decimal>.

    yyResult = pDecimalFloatingConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("FloatingConstant", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Hex>.

    yyResult = pHexFloatingConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("FloatingConstant", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.DecimalFloatingConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalFloatingConstant(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyC = character(yyRepetition1);
      if ('.' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              {
                yyRepetition1 = yyIndex;
                continue;
              }

            default:
              /* No match. */
            }
          }
          break;
        }

        yyOption1  = yyRepetition1;

        yyResult = pCConstant$Exponent(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }


        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'F':
          case 'L':
          case 'f':
          case 'l':
            {
              yyOption1  = yyIndex;
            }
            break;

          default:
            /* No match. */
          }
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyOption1  = yyRepetition1;

        yyResult = pCConstant$Exponent(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }


        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'F':
          case 'L':
          case 'f':
          case 'l':
            {
              yyOption1  = yyIndex;
            }
            break;

          default:
            /* No match. */
          }
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Alternative 3.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyResult = pCConstant$Exponent(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;

        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'F':
          case 'L':
          case 'f':
          case 'l':
            {
              yyOption1  = yyIndex;
            }
            break;

          default:
            /* No match. */
          }
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("decimal floating constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.HexFloatingConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexFloatingConstant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pHexPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
          case 'A':
          case 'B':
          case 'C':
          case 'D':
          case 'E':
          case 'F':
          case 'a':
          case 'b':
          case 'c':
          case 'd':
          case 'e':
          case 'f':
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyC = character(yyRepetition1);
        if ('.' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyRepetition1 = yyIndex;
          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
              case 'A':
              case 'B':
              case 'C':
              case 'D':
              case 'E':
              case 'F':
              case 'a':
              case 'b':
              case 'c':
              case 'd':
              case 'e':
              case 'f':
                {
                  yyRepetition1 = yyIndex;
                  continue;
                }

              default:
                /* No match. */
              }
            }
            break;
          }

          yyResult = pBinaryExponent(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;

            yyC = character(yyOption1);
            if (-1 != yyC) {
              yyIndex = yyOption1 + 1;

              switch (yyC) {
              case 'F':
              case 'L':
              case 'f':
              case 'l':
                {
                  yyOption1  = yyIndex;
                }
                break;

              default:
                /* No match. */
              }
            }

            yyValue = difference(yyStart, yyOption1);

            return new SemanticValue(yyValue, yyOption1, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if ('.' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyRepetition1 = yyIndex;
        yyRepeated1   = false;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
              {
                yyRepetition1 = yyIndex;
                yyRepeated1   = true;
                continue;
              }

            default:
              /* No match. */
            }
          }
          break;
        }

        if (yyRepeated1) {

          yyResult = pBinaryExponent(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;

            yyC = character(yyOption1);
            if (-1 != yyC) {
              yyIndex = yyOption1 + 1;

              switch (yyC) {
              case 'F':
              case 'L':
              case 'f':
              case 'l':
                {
                  yyOption1  = yyIndex;
                }
                break;

              default:
                /* No match. */
              }
            }

            yyValue = difference(yyStart, yyOption1);

            return new SemanticValue(yyValue, yyOption1, yyError);
          }
        }
      }

      // Nested alternative 3.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
          case 'A':
          case 'B':
          case 'C':
          case 'D':
          case 'E':
          case 'F':
          case 'a':
          case 'b':
          case 'c':
          case 'd':
          case 'e':
          case 'f':
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyResult = pBinaryExponent(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyC = character(yyOption1);
          if (-1 != yyC) {
            yyIndex = yyOption1 + 1;

            switch (yyC) {
            case 'F':
            case 'L':
            case 'f':
            case 'l':
              {
                yyOption1  = yyIndex;
              }
              break;

            default:
              /* No match. */
            }
          }

          yyValue = difference(yyStart, yyOption1);

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("hex floating constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.Exponent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCConstant$Exponent(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fCConstant$Exponent) 
      yyColumn.chunk1.fCConstant$Exponent = pCConstant$Exponent$1(yyStart);
    return yyColumn.chunk1.fCConstant$Exponent;
  }

  /** Actually parse xtc.lang.CConstant.Exponent. */
  private Result pCConstant$Exponent$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'E':
      case 'e':
        {
          yyOption1  = yyIndex;

          yyC = character(yyOption1);
          if (-1 != yyC) {
            yyIndex = yyOption1 + 1;

            switch (yyC) {
            case '+':
            case '-':
              {
                yyOption1  = yyIndex;
              }
              break;

            default:
              /* No match. */
            }
          }

          yyResult = p$$Shared27(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("exponent expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared27.
   * This nonterminal represents the duplicate productions 
   * CConstant.Exponent$$Plus1 
   * and xtc.lang.blink.Command.BinaryExponent$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared27(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.f$$Shared27) 
      yyColumn.chunk1.f$$Shared27 = p$$Shared27$1(yyStart);
    return yyColumn.chunk1.f$$Shared27;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared27. */
  private Result p$$Shared27$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = p$$Shared27(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.BinaryExponent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBinaryExponent(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fBinaryExponent) 
      yyColumn.chunk1.fBinaryExponent = pBinaryExponent$1(yyStart);
    return yyColumn.chunk1.fBinaryExponent;
  }

  /** Actually parse xtc.lang.CConstant.BinaryExponent. */
  private Result pBinaryExponent$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'P':
      case 'p':
        {
          yyOption1  = yyIndex;

          yyC = character(yyOption1);
          if (-1 != yyC) {
            yyIndex = yyOption1 + 1;

            switch (yyC) {
            case '+':
            case '-':
              {
                yyOption1  = yyIndex;
              }
              break;

            default:
              /* No match. */
            }
          }

          yyResult = p$$Shared27(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("binary exponent expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.CharacterConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCConstant$CharacterConstant(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWideCharacterLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = GNode.create("CharacterConstant", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pCConstant$CharacterLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = GNode.create("CharacterConstant", v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.WideCharacterLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWideCharacterLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('L' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pCConstant$CharacterLiteral(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("wide character literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.CharacterLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCConstant$CharacterLiteral(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fCConstant$CharacterLiteral) 
      yyColumn.chunk1.fCConstant$CharacterLiteral = pCConstant$CharacterLiteral$1(yyStart);
    return yyColumn.chunk1.fCConstant$CharacterLiteral;
  }

  /** Actually parse xtc.lang.CConstant.CharacterLiteral. */
  private Result pCConstant$CharacterLiteral$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\'' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pCharacterContents(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyC = character(yyResult.index);
        if ('\'' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("character literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.CharacterContents.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterContents(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '\\':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyResult = pEscapeCode(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              yyRepeated1   = true;
              continue;
            }

            // Nested alternative 2.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;

              switch (yyC) {
              case 'u':
                {
                  yyResult = pHexQuad(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    continue;
                  }
                }
                break;

              case 'U':
                {
                  yyResult = pHexQuad(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pHexQuad(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyRepetition1 = yyResult.index;
                      yyRepeated1   = true;
                      continue;
                    }
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '\n':
        case '\r':
        case '\'':
        case '\\':
          /* No match. */
          break;

        default:
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("character contents expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.StringConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCConstant$StringConstant(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fCConstant$StringConstant) 
      yyColumn.chunk1.fCConstant$StringConstant = pCConstant$StringConstant$1(yyStart);
    return yyColumn.chunk1.fCConstant$StringConstant;
  }

  /** Actually parse xtc.lang.CConstant.StringConstant. */
  private Result pCConstant$StringConstant$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCConstant$StringConstant$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<String> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("StringConstant", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CConstant.StringConstant$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCConstant$StringConstant$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWideStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pCConstant$StringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CConstant.StringConstant$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCConstant$StringConstant$$Plus1(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fCConstant$StringConstant$$Plus1) 
      yyColumn.chunk1.fCConstant$StringConstant$$Plus1 = pCConstant$StringConstant$$Plus1$1(yyStart);
    return yyColumn.chunk1.fCConstant$StringConstant$$Plus1;
  }

  /** Actually parse CConstant.StringConstant$$Plus1. */
  private Result pCConstant$StringConstant$$Plus1$1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCConstant$StringConstant$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pCConstant$StringConstant$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<String> v$4 = yyResult.semanticValue();

        yyValue = new Pair<String>(v$el$1, v$4);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<String>(v$el$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.WideStringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWideStringLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('L' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pCConstant$StringLiteral(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = difference(yyStart, yyResult.index);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("wide string literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.StringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCConstant$StringLiteral(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fCConstant$StringLiteral) 
      yyColumn.chunk2.fCConstant$StringLiteral = pCConstant$StringLiteral$1(yyStart);
    return yyColumn.chunk2.fCConstant$StringLiteral;
  }

  /** Actually parse xtc.lang.CConstant.StringLiteral. */
  private Result pCConstant$StringLiteral$1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pStringContents(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyC = character(yyResult.index);
        if ('\"' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("string literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.StringContents.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringContents(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '\\':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyResult = pEscapeCode(yyChoice2);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              continue;
            }

            // Nested alternative 2.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;

              switch (yyC) {
              case 'u':
                {
                  yyResult = pHexQuad(yyIndex);
                  yyError  = yyResult.select(yyError, yyRepetition1);
                  if (yyResult.hasValue()) {

                    yyRepetition1 = yyResult.index;
                    continue;
                  }
                }
                break;

              case 'U':
                {
                  yyResult = pHexQuad(yyIndex);
                  yyError  = yyResult.select(yyError, yyRepetition1);
                  if (yyResult.hasValue()) {

                    yyResult = pHexQuad(yyResult.index);
                    yyError  = yyResult.select(yyError, yyRepetition1);
                    if (yyResult.hasValue()) {

                      yyRepetition1 = yyResult.index;
                      continue;
                    }
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '\n':
        case '\r':
        case '\"':
        case '\\':
          /* No match. */
          break;

        default:
          {
            yyRepetition1 = yyIndex;
            continue;
          }
        }
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.EscapeCode.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEscapeCode(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\"':
      case '\'':
      case '?':
      case '\\':
      case 'a':
      case 'b':
      case 'f':
      case 'n':
      case 'r':
      case 't':
      case 'v':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
              {
                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                    {
                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyValue = null;

                return new SemanticValue(yyValue, yyChoice2, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case 'x':
        {
          yyRepetition1 = yyIndex;
          yyRepeated1   = false;
          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
              case 'A':
              case 'B':
              case 'C':
              case 'D':
              case 'E':
              case 'F':
              case 'a':
              case 'b':
              case 'c':
              case 'd':
              case 'e':
              case 'f':
                {
                  yyRepetition1 = yyIndex;
                  yyRepeated1   = true;
                  continue;
                }

              default:
                /* No match. */
              }
            }
            break;
          }

          if (yyRepeated1) {

            yyValue = null;

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("escape code expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.HexQuad.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexQuad(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case 'A':
                        case 'B':
                        case 'C':
                        case 'D':
                        case 'E':
                        case 'F':
                        case 'a':
                        case 'b':
                        case 'c':
                        case 'd':
                        case 'e':
                        case 'f':
                          {
                            yyValue = null;

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("hex quad expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSpacing.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    int        yyRepetition2;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '/':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;

              switch (yyC) {
              case '*':
                {
                  yyRepetition2 = yyIndex;
                  while (true) {

                    final int yyChoice2 = yyRepetition2;

                    // Nested alternative 1.

                    yyC = character(yyChoice2);
                    if (-1 != yyC) {
                      yyIndex = yyChoice2 + 1;

                      switch (yyC) {
                      case '*':
                        {
                          yyPredMatched = false;

                          yyC = character(yyIndex);
                          if ('/' == yyC) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyRepetition2 = yyIndex;
                            continue;
                          } else {
                            yyError = yyError.select("spacing expected", yyStart);
                          }
                        }
                        break;

                      default:
                        {
                          yyRepetition2 = yyIndex;
                          continue;
                        }
                      }
                    }
                    break;
                  }

                  yyBase = yyRepetition2;
                  yyC    = character(yyBase);
                  if ('*' == yyC) {
                    yyIndex = yyRepetition2 + 1;

                    yyC = character(yyIndex);
                    if ('/' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyRepetition1 = yyIndex;
                      continue;
                    } else {
                      yyError = yyError.select("'*/' expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("'*/' expected", yyBase);
                  }
                }
                break;

              case '/':
                {
                  yyRepetition2 = yyIndex;
                  while (true) {

                    yyC = character(yyRepetition2);
                    if (-1 != yyC) {
                      yyIndex = yyRepetition2 + 1;

                      switch (yyC) {
                      case '\n':
                      case '\r':
                        /* No match. */
                        break;

                      default:
                        {
                          yyRepetition2 = yyIndex;
                          continue;
                        }
                      }
                    }
                    break;
                  }

                  yyPredResult = pLineTerminator(yyRepetition2);
                  yyError      = yyPredResult.select(yyError);
                  if (yyPredResult.hasValue()) {

                    yyRepetition1 = yyRepetition2;
                    continue;
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
          break;

        case '\r':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('\n' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyResult = pDirective(yyIndex);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {

                yyRepetition1 = yyResult.index;
                continue;
              }
            }

            // Nested alternative 2.

            yyResult = pDirective(yyChoice2);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              continue;
            }
          }
          break;

        case '\n':
          {
            yyResult = pDirective(yyIndex);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              continue;
            }
          }
          break;

        default:
          /* No match. */
        }
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSpacing.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ' ':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\t':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSpacing.LineTerminator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineTerminator(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if ('\n' == yyC) {
            yyIndex = yyChoice1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("line terminator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSpacing.Directive.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDirective(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    String     yyOpValue1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('#' == yyC) {
      yyIndex = yyStart + 1;

      final int yyChoice1 = yyIndex;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (' ' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyResult = pLineNumber(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String line = yyResult.semanticValue();

          yyC = character(yyResult.index);
          if (' ' == yyC) {
            yyIndex = yyResult.index + 1;

            yyC = character(yyIndex);
            if ('\"' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pCSpacing$FileName(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final String file = yyResult.semanticValue();

                yyC = character(yyResult.index);
                if ('\"' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyOption1  = yyIndex;
                  yyOpValue1 = null;

                  yyBase = yyOption1;
                  yyC    = character(yyBase);
                  if (' ' == yyC) {
                    yyIndex = yyOption1 + 1;

                    yyC = character(yyIndex);
                    if ('1' == yyC) {
                      yyIndex = yyIndex + 1;
                      final String v$el$1 = " 1";

                      yyOption1  = yyIndex;
                      yyOpValue1 = v$el$1;
                    } else {
                      yyError = yyError.select("' 1' expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("' 1' expected", yyBase);
                  }
                  { // Start scope for f1.
                    final String f1 = yyOpValue1;

                    yyOpValue1 = null;

                    yyBase = yyOption1;
                    yyC    = character(yyBase);
                    if (' ' == yyC) {
                      yyIndex = yyOption1 + 1;

                      yyC = character(yyIndex);
                      if ('2' == yyC) {
                        yyIndex = yyIndex + 1;
                        final String v$el$2 = " 2";

                        yyOption1  = yyIndex;
                        yyOpValue1 = v$el$2;
                      } else {
                        yyError = yyError.select("' 2' expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("' 2' expected", yyBase);
                    }
                    { // Start scope for f2.
                      final String f2 = yyOpValue1;

                      yyOpValue1 = null;

                      yyBase = yyOption1;
                      yyC    = character(yyBase);
                      if (' ' == yyC) {
                        yyIndex = yyOption1 + 1;

                        yyC = character(yyIndex);
                        if ('3' == yyC) {
                          yyIndex = yyIndex + 1;
                          final String v$el$3 = " 3";

                          yyOption1  = yyIndex;
                          yyOpValue1 = v$el$3;
                        } else {
                          yyError = yyError.select("' 3' expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("' 3' expected", yyBase);
                      }
                      { // Start scope for f3.
                        final String f3 = yyOpValue1;

                        yyOpValue1 = null;

                        yyBase = yyOption1;
                        yyC    = character(yyBase);
                        if (' ' == yyC) {
                          yyIndex = yyOption1 + 1;

                          yyC = character(yyIndex);
                          if ('4' == yyC) {
                            yyIndex = yyIndex + 1;
                            final String v$el$4 = " 4";

                            yyOption1  = yyIndex;
                            yyOpValue1 = v$el$4;
                          } else {
                            yyError = yyError.select("' 4' expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("' 4' expected", yyBase);
                        }
                        { // Start scope for f4.
                          final String f4 = yyOpValue1;

                          yyPredResult = pLineTerminator(yyOption1);
                          yyError      = yyPredResult.select(yyError);
                          if (yyPredResult.hasValue()) {

                            final int lineNo = Integer.parseInt(line);
                            if (RELOCATE) setLocation(yyStart, file, lineNo-1, FIRST_COLUMN);
                            yyState.lineMarker(file, lineNo, f1, f2, f3, f4, location(yyStart));

                            yyValue = null;

                            return new SemanticValue(yyValue, yyOption1, yyError);
                          }
                        } // End scope for f4.
                      } // End scope for f3.
                    } // End scope for f2.
                  } // End scope for f1.
                }
              }
            }
          }
        }
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      while (true) {

        yyResult = pSpace(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }
      { // Start scope for nested choice.

        final int yyChoice2 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice2);
        if (-1 != yyC) {
          yyIndex = yyChoice2 + 1;

          switch (yyC) {
          case 'p':
            {
              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('r' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('a' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('g' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('m' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('a' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if (' ' == yyC) {

                                      yyResult = pPragma(yyIndex);
                                      yyError  = yyResult.select(yyError);
                                      if (yyResult.hasValue()) {
                                        final String pragma = yyResult.semanticValue();

                                        yyPredResult = 
                                          pLineTerminator(yyResult.index);
                                        yyError      = 
                                          yyPredResult.select(yyError);
                                        if (yyPredResult.hasValue()) {

                                          yyState.pragma(pragma, location(yyStart));

                                          yyValue = null;

                                          return yyResult.createValue(yyValue, yyError);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            break;

          case 'i':
            {
              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('d' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('n' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('t' == yyC) {

                              yyRepetition1 = yyIndex;
                              yyRepeated1   = false;
                              while (true) {

                                yyResult = pSpace(yyRepetition1);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyRepetition1 = yyResult.index;
                                  yyRepeated1   = true;
                                  continue;
                                }
                                break;
                              }

                              if (yyRepeated1) {

                                yyC = character(yyRepetition1);
                                if ('\"' == yyC) {
                                  yyIndex = yyRepetition1 + 1;

                                  yyResult = pCSpacing$FileName(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {
                                    final String s = yyResult.semanticValue();

                                    yyC = character(yyResult.index);
                                    if ('\"' == yyC) {
                                      yyIndex = yyResult.index + 1;

                                      yyPredResult = pLineTerminator(yyIndex);
                                      yyError      = 
                                        yyPredResult.select(yyError);
                                      if (yyPredResult.hasValue()) {

                                        yyState.ident(s, location(yyStart));

                                        yyValue = null;

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            break;

          default:
            /* No match. */
          }
        }
      } // End scope for nested choice.
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSpacing.LineNumber.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineNumber(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
                {
                  yyRepetition1 = yyIndex;
                  continue;
                }

              default:
                /* No match. */
              }
            }
            break;
          }

          yyValue = difference(yyStart, yyRepetition1);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("line number expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSpacing.FileName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCSpacing$FileName(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '\\':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '\"':
        case '\\':
          /* No match. */
          break;

        default:
          {
            yyRepetition1 = yyIndex;
            continue;
          }
        }
      }
      break;
    }

    yyValue = difference(yyStart, yyRepetition1);

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSpacing.Pragma.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPragma(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '\n':
        case '\r':
          /* No match. */
          break;

        default:
          {
            yyRepetition1 = yyIndex;
            continue;
          }
        }
      }
      break;
    }

    yyValue = difference(yyStart, yyRepetition1);

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieSymbol.Symbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fSymbol) 
      yyColumn.chunk2.fSymbol = pSymbol$1(yyStart);
    return yyColumn.chunk2.fSymbol;
  }

  /** Actually parse xtc.lang.jeannie.JeannieSymbol.Symbol. */
  private Result pSymbol$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbolCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieSymbol.SymbolCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbolCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '>':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '>':
              {
                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;

                  switch (yyC) {
                  case '>':
                    {
                      final int yyChoice3 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice3);
                      if (-1 != yyC) {
                        yyIndex = yyChoice3 + 1;
                        if ('=' == yyC) {

                          yyValue = ">>>=";

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }

                      // Nested alternative 2.

                      yyValue = ">>>";

                      return new SemanticValue(yyValue, yyChoice3, yyError);
                    }

                  case '=':
                    {
                      yyValue = ">>=";

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyValue = ">>";

                return new SemanticValue(yyValue, yyChoice2, yyError);
              }

            case '=':
              {
                yyValue = ">=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = ">";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '<':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '<':
              {
                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;
                  if ('=' == yyC) {

                    yyValue = "<<=";

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }

                // Nested alternative 2.

                yyValue = "<<";

                return new SemanticValue(yyValue, yyChoice2, yyError);
              }

            case '=':
              {
                yyValue = "<=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "<";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '.':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('.' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('.' == yyC) {

                  yyValue = "...";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }

          // Nested alternative 2.

          yyValue = ".";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '+':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "+=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '+':
              {
                yyValue = "++";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "+";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '-':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "-=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '-':
              {
                yyValue = "--";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '>':
              {
                yyValue = "->";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "-";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '*':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "*=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "*";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '/':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "/=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "/";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '%':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "%=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "%";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '&':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "&=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '&':
              {
                yyValue = "&&";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "&";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '^':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "^=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "^";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '|':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "|=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '|':
              {
                yyValue = "||";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = "|";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '=':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "==";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "=";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '!':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = "!=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = "!";

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case ';':
        {
          yyValue = ";";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ':':
        {
          yyValue = ":";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ',':
        {
          yyValue = ",";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '{':
        {
          yyValue = "{";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = "}";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '(':
        {
          yyValue = "(";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ')':
        {
          yyValue = ")";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = "[";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '`':
        {
          yyValue = "`";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '~':
        {
          yyValue = "~";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '?':
        {
          yyValue = "?";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("symbol characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CIdentifier.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCIdentifier$Identifier(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fCIdentifier$Identifier) 
      yyColumn.chunk2.fCIdentifier$Identifier = pCIdentifier$Identifier$1(yyStart);
    return yyColumn.chunk2.fCIdentifier$Identifier;
  }

  /** Actually parse xtc.lang.CIdentifier.Identifier. */
  private Result pCIdentifier$Identifier$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCIdentifier$Word(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (! contains(C_KEYWORDS, toText(yyValue))) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("identifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CIdentifier.Keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pKeyword(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fKeyword) 
      yyColumn.chunk2.fKeyword = pKeyword$1(yyStart);
    return yyColumn.chunk2.fKeyword;
  }

  /** Actually parse xtc.lang.CIdentifier.Keyword. */
  private Result pKeyword$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCIdentifier$Word(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (contains(C_KEYWORDS, toText(yyValue))) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("keyword expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CIdentifier.Word.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCIdentifier$Word(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fCIdentifier$Word) 
      yyColumn.chunk2.fCIdentifier$Word = pCIdentifier$Word$1(yyStart);
    return yyColumn.chunk2.fCIdentifier$Word;
  }

  /** Actually parse xtc.lang.CIdentifier.Word. */
  private Result pCIdentifier$Word$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCIdentifier$WordCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CIdentifier.WordCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCIdentifier$WordCharacters(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            if ((('0' <= yyC) && (yyC <= '9')) ||
                (('A' <= yyC) && (yyC <= 'Z')) ||
                ('_' == yyC) ||
                (('a' <= yyC) && (yyC <= 'z'))) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("word characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CContext.TypedefContext.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypedefContext(final int yyStart) throws IOException {
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyState.typedef();

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CContext.ParameterContext.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameterContext(final int yyStart) throws IOException {
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyState.parameters();

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CContext.TypeSpecContext.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeSpecContext(final int yyStart) throws IOException {
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyState.typeSpecifier();

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CContext.PushScope.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPushScope(final int yyStart) throws IOException {
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyState.pushScope();

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CContext.PopScope.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPopScope(final int yyStart) throws IOException {
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyState.popScope();

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CContext.EnterStructure.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnterStructure(final int yyStart) throws IOException {
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyState.enterStructure();

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CContext.ExitStructure.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExitStructure(final int yyStart) throws IOException {
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyState.exitStructure();

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaType.ResultType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pResultType(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fResultType) 
      yyColumn.chunk2.fResultType = pResultType$1(yyStart);
    return yyColumn.chunk2.fResultType;
  }

  /** Actually parse xtc.lang.JavaType.ResultType. */
  private Result pResultType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Void>.

    yyResult = pVoidType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Regular>.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaType.VoidType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVoidType(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Void>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("void")) {

      yyValue = GNode.create("VoidType", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("void type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaType.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fType) 
      yyColumn.chunk2.fType = pType$1(yyStart);
    return yyColumn.chunk2.fType;
  }

  /** Actually parse xtc.lang.JavaType.Type. */
  private Result pType$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Type>.

    yyResult = pJavaType$TypeName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pDimensions(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("Type", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaType.TypeName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJavaType$TypeName(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fJavaType$TypeName) 
      yyColumn.chunk2.fJavaType$TypeName = pJavaType$TypeName$1(yyStart);
    return yyColumn.chunk2.fJavaType$TypeName;
  }

  /** Actually parse xtc.lang.JavaType.TypeName. */
  private Result pJavaType$TypeName$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Basic>.

    yyResult = pPrimitiveType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Class>.

    yyResult = pQualifiedIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaType.PrimitiveType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimitiveType(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fPrimitiveType) 
      yyColumn.chunk2.fPrimitiveType = pPrimitiveType$1(yyStart);
    return yyColumn.chunk2.fPrimitiveType;
  }

  /** Actually parse xtc.lang.JavaType.PrimitiveType. */
  private Result pPrimitiveType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Byte>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("byte")) {
      final String v$g$1 = "byte";

      yyValue = GNode.create("PrimitiveType", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Short>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("short")) {
      final String v$g$2 = "short";

      yyValue = GNode.create("PrimitiveType", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Char>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("char")) {
      final String v$g$3 = "char";

      yyValue = GNode.create("PrimitiveType", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Int>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("int")) {
      final String v$g$4 = "int";

      yyValue = GNode.create("PrimitiveType", v$g$4);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Long>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("long")) {
      final String v$g$5 = "long";

      yyValue = GNode.create("PrimitiveType", v$g$5);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Float>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("float")) {
      final String v$g$6 = "float";

      yyValue = GNode.create("PrimitiveType", v$g$6);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Double>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("double")) {
      final String v$g$7 = "double";

      yyValue = GNode.create("PrimitiveType", v$g$7);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Boolean>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("boolean")) {
      final String v$g$8 = "boolean";

      yyValue = GNode.create("PrimitiveType", v$g$8);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("primitive type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaType.Dimensions.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimensions(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fDimensions) 
      yyColumn.chunk2.fDimensions = pDimensions$1(yyStart);
    return yyColumn.chunk2.fDimensions;
  }

  /** Actually parse xtc.lang.JavaType.Dimensions. */
  private Result pDimensions$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDimensions$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<String> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("Dimensions", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.Dimensions$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimensions$$Plus1(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fDimensions$$Plus1) 
      yyColumn.chunk3.fDimensions$$Plus1 = pDimensions$$Plus1$1(yyStart);
    return yyColumn.chunk3.fDimensions$$Plus1;
  }

  /** Actually parse xtc.lang.blink.Command.Dimensions$$Plus1. */
  private Result pDimensions$$Plus1$1(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyBase;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {
      final String v$el$1 = "[";

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("]")) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pDimensions$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<String> v$2 = yyResult.semanticValue();

          yyValue = new Pair<String>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = new Pair<String>(v$el$1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      } else {
        yyError = yyError.select("']' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("dimensions expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.Literal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fLiteral) 
      yyColumn.chunk3.fLiteral = pLiteral$1(yyStart);
    return yyColumn.chunk3.fLiteral;
  }

  /** Actually parse xtc.lang.JavaConstant.Literal. */
  private Result pLiteral$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <FloatingPoint>.

    yyResult = pFloatingPointLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Integer>.

    yyResult = pIntegerLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Character>.

    yyResult = pJavaConstant$CharacterLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <String>.

    yyResult = pJavaConstant$StringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <True>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("true")) {
      final String v$g$1 = "true";

      yyValue = GNode.create("BooleanLiteral", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <False>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("false")) {
      final String v$g$2 = "false";

      yyValue = GNode.create("BooleanLiteral", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Null>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("null")) {

      yyValue = GNode.create("NullLiteral", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.IntegerLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerLiteral(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fIntegerLiteral) 
      yyColumn.chunk3.fIntegerLiteral = pIntegerLiteral$1(yyStart);
    return yyColumn.chunk3.fIntegerLiteral;
  }

  /** Actually parse xtc.lang.JavaConstant.IntegerLiteral. */
  private Result pIntegerLiteral$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Hex>.

    yyResult = pHexLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("IntegerLiteral", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Octal>.

    yyResult = pOctalLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("IntegerLiteral", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Decimal>.

    yyResult = pDecimalLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("IntegerLiteral", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.HexLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pHexNumeral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'L':
        case 'l':
          {
            yyOption1  = yyIndex;
          }
          break;

        default:
          /* No match. */
        }
      }

      yyValue = difference(yyStart, yyOption1);

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("hex literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.OctalLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOctalLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOctalNumeral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'L':
        case 'l':
          {
            yyOption1  = yyIndex;
          }
          break;

        default:
          /* No match. */
        }
      }

      yyValue = difference(yyStart, yyOption1);

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("octal literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.DecimalLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDecimalNumeral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'L':
        case 'l':
          {
            yyOption1  = yyIndex;
          }
          break;

        default:
          /* No match. */
        }
      }

      yyValue = difference(yyStart, yyOption1);

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("decimal literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.DecimalNumeral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalNumeral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyOption1  = yyIndex;

          yyResult = pDigits(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          yyValue = null;

          return new SemanticValue(yyValue, yyOption1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("decimal numeral expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.Digits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.HexNumeral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexNumeral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (-1 != yyC) {
        yyIndex = yyIndex + 1;

        switch (yyC) {
        case 'X':
        case 'x':
          {
            yyResult = pHexDigits(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = null;

              return yyResult.createValue(yyValue, yyError);
            }
          }
          break;

        default:
          /* No match. */
        }
      }
    }

    // Done.
    yyError = yyError.select("hex numeral expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.HexDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("hex digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.OctalNumeral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOctalNumeral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pOctalDigits(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("octal numeral expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.OctalDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOctalDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("octal digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.FloatingPointLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatingPointLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFloatingPointString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("FloatingPointLiteral", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.FloatingPointString.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatingPointString(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDigits(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyC = character(yyResult.index);
      if ('.' == yyC) {
        yyIndex = yyResult.index + 1;

        yyOption1  = yyIndex;

        yyResult = pDigits(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }


        yyResult = pJavaConstant$Exponent(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }


        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'D':
          case 'F':
          case 'd':
          case 'f':
            {
              yyOption1  = yyIndex;
            }
            break;

          default:
            /* No match. */
          }
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pDigits(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;

        yyResult = pJavaConstant$Exponent(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }


        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'D':
          case 'F':
          case 'd':
          case 'f':
            {
              yyOption1  = yyIndex;
            }
            break;

          default:
            /* No match. */
          }
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Alternative 3.

    yyResult = pDigits(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pJavaConstant$Exponent(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;

        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'D':
          case 'F':
          case 'd':
          case 'f':
            {
              yyOption1  = yyIndex;
            }
            break;

          default:
            /* No match. */
          }
        }

        yyValue = difference(yyStart, yyOption1);

        return new SemanticValue(yyValue, yyOption1, yyError);
      }

      // Nested alternative 2.

      yyOption1  = yyChoice1;

      yyResult = pJavaConstant$Exponent(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'D':
        case 'F':
        case 'd':
        case 'f':
          {
            yyValue = difference(yyStart, yyIndex);

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        default:
          /* No match. */
        }
      }
    }

    // Done.
    yyError = yyError.select("floating point string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.Exponent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJavaConstant$Exponent(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'E':
      case 'e':
        {
          yyOption1  = yyIndex;

          yyC = character(yyOption1);
          if (-1 != yyC) {
            yyIndex = yyOption1 + 1;

            switch (yyC) {
            case '+':
            case '-':
              {
                yyOption1  = yyIndex;
              }
              break;

            default:
              /* No match. */
            }
          }

          yyResult = pDigits(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("exponent expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.CharacterLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJavaConstant$CharacterLiteral(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaConstant$CharacterConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("CharacterLiteral", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.StringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJavaConstant$StringLiteral(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaConstant$StringConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("StringLiteral", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.CharacterConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJavaConstant$CharacterConstant(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\'' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pJavaConstant$CharacterConstant$$Choice1(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyC = character(yyResult.index);
        if ('\'' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("character constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JavaConstant.CharacterConstant$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJavaConstant$CharacterConstant$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\\':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '\"':
            case '\'':
            case '\\':
            case 'b':
            case 'f':
            case 'n':
            case 'r':
            case 't':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case 'u':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case 'A':
                        case 'B':
                        case 'C':
                        case 'D':
                        case 'E':
                        case 'F':
                        case 'a':
                        case 'b':
                        case 'c':
                        case 'd':
                        case 'e':
                        case 'f':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;

                              switch (yyC) {
                              case '0':
                              case '1':
                              case '2':
                              case '3':
                              case '4':
                              case '5':
                              case '6':
                              case '7':
                              case '8':
                              case '9':
                              case 'A':
                              case 'B':
                              case 'C':
                              case 'D':
                              case 'E':
                              case 'F':
                              case 'a':
                              case 'b':
                              case 'c':
                              case 'd':
                              case 'e':
                              case 'f':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;

                                    switch (yyC) {
                                    case '0':
                                    case '1':
                                    case '2':
                                    case '3':
                                    case '4':
                                    case '5':
                                    case '6':
                                    case '7':
                                    case '8':
                                    case '9':
                                    case 'A':
                                    case 'B':
                                    case 'C':
                                    case 'D':
                                    case 'E':
                                    case 'F':
                                    case 'a':
                                    case 'b':
                                    case 'c':
                                    case 'd':
                                    case 'e':
                                    case 'f':
                                      {
                                        yyValue = null;

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }

                                    default:
                                      /* No match. */
                                    }
                                  }
                                }
                                break;

                              default:
                                /* No match. */
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.
          { // Start scope for nested choice.

            final int yyChoice2 = yyChoice1;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
                {
                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;

                          switch (yyC) {
                          case '0':
                          case '1':
                          case '2':
                          case '3':
                          case '4':
                          case '5':
                          case '6':
                          case '7':
                            {
                              yyValue = null;

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }

                          default:
                            /* No match. */
                          }
                        }
                      }
                      break;

                    default:
                      /* No match. */
                    }
                  }
                }
                break;

              default:
                /* No match. */
              }
            }

            // Nested alternative 2.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
                {
                  final int yyChoice3 = yyIndex;

                  // Nested alternative 1.

                  yyC = character(yyChoice3);
                  if (-1 != yyC) {
                    yyIndex = yyChoice3 + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                      {
                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }

                    default:
                      /* No match. */
                    }
                  }

                  // Nested alternative 2.

                  yyValue = null;

                  return new SemanticValue(yyValue, yyChoice3, yyError);
                }

              default:
                /* No match. */
              }
            }
          } // End scope for nested choice.
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\'':
      case '\\':
        /* No match. */
        break;

      default:
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("character constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.StringConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJavaConstant$StringConstant(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\\':
            {
              final int yyChoice2 = yyIndex;

              // Nested alternative 1.

              yyC = character(yyChoice2);
              if (-1 != yyC) {
                yyIndex = yyChoice2 + 1;

                switch (yyC) {
                case '\"':
                case '\'':
                case '\\':
                case 'b':
                case 'f':
                case 'n':
                case 'r':
                case 't':
                  {
                    yyRepetition1 = yyIndex;
                    continue;
                  }

                case 'u':
                  {
                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;

                      switch (yyC) {
                      case '0':
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                      case 'A':
                      case 'B':
                      case 'C':
                      case 'D':
                      case 'E':
                      case 'F':
                      case 'a':
                      case 'b':
                      case 'c':
                      case 'd':
                      case 'e':
                      case 'f':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                            case 'A':
                            case 'B':
                            case 'C':
                            case 'D':
                            case 'E':
                            case 'F':
                            case 'a':
                            case 'b':
                            case 'c':
                            case 'd':
                            case 'e':
                            case 'f':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;

                                  switch (yyC) {
                                  case '0':
                                  case '1':
                                  case '2':
                                  case '3':
                                  case '4':
                                  case '5':
                                  case '6':
                                  case '7':
                                  case '8':
                                  case '9':
                                  case 'A':
                                  case 'B':
                                  case 'C':
                                  case 'D':
                                  case 'E':
                                  case 'F':
                                  case 'a':
                                  case 'b':
                                  case 'c':
                                  case 'd':
                                  case 'e':
                                  case 'f':
                                    {
                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;

                                        switch (yyC) {
                                        case '0':
                                        case '1':
                                        case '2':
                                        case '3':
                                        case '4':
                                        case '5':
                                        case '6':
                                        case '7':
                                        case '8':
                                        case '9':
                                        case 'A':
                                        case 'B':
                                        case 'C':
                                        case 'D':
                                        case 'E':
                                        case 'F':
                                        case 'a':
                                        case 'b':
                                        case 'c':
                                        case 'd':
                                        case 'e':
                                        case 'f':
                                          {
                                            yyRepetition1 = yyIndex;
                                            continue;
                                          }

                                        default:
                                          /* No match. */
                                        }
                                      }
                                    }
                                    break;

                                  default:
                                    /* No match. */
                                  }
                                }
                              }
                              break;

                            default:
                              /* No match. */
                            }
                          }
                        }
                        break;

                      default:
                        /* No match. */
                      }
                    }
                  }
                  break;

                default:
                  /* No match. */
                }
              }

              // Nested alternative 2.
              { // Start scope for nested choice.

                final int yyChoice3 = yyChoice2;

                // Nested alternative 1.

                yyC = character(yyChoice3);
                if (-1 != yyC) {
                  yyIndex = yyChoice3 + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;

                              switch (yyC) {
                              case '0':
                              case '1':
                              case '2':
                              case '3':
                              case '4':
                              case '5':
                              case '6':
                              case '7':
                                {
                                  yyRepetition1 = yyIndex;
                                  continue;
                                }

                              default:
                                /* No match. */
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyC = character(yyChoice3);
                if (-1 != yyC) {
                  yyIndex = yyChoice3 + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                    {
                      final int yyChoice4 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice4);
                      if (-1 != yyC) {
                        yyIndex = yyChoice4 + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                          {
                            yyRepetition1 = yyIndex;
                            continue;
                          }

                        default:
                          /* No match. */
                        }
                      }

                      // Nested alternative 2.

                      yyRepetition1 = yyChoice4;
                      continue;
                    }

                  default:
                    /* No match. */
                  }
                }
              } // End scope for nested choice.
            }
            break;

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\"':
          case '\\':
            /* No match. */
            break;

          default:
            {
              yyRepetition1 = yyIndex;
              continue;
            }
          }
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('\"' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = difference(yyStart, yyIndex);

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("string constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaIdentifier.QualifiedIdentifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualifiedIdentifier(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fQualifiedIdentifier) 
      yyColumn.chunk3.fQualifiedIdentifier = pQualifiedIdentifier$1(yyStart);
    return yyColumn.chunk3.fQualifiedIdentifier;
  }

  /** Actually parse xtc.lang.JavaIdentifier.QualifiedIdentifier. */
  private Result pQualifiedIdentifier$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyResult = pQualifiedIdentifier$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<String> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("QualifiedIdentifier", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * xtc.lang.blink.Command.QualifiedIdentifier$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualifiedIdentifier$$Star1(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fQualifiedIdentifier$$Star1) 
      yyColumn.chunk3.fQualifiedIdentifier$$Star1 = pQualifiedIdentifier$$Star1$1(yyStart);
    return yyColumn.chunk3.fQualifiedIdentifier$$Star1;
  }

  /** Actually parse xtc.lang.blink.Command.QualifiedIdentifier$$Star1. */
  private Result pQualifiedIdentifier$$Star1$1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Pair<String> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(".")) {

      yyResult = pJavaIdentifier$Identifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$el$1 = yyResult.semanticValue();

        yyResult = pQualifiedIdentifier$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<String> v$2 = yyResult.semanticValue();

          yyValue = new Pair<String>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaIdentifier.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJavaIdentifier$Identifier(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fJavaIdentifier$Identifier) 
      yyColumn.chunk3.fJavaIdentifier$Identifier = pJavaIdentifier$Identifier$1(yyStart);
    return yyColumn.chunk3.fJavaIdentifier$Identifier;
  }

  /** Actually parse xtc.lang.JavaIdentifier.Identifier. */
  private Result pJavaIdentifier$Identifier$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (! contains(JAVA_KEYWORDS, toText(yyValue))) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("identifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaIdentifier.Word.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJavaIdentifier$Word(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fJavaIdentifier$Word) 
      yyColumn.chunk3.fJavaIdentifier$Word = pJavaIdentifier$Word$1(yyStart);
    return yyColumn.chunk3.fJavaIdentifier$Word;
  }

  /** Actually parse xtc.lang.JavaIdentifier.Word. */
  private Result pJavaIdentifier$Word$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$WordCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaIdentifier.WordCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJavaIdentifier$WordCharacters(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      final char start = (char)yyC;

      if (Character.isJavaIdentifierStart(start)) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            final char part = (char)yyC;

            if (Character.isJavaIdentifierPart(part)) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("word characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared6.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieC.Annotations 
   * and xtc.lang.blink.CommandC.Annotations.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared6(final int yyStart) throws IOException {
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative 1.

    yyState.mark();
    yyValue = yyState.annotate(null);

    // Commit the state modification.
    yyState.commit();

    setLocation(yyValue, yyStart);
    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.Declaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$Declaration(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pKeyword(yyBase);
    if (yyResult.hasValue("__extension__")) {
      final String v$el$1 = "__extension__";

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    } else {
      yyError = yyError.select("'__extension__' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final String v$g$1 = cast(yyOpValue1);

      yyResult = pJeannieC$DeclarationSpecifiers(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pJeannieC$InitializedDeclaratorList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for l.
          final Node l = cast(yyOpValue1);

          if (yyState.isValid(l)) {

            yyBase   = yyOption1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(";")) {

              yyValue = GNode.create("Declaration", v$g$1, v$g$2, l);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("';' expected", yyBase);
            }
          }
        } // End scope for l.
      }
    } // End scope for v$g$1.

    // Done.
    yyError = yyError.select("declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.DeclarationSpecifiers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$DeclarationSpecifiers(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fJeannieC$DeclarationSpecifiers) 
      yyColumn.chunk3.fJeannieC$DeclarationSpecifiers = pJeannieC$DeclarationSpecifiers$1(yyStart);
    return yyColumn.chunk3.fJeannieC$DeclarationSpecifiers;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.DeclarationSpecifiers. */
  private Result pJeannieC$DeclarationSpecifiers$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieC$DeclarationSpecifierPlus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("DeclarationSpecifiers", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.DeclarationSpecifierPlus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$DeclarationSpecifierPlus(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pJeannieC$DeclarationSpecifier(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.DeclarationSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$DeclarationSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <StorageClass>.

    yyResult = pJeannieC$StorageClassSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <TypeSpecifier>.

    yyResult = pJeannieC$TypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pTypeSpecContext(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <TypeQualifier>.

    yyResult = pJeannieC$TypeQualifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("inline")) {
      final String v$g$1 = "inline";

      yyValue = GNode.create("FunctionSpecifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__inline")) {
      final String v$g$2 = "__inline";

      yyValue = GNode.create("FunctionSpecifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__inline__")) {
      final String v$g$3 = "__inline__";

      yyValue = GNode.create("FunctionSpecifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Attribute>.

    yyResult = pJeannieC$AttributeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("declaration specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.InitializedDeclaratorList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$InitializedDeclaratorList(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fJeannieC$InitializedDeclaratorList) 
      yyColumn.chunk3.fJeannieC$InitializedDeclaratorList = pJeannieC$InitializedDeclaratorList$1(yyStart);
    return yyColumn.chunk3.fJeannieC$InitializedDeclaratorList;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.InitializedDeclaratorList. */
  private Result pJeannieC$InitializedDeclaratorList$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <List>.

    yyResult = pJeannieC$InitializedDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pJeannieC$InitializedDeclaratorList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("InitializedDeclaratorList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.InitializedDeclaratorList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$InitializedDeclaratorList$$Star1(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fJeannieC$InitializedDeclaratorList$$Star1) 
      yyColumn.chunk3.fJeannieC$InitializedDeclaratorList$$Star1 = pJeannieC$InitializedDeclaratorList$$Star1$1(yyStart);
    return yyColumn.chunk3.fJeannieC$InitializedDeclaratorList$$Star1;
  }

  /** Actually parse JeannieC.InitializedDeclaratorList$$Star1. */
  private Result pJeannieC$InitializedDeclaratorList$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pJeannieC$InitializedDeclarator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyResult = pJeannieC$InitializedDeclaratorList$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.InitializedDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$InitializedDeclarator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pJeannieC$AttributeSpecifierList(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pJeannieC$Declarator(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pJeannieC$SimpleAssemblyExpression(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyOpValue1 = null;

          yyResult = pJeannieC$AttributeSpecifierList(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
          { // Start scope for v$g$4.
            final Node v$g$4 = yyOpValue1;

            yyOpValue1 = null;

            yyBase   = yyOption1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue("=")) {

              yyResult = pJeannieC$Initializer(yyResult.index);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                final Node v$el$4 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$4;
              }
            } else {
              yyError = yyError.select("'=' expected", yyBase);
            }
            { // Start scope for v$g$5.
              final Node v$g$5 = yyOpValue1;

              yyValue = GNode.create("InitializedDeclarator", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$g$5.
          } // End scope for v$g$4.
        } // End scope for v$g$3.
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.StorageClassSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$StorageClassSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("auto")) {

      yyValue = GNode.create("AutoSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("extern")) {

      yyValue = GNode.create("ExternSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("register")) {

      yyValue = GNode.create("RegisterSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("static")) {

      yyValue = GNode.create("StaticSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__thread")) {

      yyValue = GNode.create("ThreadSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("typedef")) {

      yyResult = pTypedefContext(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = GNode.create("TypedefSpecifier", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("storage class specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.TypeQualifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$TypeQualifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("volatile")) {
      final String v$g$1 = "volatile";

      yyValue = GNode.create("VolatileQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__volatile")) {
      final String v$g$2 = "__volatile";

      yyValue = GNode.create("VolatileQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__volatile__")) {
      final String v$g$3 = "__volatile__";

      yyValue = GNode.create("VolatileQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("const")) {
      final String v$g$1 = "const";

      yyValue = GNode.create("ConstantQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__const")) {
      final String v$g$2 = "__const";

      yyValue = GNode.create("ConstantQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__const__")) {
      final String v$g$3 = "__const__";

      yyValue = GNode.create("ConstantQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("restrict")) {
      final String v$g$1 = "restrict";

      yyValue = GNode.create("RestrictQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__restrict")) {
      final String v$g$2 = "__restrict";

      yyValue = GNode.create("RestrictQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__restrict__")) {
      final String v$g$3 = "__restrict__";

      yyValue = GNode.create("RestrictQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("type qualifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.TypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$TypeSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Enumeration>.

    yyResult = pJeannieC$EnumerationTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Structure>.

    yyResult = pJeannieC$StructureTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Union>.

    yyResult = pJeannieC$UnionTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Floating>.

    yyResult = pJeannieC$FloatingPointTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Integer>.

    yyResult = pJeannieC$IntegerTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <JavaTyp>.

    yyResult = pJeannieC$JavaType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String id = yyResult.semanticValue();

      if (yyState.isType(toText(id))) {

        yyValue = GNode.create("TypedefName", id);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 8.

    yyResult = p$$Shared9(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pJeannieC$TypeName(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("TypeofSpecifier", v$g$1);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }

        // Nested alternative 2.

        yyResult = pJeannieC$CommaExpression(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("TypeofSpecifier", v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 9.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("void")) {

      yyValue = GNode.create("VoidTypeSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__builtin_va_list")) {

      yyValue = GNode.create("VarArgListSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.EnumerationTypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$EnumerationTypeSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("enum")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pJeannieC$AttributeSpecifierList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = cast(yyOpValue1);

        final int yyChoice1 = yyOption1;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pCIdentifier$Identifier(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final String v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$2.
          final String v$g$2 = cast(yyOpValue1);

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("{")) {

            yyResult = pJeannieC$EnumeratorList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(",")) {

                yyOption1  = yyResult.index;
              } else {
                yyError = yyError.select("',' expected", yyBase);
              }

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue("}")) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pJeannieC$AttributeSpecifierList(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  final Node v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
                { // Start scope for v$g$4.
                  final Node v$g$4 = cast(yyOpValue1);

                  yyValue = GNode.create("EnumerationTypeDefinition", v$g$1, v$g$2, v$g$3, v$g$4);
                  yyValue.setLocation(location(yyStart));

                  return new SemanticValue(yyValue, yyOption1, yyError);
                } // End scope for v$g$4.
              } else {
                yyError = yyError.select("'}' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("'{' expected", yyBase);
          }
        } // End scope for v$g$2.

        // Nested alternative 2.

        yyResult = pCIdentifier$Identifier(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("EnumerationTypeReference", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("enumeration type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.EnumeratorList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$EnumeratorList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <List>.

    yyResult = pJeannieC$Enumerator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pJeannieC$Enumerator(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("EnumeratorList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.Enumerator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$Enumerator(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Enumerator>.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String id = yyResult.semanticValue();

      yyState.bind(toText(id), false);

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("=")) {

        yyResult = pJeannieC$ConditionalExpression(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = yyOpValue1;

        yyValue = GNode.create("Enumerator", id, v$g$1);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.StructureTypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$StructureTypeSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("struct")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pJeannieC$AttributeSpecifierList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = cast(yyOpValue1);

        final int yyChoice1 = yyOption1;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pCIdentifier$Identifier(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final String v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$2.
          final String v$g$2 = cast(yyOpValue1);

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("{")) {

            yyResult = pPushScope(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pEnterStructure(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pJeannieC$StructureDeclarationList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$3 = yyResult.semanticValue();

                  yyBase   = yyResult.index;
                  yyResult = pSymbol(yyBase);
                  if (yyResult.hasValue("}")) {

                    yyResult = pExitStructure(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pPopScope(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyOption1  = yyResult.index;
                        yyOpValue1 = null;

                        yyResult = 
                          pJeannieC$AttributeSpecifierList(yyOption1);
                        yyError  = yyResult.select(yyError, yyOption1);
                        if (yyResult.hasValue()) {
                          final Node v$el$3 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$3;
                        }
                        { // Start scope for v$g$4.
                          final Node v$g$4 = cast(yyOpValue1);

                          yyValue = GNode.create("StructureTypeDefinition", v$g$1, v$g$2, v$g$3, v$g$4);
                          yyValue.setLocation(location(yyStart));

                          return new SemanticValue(yyValue, yyOption1, yyError);
                        } // End scope for v$g$4.
                      }
                    }
                  } else {
                    yyError = yyError.select("'}' expected", yyBase);
                  }
                }
              }
            }
          } else {
            yyError = yyError.select("'{' expected", yyBase);
          }
        } // End scope for v$g$2.

        // Nested alternative 2.

        yyResult = pCIdentifier$Identifier(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("StructureTypeReference", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("structure type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.UnionTypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$UnionTypeSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("union")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pJeannieC$AttributeSpecifierList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = cast(yyOpValue1);

        final int yyChoice1 = yyOption1;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pCIdentifier$Identifier(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final String v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$2.
          final String v$g$2 = cast(yyOpValue1);

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("{")) {

            yyResult = pPushScope(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pEnterStructure(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pJeannieC$StructureDeclarationList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$3 = yyResult.semanticValue();

                  yyBase   = yyResult.index;
                  yyResult = pSymbol(yyBase);
                  if (yyResult.hasValue("}")) {

                    yyResult = pExitStructure(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pPopScope(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyOption1  = yyResult.index;
                        yyOpValue1 = null;

                        yyResult = 
                          pJeannieC$AttributeSpecifierList(yyOption1);
                        yyError  = yyResult.select(yyError, yyOption1);
                        if (yyResult.hasValue()) {
                          final Node v$el$3 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$3;
                        }
                        { // Start scope for v$g$4.
                          final Node v$g$4 = cast(yyOpValue1);

                          yyValue = GNode.create("UnionTypeDefinition", v$g$1, v$g$2, v$g$3, v$g$4);
                          yyValue.setLocation(location(yyStart));

                          return new SemanticValue(yyValue, yyOption1, yyError);
                        } // End scope for v$g$4.
                      }
                    }
                  } else {
                    yyError = yyError.select("'}' expected", yyBase);
                  }
                }
              }
            }
          } else {
            yyError = yyError.select("'{' expected", yyBase);
          }
        } // End scope for v$g$2.

        // Nested alternative 2.

        yyResult = pCIdentifier$Identifier(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("UnionTypeReference", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("union type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.StructureDeclarationList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$StructureDeclarationList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Regular>.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pJeannieC$AnnotatedStructureDeclaration(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyResult = p$$Shared6(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("StructureDeclarationList", v$g$1.size() + 1).
          addAll(v$g$1).add(v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Empty>.

    if (GCC) {

      yyResult = p$$Shared6(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("StructureDeclarationList", v$g$3);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("structure declaration list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * xtc.lang.jeannie.JeannieC.AnnotatedStructureDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AnnotatedStructureDeclaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative 1.

    yyState.mark();

    yyResult = pJeannieC$StructureDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node d = yyResult.semanticValue();

      yyValue = yyState.annotate(d);

      // Commit the state modification.
      yyState.commit();

      setLocation(yyValue, yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.StructureDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$StructureDeclaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declaration>.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pKeyword(yyBase);
    if (yyResult.hasValue("__extension__")) {
      final String v$el$1 = "__extension__";

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    } else {
      yyError = yyError.select("'__extension__' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final String v$g$1 = yyOpValue1;

      yyResult = pJeannieC$SpecifierQualifierList(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pJeannieC$OptionalStructureDeclaratorList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyOption1  = yyResult.index;

            if (GCC) {

              yyRepetition1 = yyOption1;
              yyRepeated1   = false;
              while (true) {

                yyBase   = yyRepetition1;
                yyResult = pSymbol(yyBase);
                if (yyResult.hasValue(";")) {

                  yyRepetition1 = yyResult.index;
                  yyRepeated1   = true;
                  continue;
                } else {
                  yyError = yyError.select("';' expected", yyBase);
                }
                break;
              }

              if (yyRepeated1) {

                yyOption1  = yyRepetition1;
              }
            }

            yyValue = GNode.create("StructureDeclaration", v$g$1, v$g$2, v$g$3);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      }
    } // End scope for v$g$1.

    // Done.
    yyError = yyError.select("structure declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.SpecifierQualifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$SpecifierQualifierList(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fJeannieC$SpecifierQualifierList) 
      yyColumn.chunk4.fJeannieC$SpecifierQualifierList = pJeannieC$SpecifierQualifierList$1(yyStart);
    return yyColumn.chunk4.fJeannieC$SpecifierQualifierList;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.SpecifierQualifierList. */
  private Result pJeannieC$SpecifierQualifierList$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieC$SpecifierQualifierPlus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("SpecifierQualifierList", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.SpecifierQualifierPlus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$SpecifierQualifierPlus(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pJeannieC$SpecifierQualifier(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.SpecifierQualifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$SpecifierQualifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <TypeSpecifier>.

    yyResult = pJeannieC$TypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pTypeSpecContext(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <TypeQualifier>.

    yyResult = pJeannieC$TypeQualifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Attribute>.

    yyResult = pJeannieC$AttributeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * xtc.lang.jeannie.JeannieC.OptionalStructureDeclaratorList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$OptionalStructureDeclaratorList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <List>.

    yyResult = pJeannieC$StructureDeclaratorList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Null>.

    if (GCC) {
      { // Start scope for yyValue.
        yyValue = null;

        return new SemanticValue(yyValue, yyStart, yyError);
      } // End scope for yyValue.
    }

    // Done.
    yyError = yyError.select("optional structure declarator list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.StructureDeclaratorList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$StructureDeclaratorList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <List>.

    yyResult = pJeannieC$StructureDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pJeannieC$StructureDeclarator(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("StructureDeclaratorList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.StructureDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$StructureDeclarator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pJeannieC$AttributeSpecifierList(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyOpValue1 = null;

      yyResult = pJeannieC$Declarator(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(":")) {

          yyResult = pJeannieC$ConditionalExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pJeannieC$AttributeSpecifierList(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
            { // Start scope for v$g$4.
              final Node v$g$4 = yyOpValue1;

              yyValue = GNode.create("BitField", v$g$1, v$g$2, v$g$3, v$g$4);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$g$4.
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      } // End scope for v$g$2.
    } // End scope for v$g$1.

    // Alternative <Simple>.

    yyResult = pJeannieC$AttributedDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.AttributedDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AttributedDeclarator(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fJeannieC$AttributedDeclarator) 
      yyColumn.chunk4.fJeannieC$AttributedDeclarator = pJeannieC$AttributedDeclarator$1(yyStart);
    return yyColumn.chunk4.fJeannieC$AttributedDeclarator;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.AttributedDeclarator. */
  private Result pJeannieC$AttributedDeclarator$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pJeannieC$AttributeSpecifierList(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pJeannieC$Declarator(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pJeannieC$AttributeSpecifierList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyValue = GNode.create("AttributedDeclarator", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$3.
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.Declarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$Declarator(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fJeannieC$Declarator) 
      yyColumn.chunk4.fJeannieC$Declarator = pJeannieC$Declarator$1(yyStart);
    return yyColumn.chunk4.fJeannieC$Declarator;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.Declarator. */
  private Result pJeannieC$Declarator$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Pointer>.

    yyResult = pJeannieC$PointerDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Direct>.

    yyResult = pJeannieC$DirectDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.PointerDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$PointerDeclarator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieC$Pointer(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pJeannieC$DirectDeclarator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("PointerDeclarator", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.Pointer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$Pointer(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fJeannieC$Pointer) 
      yyColumn.chunk4.fJeannieC$Pointer = pJeannieC$Pointer$1(yyStart);
    return yyColumn.chunk4.fJeannieC$Pointer;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.Pointer. */
  private Result pJeannieC$Pointer$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("*")) {

      yyResult = pJeannieC$TypeQualifierList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pJeannieC$Pointer(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$2.
          final Node v$g$2 = yyOpValue1;

          yyValue = GNode.create("Pointer", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("pointer expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.TypeQualifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$TypeQualifierList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pJeannieC$TypeQualifierList$$Choice1(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("TypeQualifierList", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.TypeQualifierList$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$TypeQualifierList$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieC$TypeQualifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pJeannieC$AttributeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.DirectDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$DirectDeclarator(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyBase;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <FullBase>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pJeannieC$AttributedDeclarator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$7 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pJeannieC$DirectDeclarator$$Tail1(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Action<Node> v$8 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Action<Node>>(v$8, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for v$9.
            final Pair<Action<Node>> v$9 = yyRepValue1.reverse();

            yyValue = apply(v$9, v$g$7, yyStart);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for v$9.
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative <SimpleBase>.

    yyResult = pJeannieC$SimpleDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$10 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieC$DirectDeclarator$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$11 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$11, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$12.
        final Pair<Action<Node>> v$12 = yyRepValue1.reverse();

        yyValue = apply(v$12, v$g$10, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$12.
    }

    // Done.
    yyError = yyError.select("direct declarator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.DirectDeclarator$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$DirectDeclarator$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyOption1;
    Node         yyOpValue1;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pPushScope(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pJeannieC$ParameterTypeList(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pParameterContext(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pJeannieC$JavaThrows(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node javaThrows = yyResult.semanticValue();

                yyValue = new Action<Node>() {
                  public Node run(Node v$1) {
                    return GNode.create("FunctionDeclarator", v$1, v$g$2, javaThrows);
                  }};

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }

        // Nested alternative 2.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pJeannieC$IdentifierList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pParameterContext(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pJeannieC$JavaThrows(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node javaThrows = yyResult.semanticValue();

                yyValue = new Action<Node>() {
                  public Node run(Node v$1) {
                    return GNode.create("FunctionDeclarator", v$1, v$g$3, javaThrows);
                  }};

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$g$3.
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {

      yyResult = pJeannieC$ArrayQualifierList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pJeannieC$AssignmentExpression(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$5.
          final Node v$g$5 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("]")) {

            yyValue = new Action<Node>() {
              public Node run(Node v$1) {
                return GNode.create("ArrayDeclarator", v$1, v$g$4, v$g$5);
              }};

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("']' expected", yyBase);
          }
        } // End scope for v$g$5.

        // Nested alternative 2.

        yyResult = pJeannieC$VariableLength(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$6 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("]")) {

            yyValue = new Action<Node>() {
              public Node run(Node v$1) {
                return GNode.create("ArrayDeclarator", v$1, v$g$4, v$g$6);
              }};

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("']' expected", yyBase);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("direct declarator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.VariableLength.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$VariableLength(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fJeannieC$VariableLength) 
      yyColumn.chunk4.fJeannieC$VariableLength = pJeannieC$VariableLength$1(yyStart);
    return yyColumn.chunk4.fJeannieC$VariableLength;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.VariableLength. */
  private Result pJeannieC$VariableLength$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("*")) {

      yyValue = GNode.create("VariableLength", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("variable length expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.SimpleDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$SimpleDeclarator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declarator>.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String id = yyResult.semanticValue();

      yyState.bind(toText(id));

      yyValue = GNode.create("SimpleDeclarator", id);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.ParameterTypeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$ParameterTypeList(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fJeannieC$ParameterTypeList) 
      yyColumn.chunk4.fJeannieC$ParameterTypeList = pJeannieC$ParameterTypeList$1(yyStart);
    return yyColumn.chunk4.fJeannieC$ParameterTypeList;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.ParameterTypeList. */
  private Result pJeannieC$ParameterTypeList$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieC$ParameterList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(",")) {

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("...")) {
          final String v$el$1 = "...";

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        } else {
          yyError = yyError.select("'...' expected", yyBase);
        }
      } else {
        yyError = yyError.select("',' expected", yyBase);
      }
      { // Start scope for v$g$2.
        final String v$g$2 = yyOpValue1;

        yyValue = GNode.create("ParameterTypeList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.ParameterList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$ParameterList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieC$ParameterDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pJeannieC$ParameterDeclaration(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("ParameterList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.ParameterDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$ParameterDeclaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative 1.

    yyResult = pJeannieC$DeclarationSpecifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pJeannieC$Declarator(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pJeannieC$AttributeSpecifierList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyValue = GNode.create("ParameterDeclaration", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          // Commit the state modification.
          yyState.commit();

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$3.
      }

      // Nested alternative 2.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pJeannieC$AbstractDeclarator(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for v$g$4.
        final Node v$g$4 = yyOpValue1;

        yyOpValue1 = null;

        yyResult = pJeannieC$AttributeSpecifierList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
        { // Start scope for v$g$5.
          final Node v$g$5 = yyOpValue1;

          yyValue = GNode.create("ParameterDeclaration", v$g$1, v$g$4, v$g$5);
          yyValue.setLocation(location(yyStart));

          // Commit the state modification.
          yyState.commit();

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$5.
      } // End scope for v$g$4.
    }

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.AttributedAbstractDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AttributedAbstractDeclarator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pJeannieC$AttributeSpecifierList(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pJeannieC$AbstractDeclarator(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("AttributedAbstractDeclarator", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.AbstractDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AbstractDeclarator(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fJeannieC$AbstractDeclarator) 
      yyColumn.chunk4.fJeannieC$AbstractDeclarator = pJeannieC$AbstractDeclarator$1(yyStart);
    return yyColumn.chunk4.fJeannieC$AbstractDeclarator;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.AbstractDeclarator. */
  private Result pJeannieC$AbstractDeclarator$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pJeannieC$Pointer(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for p.
      final Node p = yyOpValue1;

      yyResult = pJeannieC$DirectAbstractDeclarator(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node d = yyResult.semanticValue();

        if ((null != p) || (null != d)) {

          yyValue = GNode.create("AbstractDeclarator", p, d);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } // End scope for p.

    // Done.
    yyError = yyError.select("abstract declarator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.DirectAbstractDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$DirectAbstractDeclarator(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyBase;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Parenthesized>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pJeannieC$AttributedAbstractDeclarator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$7 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = 
              pJeannieC$DirectAbstractDeclarator$$Tail1(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Action<Node> v$8 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Action<Node>>(v$8, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for v$9.
            final Pair<Action<Node>> v$9 = yyRepValue1.reverse();

            yyValue = apply(v$9, v$g$7, yyStart);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for v$9.
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative <Empty>.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pJeannieC$DirectAbstractDeclarator$$Tail1(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Action<Node> v$11 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Action<Node>>(v$11, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$12.
      final Pair<Action<Node>> v$12 = yyRepValue1.reverse();

      yyValue = apply(v$12, null, yyStart);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$12.
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.DirectAbstractDeclarator$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$DirectAbstractDeclarator$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyOption1;
    Node         yyOpValue1;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {
      final String v$g$2 = "[";

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pJeannieC$AssignmentExpression(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$3.
        final Node v$g$3 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("DirectAbstractDeclarator", v$1, v$g$2, v$g$3);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      } // End scope for v$g$3.

      // Nested alternative 2.

      yyResult = pJeannieC$VariableLength(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("DirectAbstractDeclarator", v$1, v$g$2, v$g$4);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {
      final String v$g$5 = "(";

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pJeannieC$ParameterTypeList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for v$g$6.
        final Node v$g$6 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("DirectAbstractDeclarator", v$1, v$g$5, v$g$6);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      } // End scope for v$g$6.
    }

    // Done.
    yyError = yyError.select("direct abstract declarator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.IdentifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$IdentifierList(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Node         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String id1 = yyResult.semanticValue();

      yyState.bind(toText(id1));

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pCIdentifier$Identifier(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final String id2 = yyResult.semanticValue();

            yyState.bind(toText(id2));

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<String>(id2, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$1.
        final Pair<String> v$g$1 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("IdentifierList", id1, v$g$1);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.ArrayQualifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$ArrayQualifierList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pJeannieC$ArrayQualifierList$$Choice1(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("ArrayQualifierList", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.ArrayQualifierList$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$ArrayQualifierList$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("static")) {

      yyValue = GNode.create("StaticSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("volatile")) {
      final String v$g$1 = "volatile";

      yyValue = GNode.create("VolatileQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__volatile")) {
      final String v$g$2 = "__volatile";

      yyValue = GNode.create("VolatileQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__volatile__")) {
      final String v$g$3 = "__volatile__";

      yyValue = GNode.create("VolatileQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("restrict")) {
      final String v$g$1 = "restrict";

      yyValue = GNode.create("RestrictQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__restrict")) {
      final String v$g$2 = "__restrict";

      yyValue = GNode.create("RestrictQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__restrict__")) {
      final String v$g$3 = "__restrict__";

      yyValue = GNode.create("RestrictQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("const")) {
      final String v$g$1 = "const";

      yyValue = GNode.create("ConstantQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__const")) {
      final String v$g$2 = "__const";

      yyValue = GNode.create("ConstantQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__const__")) {
      final String v$g$3 = "__const__";

      yyValue = GNode.create("ConstantQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 11.

    yyResult = pJeannieC$AttributeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("array qualifier list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.FloatingPointTypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$FloatingPointTypeSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("_Complex")) {
      final String v$g$1 = "_Complex";

      yyValue = GNode.create("Complex", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__complex__")) {
      final String v$g$2 = "__complex__";

      yyValue = GNode.create("Complex", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("double")) {

      yyValue = GNode.create("Double", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("float")) {

      yyValue = GNode.create("Float", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("floating point type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.IntegerTypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$IntegerTypeSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("long")) {

      yyValue = GNode.create("Long", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("int")) {

      yyValue = GNode.create("Int", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("short")) {

      yyValue = GNode.create("Short", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("char")) {

      yyValue = GNode.create("Char", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("_Bool")) {

      yyValue = GNode.create("Bool", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("unsigned")) {

      yyValue = GNode.create("Unsigned", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("signed")) {
      final String v$g$1 = "signed";

      yyValue = GNode.create("Signed", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__signed")) {
      final String v$g$2 = "__signed";

      yyValue = GNode.create("Signed", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__signed__")) {
      final String v$g$3 = "__signed__";

      yyValue = GNode.create("Signed", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("integer type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared9.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieC.TypeofKeyword 
   * and xtc.lang.blink.CommandC.TypeofKeyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared9(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.f$$Shared9) 
      yyColumn.chunk4.f$$Shared9 = p$$Shared9$1(yyStart);
    return yyColumn.chunk4.f$$Shared9;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared9. */
  private Result p$$Shared9$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("typeof")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__typeof")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__typeof__")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.Initializer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$Initializer(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Complex>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyResult = pJeannieC$InitializerList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyOption1  = yyResult.index;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyOption1  = yyResult.index;
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("}")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      }
    }

    // Alternative <Simple>.

    yyResult = pJeannieC$AssignmentExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("initializer expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.InitializerList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$InitializerList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieC$InitializerListEntry(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pJeannieC$InitializerListEntry(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("InitializerList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Alternative 2.

    if (GCC) {

      yyValue = GNode.create("InitializerList", false);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyStart, yyError);
    }

    // Done.
    yyError = yyError.select("initializer list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.InitializerListEntry.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$InitializerListEntry(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pJeannieC$Designation(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pJeannieC$Initializer(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("InitializerListEntry", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.Designation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$Designation(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Standard>.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pJeannieC$Designator(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyBase   = yyRepetition1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("=")) {

        yyValue = GNode.createFromPair("Designation", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Alternative 2.

    if (GCC) {

      final int yyChoice1 = yyStart;

      // Nested alternative 1.

      yyResult = pJeannieC$ObsoleteArrayDesignation(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pJeannieC$ObsoleteFieldDesignation(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("designation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.Designator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$Designator(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Array>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {
      final String v$g$1 = "[";

      yyResult = pJeannieC$ConditionalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = GNode.create("Designator", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative <ArrayRange>.

    if (GCC) {

      yyResult = pSymbol(yyStart);
      if (yyResult.hasValue("[")) {
        final String v$g$3 = "[";

        yyResult = pJeannieC$ConditionalExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("...")) {

            yyResult = pJeannieC$ConditionalExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$5 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue("]")) {

                yyValue = GNode.create("Designator", v$g$3, v$g$4, v$g$5);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("']' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("'...' expected", yyBase);
          }
        }
      }
    }

    // Alternative <Structure>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(".")) {
      final String v$g$6 = ".";

      yyResult = pJeannieC$PrimaryIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$7 = yyResult.semanticValue();

        yyValue = GNode.create("Designator", v$g$6, v$g$7);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("designator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.ObsoleteArrayDesignation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$ObsoleteArrayDesignation(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {
      final String v$g$1 = "[";

      yyResult = pJeannieC$ConditionalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyBase   = yyChoice1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = GNode.create("ObsoleteArrayDesignation", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }

        // Nested alternative 2.

        yyBase   = yyChoice1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("...")) {

          yyResult = pJeannieC$ConditionalExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$3 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue("]")) {

              yyValue = GNode.create("ObsoleteArrayDesignation", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("']' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'...' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("obsolete array designation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.ObsoleteFieldDesignation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$ObsoleteFieldDesignation(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyValue = GNode.create("ObsoleteFieldDesignation", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.TypeName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$TypeName(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fJeannieC$TypeName) 
      yyColumn.chunk4.fJeannieC$TypeName = pJeannieC$TypeName$1(yyStart);
    return yyColumn.chunk4.fJeannieC$TypeName;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.TypeName. */
  private Result pJeannieC$TypeName$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative 1.

    yyResult = pJeannieC$SpecifierQualifierList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pJeannieC$AbstractDeclarator(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("TypeName", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        // Commit the state modification.
        yyState.commit();

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.AttributeSpecifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AttributeSpecifierList(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fJeannieC$AttributeSpecifierList) 
      yyColumn.chunk4.fJeannieC$AttributeSpecifierList = pJeannieC$AttributeSpecifierList$1(yyStart);
    return yyColumn.chunk4.fJeannieC$AttributeSpecifierList;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.AttributeSpecifierList. */
  private Result pJeannieC$AttributeSpecifierList$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieC$AttributeSpecifierPlus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("AttributeSpecifierList", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.AttributeSpecifierPlus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AttributeSpecifierPlus(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pJeannieC$AttributeSpecifier(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.AttributeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AttributeSpecifier(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fJeannieC$AttributeSpecifier) 
      yyColumn.chunk5.fJeannieC$AttributeSpecifier = pJeannieC$AttributeSpecifier$1(yyStart);
    return yyColumn.chunk5.fJeannieC$AttributeSpecifier;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.AttributeSpecifier. */
  private Result pJeannieC$AttributeSpecifier$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared10(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("(")) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pJeannieC$AttributeList(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$1.
            final Node v$g$1 = yyOpValue1;

            yyBase   = yyOption1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(")")) {

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(")")) {

                yyValue = GNode.create("AttributeSpecifier", v$g$1);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          } // End scope for v$g$1.
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared10.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieC.AttributeKeyword 
   * and xtc.lang.blink.CommandC.AttributeKeyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared10(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.f$$Shared10) 
      yyColumn.chunk5.f$$Shared10 = p$$Shared10$1(yyStart);
    return yyColumn.chunk5.f$$Shared10;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared10. */
  private Result p$$Shared10$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__attribute")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__attribute__")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.AttributeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AttributeList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieC$AttributeListEntry(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pJeannieC$AttributeListEntry(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("AttributeList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.AttributeListEntry.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AttributeListEntry(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    int        yyOption2;
    Node       yyOpValue2;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCIdentifier$Word(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyOption2  = yyResult.index;
        yyOpValue2 = null;

        yyResult = pJeannieC$ExpressionList(yyOption2);
        yyError  = yyResult.select(yyError, yyOption2);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption2  = yyResult.index;
          yyOpValue2 = v$el$2;
        }
        { // Start scope for v$el$1.
          final Node v$el$1 = yyOpValue2;

          yyBase   = yyOption2;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$el$1.
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("AttributeListEntry", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$Statement(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fJeannieC$Statement) 
      yyColumn.chunk5.fJeannieC$Statement = pJeannieC$Statement$1(yyStart);
    return yyColumn.chunk5.fJeannieC$Statement;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.Statement. */
  private Result pJeannieC$Statement$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieC$CommaExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(";")) {

        yyValue = GNode.create("ExpressionStatement", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative <JavaInCStatement>.

    yyResult = pJeannieC$JavaInCStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Cancel>.

    yyResult = pJeannieC$CancelStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Commit>.

    yyResult = pJeannieC$CommitStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <With>.

    yyResult = pJeannieC$WithStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Compound>.

    yyResult = pJeannieC$CompoundStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("if")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pJeannieC$CommaExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pJeannieC$Statement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              final int yyChoice1 = yyResult.index;

              // Nested alternative 1.

              yyBase   = yyChoice1;
              yyResult = pKeyword(yyBase);
              if (yyResult.hasValue("else")) {

                yyResult = pJeannieC$Statement(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$3 = yyResult.semanticValue();

                  yyValue = GNode.create("IfElseStatement", v$g$1, v$g$2, v$g$3);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                }
              } else {
                yyError = yyError.select("'else' expected", yyBase);
              }

              // Nested alternative 2.

              yyValue = GNode.create("IfStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyChoice1, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 8.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("while")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pJeannieC$CommaExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pJeannieC$Statement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyValue = GNode.create("WhileStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 9.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("do")) {

      yyResult = pJeannieC$Statement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pKeyword(yyBase);
        if (yyResult.hasValue("while")) {

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("(")) {

            yyResult = pJeannieC$CommaExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(")")) {

                yyBase   = yyResult.index;
                yyResult = pSymbol(yyBase);
                if (yyResult.hasValue(";")) {

                  yyValue = GNode.create("DoStatement", v$g$1, v$g$2);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                } else {
                  yyError = yyError.select("';' expected", yyBase);
                }
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("'(' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'while' expected", yyBase);
        }
      }
    }

    // Alternative 10.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("for")) {

      yyResult = pPushScope(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("(")) {

          yyResult = pJeannieC$InitialClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pJeannieC$CommaExpression(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
            { // Start scope for v$g$2.
              final Node v$g$2 = yyOpValue1;

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(";")) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pJeannieC$CommaExpression(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  final Node v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
                { // Start scope for v$g$3.
                  final Node v$g$3 = yyOpValue1;

                  yyBase   = yyOption1;
                  yyResult = pSymbol(yyBase);
                  if (yyResult.hasValue(")")) {

                    yyResult = pJeannieC$Statement(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      final Node v$g$4 = yyResult.semanticValue();

                      yyResult = pPopScope(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyValue = GNode.create("ForStatement", v$g$1, v$g$2, v$g$3, v$g$4);
                        yyValue.setLocation(location(yyStart));

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  } else {
                    yyError = yyError.select("')' expected", yyBase);
                  }
                } // End scope for v$g$3.
              } else {
                yyError = yyError.select("';' expected", yyBase);
              }
            } // End scope for v$g$2.
          }
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      }
    }

    // Alternative 11.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("switch")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pJeannieC$CommaExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pJeannieC$Statement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyValue = GNode.create("SwitchStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative <Complete>.

    yyResult = pJeannieC$Label(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pJeannieC$Statement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("LabeledStatement", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Incomplete>.

    if (GCC) {

      yyResult = pJeannieC$Label(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("LabeledStatement", v$g$3, null);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 14.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("break")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(";")) {

        yyValue = GNode.create("BreakStatement", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 15.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("continue")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(";")) {

        yyValue = GNode.create("ContinueStatement", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 16.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("return")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pJeannieC$CommaExpression(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("ReturnStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Alternative <Direct>.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("goto")) {

      yyResult = pJeannieC$PrimaryIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("GotoStatement", null, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Alternative <Computed>.

    if (GCC) {

      yyResult = pKeyword(yyStart);
      if (yyResult.hasValue("goto")) {

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("*")) {
          final String v$g$3 = "*";

          yyResult = pJeannieC$CommaExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$4 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(";")) {

              yyValue = GNode.create("GotoStatement", v$g$3, v$g$4);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("';' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'*' expected", yyBase);
        }
      }
    }

    // Alternative 19.

    yyResult = p$$Shared18(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pJeannieC$TypeQualifier(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("(")) {

          yyResult = pJeannieC$AssemblyArgument(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(")")) {

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(";")) {
                final String v$g$3 = ";";

                yyValue = GNode.create("AssemblyStatement", v$g$1, v$g$2, v$g$3);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("';' expected", yyBase);
              }
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Alternative 20.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(";")) {

      yyValue = GNode.create("EmptyStatement", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.Label.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$Label(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Label>.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pJeannieC$AttributeSpecifierList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$2.
          final Node v$g$2 = yyOpValue1;

          yyValue = GNode.create("NamedLabel", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$2.
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Alternative <Range>.

    if (GCC) {

      yyResult = pKeyword(yyStart);
      if (yyResult.hasValue("case")) {

        yyResult = pJeannieC$ConditionalExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("...")) {

            yyResult = pJeannieC$ConditionalExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(":")) {

                yyValue = GNode.create("CaseLabel", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("':' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("'...' expected", yyBase);
          }
        }
      }
    }

    // Alternative <Simple>.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("case")) {

      yyResult = pJeannieC$ConditionalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(":")) {

          yyValue = GNode.create("CaseLabel", v$g$3);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("default")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyValue = GNode.create("DefaultLabel", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("label expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.CompoundStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$CompoundStatement(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fJeannieC$CompoundStatement) 
      yyColumn.chunk5.fJeannieC$CompoundStatement = pJeannieC$CompoundStatement$1(yyStart);
    return yyColumn.chunk5.fJeannieC$CompoundStatement;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.CompoundStatement. */
  private Result pJeannieC$CompoundStatement$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <CBlock>.

    yyResult = pJeannieC$CInCBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <JavaBlock>.

    yyResult = pJeannieC$JavaInCBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.LocalLabelDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$LocalLabelDeclaration(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Node         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__label__")) {

      yyResult = pCIdentifier$Identifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pCIdentifier$Identifier(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final String v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<String> v$g$2 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyValue = GNode.createFromPair("LocalLabelDeclaration", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("local label declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.DeclarationOrStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$DeclarationOrStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative <Declaration>.

    yyState.mark();

    yyResult = pJeannieC$Declaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node d = yyResult.semanticValue();

      yyValue = yyState.annotate(d);

      // Commit the state modification.
      yyState.commit();

      setLocation(yyValue, yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Statement>.

    yyResult = pJeannieC$Statement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node s = yyResult.semanticValue();

      yyValue = yyState.annotate(s);

      // Commit the state modification.
      yyState.commit();

      setLocation(yyValue, yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.InitialClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$InitialClause(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative <Declaration>.

    yyResult = pJeannieC$Declaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      // Commit the state modification.
      yyState.commit();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Expression>.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pJeannieC$CommaExpression(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$3 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$3;
    }
    { // Start scope for yyValue.
      yyValue = yyOpValue1;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(";")) {

        // Commit the state modification.
        yyState.commit();

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    } // End scope for yyValue.

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.CommaExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$CommaExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fJeannieC$CommaExpression) 
      yyColumn.chunk5.fJeannieC$CommaExpression = pJeannieC$CommaExpression$1(yyStart);
    return yyColumn.chunk5.fJeannieC$CommaExpression;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.CommaExpression. */
  private Result pJeannieC$CommaExpression$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieC$AssignmentExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieC$CommaExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.CommaExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$CommaExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Comma>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pJeannieC$AssignmentExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("CommaExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("comma expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.AssignmentExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AssignmentExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fJeannieC$AssignmentExpression) 
      yyColumn.chunk5.fJeannieC$AssignmentExpression = pJeannieC$AssignmentExpression$1(yyStart);
    return yyColumn.chunk5.fJeannieC$AssignmentExpression;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.AssignmentExpression. */
  private Result pJeannieC$AssignmentExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Assignment>.

    yyResult = pJeannieC$UnaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = p$$Shared11(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$2 = yyResult.semanticValue();

        yyResult = pJeannieC$AssignmentExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("AssignmentExpression", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pJeannieC$ConditionalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared11.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieC.AssignmentOperator 
   * and xtc.lang.blink.CommandC.AssignmentOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared11(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.f$$Shared11) 
      yyColumn.chunk5.f$$Shared11 = p$$Shared11$1(yyStart);
    return yyColumn.chunk5.f$$Shared11;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared11. */
  private Result p$$Shared11$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Equal>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("=")) {
      yyValue = "=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <PlusEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("+=")) {
      yyValue = "+=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <MinusEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("-=")) {
      yyValue = "-=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <TimesEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("*=")) {
      yyValue = "*=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <OverEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("/=")) {
      yyValue = "/=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <ModuloEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("%=")) {
      yyValue = "%=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <LeftEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<<=")) {
      yyValue = "<<=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <RightEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">>=")) {
      yyValue = ">>=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <AndEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&=")) {
      yyValue = "&=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <XorEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("^=")) {
      yyValue = "^=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <OrEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("|=")) {
      yyValue = "|=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.ConditionalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$ConditionalExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fJeannieC$ConditionalExpression) 
      yyColumn.chunk5.fJeannieC$ConditionalExpression = pJeannieC$ConditionalExpression$1(yyStart);
    return yyColumn.chunk5.fJeannieC$ConditionalExpression;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.ConditionalExpression. */
  private Result pJeannieC$ConditionalExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Conditional>.

    yyResult = pJeannieC$LogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("?")) {

        yyResult = pJeannieC$CommaExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(":")) {

            yyResult = pJeannieC$ConditionalExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("ConditionalExpression", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'?' expected", yyBase);
      }
    }

    // Alternative <IncompleteConditional>.

    if (GCC) {

      yyResult = pJeannieC$LogicalOrExpression(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("?")) {

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(":")) {

            yyResult = pJeannieC$ConditionalExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$6 = yyResult.semanticValue();

              yyValue = GNode.create("ConditionalExpression", v$g$4, null, v$g$6);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'?' expected", yyBase);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pJeannieC$LogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("conditional expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.LogicalOrExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$LogicalOrExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fJeannieC$LogicalOrExpression) 
      yyColumn.chunk5.fJeannieC$LogicalOrExpression = pJeannieC$LogicalOrExpression$1(yyStart);
    return yyColumn.chunk5.fJeannieC$LogicalOrExpression;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.LogicalOrExpression. */
  private Result pJeannieC$LogicalOrExpression$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieC$LogicalAndExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieC$LogicalOrExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.LogicalOrExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$LogicalOrExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Or>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("||")) {

      yyResult = pJeannieC$LogicalAndExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalOrExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical or expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.LogicalAndExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$LogicalAndExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieC$BitwiseOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieC$LogicalAndExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.LogicalAndExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$LogicalAndExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <And>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&&")) {

      yyResult = pJeannieC$BitwiseOrExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalAndExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical and expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.BitwiseOrExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$BitwiseOrExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieC$BitwiseXorExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieC$BitwiseOrExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.BitwiseOrExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$BitwiseOrExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Or>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("|")) {

      yyResult = pJeannieC$BitwiseXorExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseOrExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise or expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.BitwiseXorExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$BitwiseXorExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieC$BitwiseAndExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieC$BitwiseXorExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.BitwiseXorExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$BitwiseXorExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Xor>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("^")) {

      yyResult = pJeannieC$BitwiseAndExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseXorExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise xor expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.BitwiseAndExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$BitwiseAndExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieC$EqualityExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieC$BitwiseAndExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.BitwiseAndExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$BitwiseAndExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <And>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&")) {

      yyResult = pJeannieC$EqualityExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseAndExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise and expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.EqualityExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$EqualityExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieC$RelationalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieC$EqualityExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.EqualityExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$EqualityExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared12(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pJeannieC$RelationalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("EqualityExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared12.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieC.EqualityOperator, 
   * xtc.lang.blink.CommandC.EqualityOperator, 
   * xtc.lang.jeannie.JeannieJava.EqualityOperator, 
   * and xtc.lang.blink.CommandJava.EqualityOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared12(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.f$$Shared12) 
      yyColumn.chunk5.f$$Shared12 = p$$Shared12$1(yyStart);
    return yyColumn.chunk5.f$$Shared12;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared12. */
  private Result p$$Shared12$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Equal>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("==")) {
      yyValue = "==";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <NotEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("!=")) {
      yyValue = "!=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.RelationalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$RelationalExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieC$ShiftExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieC$RelationalExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.RelationalExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$RelationalExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared13(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pJeannieC$ShiftExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("RelationalExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared13.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieC.RelationalOperator 
   * and xtc.lang.blink.CommandC.RelationalOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared13(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.f$$Shared13) 
      yyColumn.chunk6.f$$Shared13 = p$$Shared13$1(yyStart);
    return yyColumn.chunk6.f$$Shared13;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared13. */
  private Result p$$Shared13$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <LessEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<=")) {
      yyValue = "<=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Less>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<")) {
      yyValue = "<";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <GreaterEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">=")) {
      yyValue = ">=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Greater>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">")) {
      yyValue = ">";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.ShiftExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$ShiftExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieC$AdditiveExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieC$ShiftExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.ShiftExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$ShiftExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared14(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pJeannieC$AdditiveExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("ShiftExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared14.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieC.ShiftOperator 
   * and xtc.lang.blink.CommandC.ShiftOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared14(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.f$$Shared14) 
      yyColumn.chunk6.f$$Shared14 = p$$Shared14$1(yyStart);
    return yyColumn.chunk6.f$$Shared14;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared14. */
  private Result p$$Shared14$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Left>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<<")) {
      yyValue = "<<";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Right>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">>")) {
      yyValue = ">>";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.AdditiveExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AdditiveExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieC$MultiplicativeExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieC$AdditiveExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.AdditiveExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AdditiveExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared15(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pJeannieC$MultiplicativeExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("AdditiveExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared15.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieC.AdditiveOperator, 
   * xtc.lang.blink.CommandC.AdditiveOperator, 
   * xtc.lang.jeannie.JeannieJava.AdditiveOperator, 
   * and xtc.lang.blink.CommandJava.AdditiveOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared15(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.f$$Shared15) 
      yyColumn.chunk6.f$$Shared15 = p$$Shared15$1(yyStart);
    return yyColumn.chunk6.f$$Shared15;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared15. */
  private Result p$$Shared15$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Plus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("+")) {
      yyValue = "+";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Minus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("-")) {
      yyValue = "-";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.MultiplicativeExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$MultiplicativeExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieC$CastExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieC$MultiplicativeExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.MultiplicativeExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$MultiplicativeExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared16(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pJeannieC$CastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("MultiplicativeExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared16.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieC.MultiplicativeOperator, 
   * xtc.lang.blink.CommandC.MultiplicativeOperator, 
   * xtc.lang.jeannie.JeannieJava.MultiplicativeOperator, 
   * and xtc.lang.blink.CommandJava.MultiplicativeOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared16(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.f$$Shared16) 
      yyColumn.chunk6.f$$Shared16 = p$$Shared16$1(yyStart);
    return yyColumn.chunk6.f$$Shared16;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared16. */
  private Result p$$Shared16$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Times>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("*")) {
      yyValue = "*";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Over>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("/")) {
      yyValue = "/";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Modulo>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("%")) {
      yyValue = "%";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.CastExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$CastExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fJeannieC$CastExpression) 
      yyColumn.chunk6.fJeannieC$CastExpression = pJeannieC$CastExpression$1(yyStart);
    return yyColumn.chunk6.fJeannieC$CastExpression;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.CastExpression. */
  private Result pJeannieC$CastExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Cast>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pJeannieC$TypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyResult = pJeannieC$CastExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("CastExpression", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pJeannieC$UnaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("cast expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.UnaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$UnaryExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fJeannieC$UnaryExpression) 
      yyColumn.chunk6.fJeannieC$UnaryExpression = pJeannieC$UnaryExpression$1(yyStart);
    return yyColumn.chunk6.fJeannieC$UnaryExpression;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.UnaryExpression. */
  private Result pJeannieC$UnaryExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("sizeof")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pJeannieC$TypeName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyPredMatched = false;

            yyPredResult = pSymbol(yyResult.index);
            if (yyPredResult.hasValue("{")) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = GNode.create("SizeofExpression", v$g$1);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("unary expression expected", yyStart);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }

      // Nested alternative 2.

      yyResult = pJeannieC$UnaryExpression(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("SizeofExpression", v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = p$$Shared17(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pJeannieC$TypeName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyPredMatched = false;

            yyPredResult = pSymbol(yyResult.index);
            if (yyPredResult.hasValue("{")) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = GNode.create("AlignofExpression", v$g$1);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("unary expression expected", yyStart);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }

      // Nested alternative 2.

      yyResult = pJeannieC$UnaryExpression(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("AlignofExpression", v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__builtin_offsetof")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pJeannieC$TypeName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pJeannieC$PostfixExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(")")) {

                yyValue = GNode.create("OffsetofExpression", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__builtin_types_compatible_p")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pJeannieC$TypeName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pJeannieC$TypeName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(")")) {

                yyValue = GNode.create("TypeCompatibilityExpression", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 5.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("-")) {

      yyResult = pJeannieC$CastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryMinusExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 6.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("+")) {

      yyResult = pJeannieC$CastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryPlusExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <JavaInCExpression>.

    yyResult = pJeannieC$JavaInCExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("!")) {

      yyResult = pJeannieC$CastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("LogicalNegationExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 9.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("~")) {

      yyResult = pJeannieC$CastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("BitwiseNegationExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 10.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&")) {

      yyResult = pJeannieC$CastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("AddressExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <LabelAddress>.

    if (GCC) {

      yyResult = pSymbol(yyStart);
      if (yyResult.hasValue("&&")) {

        yyResult = pCIdentifier$Identifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$1 = yyResult.semanticValue();

          yyValue = GNode.create("LabelAddressExpression", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 12.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("*")) {

      yyResult = pJeannieC$CastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("IndirectionExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 13.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("++")) {

      yyResult = pJeannieC$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("PreincrementExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 14.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("--")) {

      yyResult = pJeannieC$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("PredecrementExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Extension>.

    if (GCC) {

      yyResult = pKeyword(yyStart);
      if (yyResult.hasValue("__extension__")) {

        yyResult = pJeannieC$CastExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyValue = GNode.create("ExtensionExpression", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pJeannieC$PostfixExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("unary expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared17.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieC.AlignofKeyword 
   * and xtc.lang.blink.CommandC.AlignofKeyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared17(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.f$$Shared17) 
      yyColumn.chunk6.f$$Shared17 = p$$Shared17$1(yyStart);
    return yyColumn.chunk6.f$$Shared17;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared17. */
  private Result p$$Shared17$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__alignof__")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__alignof")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.PostfixExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$PostfixExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Compound>.

    yyResult = pJeannieC$CompoundLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$6 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieC$PostfixExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$7 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$7, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$8.
        final Pair<Action<Node>> v$8 = yyRepValue1.reverse();

        yyValue = apply(v$8, v$g$6, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$8.
    }

    // Alternative <Primary>.

    yyResult = pJeannieC$PrimaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$9 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieC$PostfixExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$10 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$10, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$11.
        final Pair<Action<Node>> v$11 = yyRepValue1.reverse();

        yyValue = apply(v$11, v$g$9, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$11.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.PostfixExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$PostfixExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyOption1;
    Node         yyOpValue1;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {

      yyResult = pJeannieC$CommaExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("SubscriptExpression", v$1, v$g$2);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(".")) {

      yyResult = pCIdentifier$Identifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("DirectComponentSelection", v$1, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("->")) {

      yyResult = pCIdentifier$Identifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$4 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("IndirectComponentSelection", v$1, v$g$4);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pJeannieC$ExpressionList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$5.
        final Node v$g$5 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("FunctionCall", v$1, v$g$5);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      } // End scope for v$g$5.
    }

    // Alternative 5.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("++")) {

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          return GNode.create("PostincrementExpression", v$1);
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("--")) {

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          return GNode.create("PostdecrementExpression", v$1);
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("postfix expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.ExpressionList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$ExpressionList(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fJeannieC$ExpressionList) 
      yyColumn.chunk6.fJeannieC$ExpressionList = pJeannieC$ExpressionList$1(yyStart);
    return yyColumn.chunk6.fJeannieC$ExpressionList;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.ExpressionList. */
  private Result pJeannieC$ExpressionList$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Expressions>.

    yyResult = pJeannieC$AssignmentExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pJeannieC$ExpressionList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("ExpressionList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.ExpressionList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$ExpressionList$$Star1(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fJeannieC$ExpressionList$$Star1) 
      yyColumn.chunk6.fJeannieC$ExpressionList$$Star1 = pJeannieC$ExpressionList$$Star1$1(yyStart);
    return yyColumn.chunk6.fJeannieC$ExpressionList$$Star1;
  }

  /** Actually parse JeannieC.ExpressionList$$Star1. */
  private Result pJeannieC$ExpressionList$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pJeannieC$AssignmentExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyResult = pJeannieC$ExpressionList$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.CompoundLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$CompoundLiteral(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pJeannieC$TypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("{")) {

            yyResult = pJeannieC$InitializerList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(",")) {

                yyOption1  = yyResult.index;
              } else {
                yyError = yyError.select("',' expected", yyBase);
              }

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue("}")) {

                yyValue = GNode.create("CompoundLiteral", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("'}' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("'{' expected", yyBase);
          }
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("compound literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.PrimaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$PrimaryExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Constant>.

    yyResult = pConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("PrimaryIdentifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    if (GCC) {

      yyResult = pSymbol(yyStart);
      if (yyResult.hasValue("(")) {

        yyResult = pJeannieC$CompoundStatement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("StatementAsExpression", v$g$1);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__builtin_va_arg")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pJeannieC$AssignmentExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pJeannieC$TypeName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(")")) {

                yyValue = GNode.create("VariableArgumentAccess", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative <ParenthesizedExpression>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pJeannieC$CommaExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("primary expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.PrimaryIdentifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$PrimaryIdentifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("PrimaryIdentifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.SimpleAssemblyExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$SimpleAssemblyExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared18(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pCConstant$StringConstant(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("SimpleAssemblyExpression", v$g$1);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.AssemblyArgument.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AssemblyArgument(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCConstant$StringConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pJeannieC$AssemblyOperands(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$2.
          final Node v$g$2 = yyOpValue1;

          final int yyChoice2 = yyOption1;

          // Nested alternative 1.

          yyBase   = yyChoice2;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(":")) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pJeannieC$AssemblyOperands(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$3.
              final Node v$g$3 = yyOpValue1;

              final int yyChoice3 = yyOption1;

              // Nested alternative 1.

              yyBase   = yyChoice3;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(":")) {

                yyResult = pJeannieC$AssemblyClobbers(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$4 = yyResult.semanticValue();

                  yyValue = GNode.create("AssemblyArgument", v$g$1, v$g$2, v$g$3, v$g$4);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                }
              } else {
                yyError = yyError.select("':' expected", yyBase);
              }

              // Nested alternative 2.

              yyValue = GNode.create("AssemblyArgument", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyChoice3, yyError);
            } // End scope for v$g$3.
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }

          // Nested alternative 2.

          yyValue = GNode.create("AssemblyArgument", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice2, yyError);
        } // End scope for v$g$2.
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }

      // Nested alternative 2.

      yyValue = GNode.create("AssemblyArgument", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.AssemblyOperands.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AssemblyOperands(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk6) yyColumn.chunk6 = new Chunk6();
    if (null == yyColumn.chunk6.fJeannieC$AssemblyOperands) 
      yyColumn.chunk6.fJeannieC$AssemblyOperands = pJeannieC$AssemblyOperands$1(yyStart);
    return yyColumn.chunk6.fJeannieC$AssemblyOperands;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.AssemblyOperands. */
  private Result pJeannieC$AssemblyOperands$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieC$AssemblyOperand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pJeannieC$AssemblyOperands$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("AssemblyOperands", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.AssemblyOperands$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AssemblyOperands$$Star1(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fJeannieC$AssemblyOperands$$Star1) 
      yyColumn.chunk7.fJeannieC$AssemblyOperands$$Star1 = pJeannieC$AssemblyOperands$$Star1$1(yyStart);
    return yyColumn.chunk7.fJeannieC$AssemblyOperands$$Star1;
  }

  /** Actually parse JeannieC.AssemblyOperands$$Star1. */
  private Result pJeannieC$AssemblyOperands$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pJeannieC$AssemblyOperand(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyResult = pJeannieC$AssemblyOperands$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.AssemblyOperand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AssemblyOperand(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fJeannieC$AssemblyOperand) 
      yyColumn.chunk7.fJeannieC$AssemblyOperand = pJeannieC$AssemblyOperand$1(yyStart);
    return yyColumn.chunk7.fJeannieC$AssemblyOperand;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.AssemblyOperand. */
  private Result pJeannieC$AssemblyOperand$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pSymbol(yyBase);
    if (yyResult.hasValue("[")) {

      yyResult = pCIdentifier$Word(yyResult.index);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final String v$el$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    } else {
      yyError = yyError.select("'[' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final String v$g$1 = yyOpValue1;

      yyResult = pCConstant$StringConstant(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("(")) {

          yyResult = pJeannieC$CommaExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$3 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(")")) {

              yyValue = GNode.create("AssemblyOperand", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.AssemblyClobbers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$AssemblyClobbers(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCConstant$StringConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pCConstant$StringConstant(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("AssemblyClobbers", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared18.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieC.AsmKeyword 
   * and xtc.lang.blink.CommandC.AsmKeyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared18(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.f$$Shared18) 
      yyColumn.chunk7.f$$Shared18 = p$$Shared18$1(yyStart);
    return yyColumn.chunk7.f$$Shared18;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared18. */
  private Result p$$Shared18$1(final int yyStart) throws IOException {
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("asm")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__asm")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__asm__")) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.WithStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$WithStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("_with")) {

      yyResult = pPushScope(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("(")) {

          yyResult = pJeannieC$WithInitializer(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$1 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(")")) {

              yyResult = pJeannieC$CInCBlock(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$2 = yyResult.semanticValue();

                yyResult = pPopScope(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = GNode.create("WithStatement", v$g$1, v$g$2);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("with statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.WithInitializer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$WithInitializer(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declaration>.

    yyResult = pJeannieC$DeclarationNoSemicolon(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Assignment>.

    yyResult = pJeannieC$AssignmentExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.DeclarationNoSemicolon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$DeclarationNoSemicolon(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieC$DeclarationSpecifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$2 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pJeannieC$InitializedDeclaratorList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for l.
        final Node l = yyOpValue1;

        if (yyState.isValid(l)) {

          yyValue = GNode.create("Declaration", null, v$g$2, l);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      } // End scope for l.
    }

    // Done.
    yyError = yyError.select("declaration no semicolon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.CancelStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$CancelStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("_cancel")) {

      yyResult = pJeannieC$PrimaryIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("CancelStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("cancel statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.CommitStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$CommitStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("_commit")) {

      yyResult = pJeannieC$PrimaryIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("CommitStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("commit statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared25.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieC.JavaInC and xtc.lang.blink.CommandC.JavaInC.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared25(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.f$$Shared25) 
      yyColumn.chunk7.f$$Shared25 = p$$Shared25$1(yyStart);
    return yyColumn.chunk7.f$$Shared25;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared25. */
  private Result p$$Shared25$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("`")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(".")) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('J' == yyC) {
          yyIndex = yyResult.index + 1;

          yyC = character(yyIndex);
          if ('a' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if ('v' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('a' == yyC) {
                yyIndex = yyIndex + 1;

                yyResult = pSpacing(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = null;

                  return yyResult.createValue(yyValue, yyError);
                }
              } else {
                yyError = yyError.select("'Java' expected", yyBase);
              }
            } else {
              yyError = yyError.select("'Java' expected", yyBase);
            }
          } else {
            yyError = yyError.select("'Java' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'Java' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'.' expected", yyBase);
      }

      // Nested alternative 2.

      yyValue = null;

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.CInCBlock.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$CInCBlock(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fJeannieC$CInCBlock) 
      yyColumn.chunk7.fJeannieC$CInCBlock = pJeannieC$CInCBlock$1(yyStart);
    return yyColumn.chunk7.fJeannieC$CInCBlock;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.CInCBlock. */
  private Result pJeannieC$CInCBlock$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyResult = pPushScope(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pJeannieC$CInCBlock$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$g$1 = yyResult.semanticValue();

          yyResult = pJeannieC$CInCBlock$$Star2(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Pair<Node> v$g$2 = yyResult.semanticValue();

            yyResult = p$$Shared6(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyBase = yyResult.index;
              yyC    = character(yyBase);
              if ('}' == yyC) {
                yyIndex = yyResult.index + 1;

                yyResult = pSpacing(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pPopScope(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = GNode.create("CInCBlock", v$g$1.size() + v$g$2.size() + 1).
                      addAll(v$g$1).addAll(v$g$2).add(v$g$3);
                    yyValue.setLocation(location(yyStart));

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } else {
                yyError = yyError.select("'}' expected", yyBase);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("c in c block expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.CInCBlock$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$CInCBlock$$Star1(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fJeannieC$CInCBlock$$Star1) 
      yyColumn.chunk7.fJeannieC$CInCBlock$$Star1 = pJeannieC$CInCBlock$$Star1$1(yyStart);
    return yyColumn.chunk7.fJeannieC$CInCBlock$$Star1;
  }

  /** Actually parse JeannieC.CInCBlock$$Star1. */
  private Result pJeannieC$CInCBlock$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieC$LocalLabelDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyResult = pJeannieC$CInCBlock$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieC.CInCBlock$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$CInCBlock$$Star2(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fJeannieC$CInCBlock$$Star2) 
      yyColumn.chunk7.fJeannieC$CInCBlock$$Star2 = pJeannieC$CInCBlock$$Star2$1(yyStart);
    return yyColumn.chunk7.fJeannieC$CInCBlock$$Star2;
  }

  /** Actually parse JeannieC.CInCBlock$$Star2. */
  private Result pJeannieC$CInCBlock$$Star2$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieC$DeclarationOrStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$el$3 = yyResult.semanticValue();

      yyResult = pJeannieC$CInCBlock$$Star2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$4 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$3, v$4);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.JavaInCBlock.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$JavaInCBlock(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared25(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pJeannieJava$JavaInJavaBlock(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("JavaInCBlock", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.JavaInCExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$JavaInCExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared25(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pJeannieJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("JavaInCExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.JavaInCStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$JavaInCStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared25(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pJeannieJava$TryCatchFinallyStatement(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("JavaInCStatement", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pJeannieJava$SynchronizedStatement(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("JavaInCStatement", v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pJeannieJava$ThrowStatement(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("JavaInCStatement", v$g$3);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.JavaThrows.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$JavaThrows(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fJeannieC$JavaThrows) 
      yyColumn.chunk7.fJeannieC$JavaThrows = pJeannieC$JavaThrows$1(yyStart);
    return yyColumn.chunk7.fJeannieC$JavaThrows;
  }

  /** Actually parse xtc.lang.jeannie.JeannieC.JavaThrows. */
  private Result pJeannieC$JavaThrows$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = p$$Shared25(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {

      yyResult = pJeannieJava$ThrowsClause(yyResult.index);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyValue = GNode.create("JavaThrows", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyOption1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieC.JavaType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieC$JavaType(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared25(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pJavaType$TypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("JavaType", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.Declaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$Declaration(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pKeyword(yyBase);
    if (yyResult.hasValue("__extension__")) {
      final String v$el$1 = "__extension__";

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    } else {
      yyError = yyError.select("'__extension__' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final String v$g$1 = cast(yyOpValue1);

      yyResult = pCommandC$DeclarationSpecifiers(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pCommandC$InitializedDeclaratorList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for l.
          final Node l = cast(yyOpValue1);

          if (yyState.isValid(l)) {

            yyBase   = yyOption1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(";")) {

              yyValue = GNode.create("Declaration", v$g$1, v$g$2, l);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("';' expected", yyBase);
            }
          }
        } // End scope for l.
      }
    } // End scope for v$g$1.

    // Done.
    yyError = yyError.select("declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.DeclarationSpecifiers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$DeclarationSpecifiers(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fCommandC$DeclarationSpecifiers) 
      yyColumn.chunk7.fCommandC$DeclarationSpecifiers = pCommandC$DeclarationSpecifiers$1(yyStart);
    return yyColumn.chunk7.fCommandC$DeclarationSpecifiers;
  }

  /** Actually parse xtc.lang.blink.CommandC.DeclarationSpecifiers. */
  private Result pCommandC$DeclarationSpecifiers$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandC$DeclarationSpecifierPlus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("DeclarationSpecifiers", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.DeclarationSpecifierPlus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$DeclarationSpecifierPlus(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pCommandC$DeclarationSpecifier(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.DeclarationSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$DeclarationSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <StorageClass>.

    yyResult = pCommandC$StorageClassSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <TypeSpecifier>.

    yyResult = pCommandC$TypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pTypeSpecContext(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <TypeQualifier>.

    yyResult = pCommandC$TypeQualifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("inline")) {
      final String v$g$1 = "inline";

      yyValue = GNode.create("FunctionSpecifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__inline")) {
      final String v$g$2 = "__inline";

      yyValue = GNode.create("FunctionSpecifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__inline__")) {
      final String v$g$3 = "__inline__";

      yyValue = GNode.create("FunctionSpecifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Attribute>.

    yyResult = pCommandC$AttributeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("declaration specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.InitializedDeclaratorList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$InitializedDeclaratorList(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk7) yyColumn.chunk7 = new Chunk7();
    if (null == yyColumn.chunk7.fCommandC$InitializedDeclaratorList) 
      yyColumn.chunk7.fCommandC$InitializedDeclaratorList = pCommandC$InitializedDeclaratorList$1(yyStart);
    return yyColumn.chunk7.fCommandC$InitializedDeclaratorList;
  }

  /** Actually parse xtc.lang.blink.CommandC.InitializedDeclaratorList. */
  private Result pCommandC$InitializedDeclaratorList$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <List>.

    yyResult = pCommandC$InitializedDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pCommandC$InitializedDeclaratorList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("InitializedDeclaratorList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.InitializedDeclaratorList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$InitializedDeclaratorList$$Star1(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fCommandC$InitializedDeclaratorList$$Star1) 
      yyColumn.chunk8.fCommandC$InitializedDeclaratorList$$Star1 = pCommandC$InitializedDeclaratorList$$Star1$1(yyStart);
    return yyColumn.chunk8.fCommandC$InitializedDeclaratorList$$Star1;
  }

  /** Actually parse CommandC.InitializedDeclaratorList$$Star1. */
  private Result pCommandC$InitializedDeclaratorList$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pCommandC$InitializedDeclarator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyResult = pCommandC$InitializedDeclaratorList$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.InitializedDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$InitializedDeclarator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pCommandC$AttributeSpecifierList(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pCommandC$Declarator(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pCommandC$SimpleAssemblyExpression(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyOpValue1 = null;

          yyResult = pCommandC$AttributeSpecifierList(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
          { // Start scope for v$g$4.
            final Node v$g$4 = yyOpValue1;

            yyOpValue1 = null;

            yyBase   = yyOption1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue("=")) {

              yyResult = pCommandC$Initializer(yyResult.index);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                final Node v$el$4 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$4;
              }
            } else {
              yyError = yyError.select("'=' expected", yyBase);
            }
            { // Start scope for v$g$5.
              final Node v$g$5 = yyOpValue1;

              yyValue = GNode.create("InitializedDeclarator", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$g$5.
          } // End scope for v$g$4.
        } // End scope for v$g$3.
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.StorageClassSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$StorageClassSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("auto")) {

      yyValue = GNode.create("AutoSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("extern")) {

      yyValue = GNode.create("ExternSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("register")) {

      yyValue = GNode.create("RegisterSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("static")) {

      yyValue = GNode.create("StaticSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__thread")) {

      yyValue = GNode.create("ThreadSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("typedef")) {

      yyResult = pTypedefContext(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = GNode.create("TypedefSpecifier", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("storage class specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.TypeQualifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$TypeQualifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("volatile")) {
      final String v$g$1 = "volatile";

      yyValue = GNode.create("VolatileQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__volatile")) {
      final String v$g$2 = "__volatile";

      yyValue = GNode.create("VolatileQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__volatile__")) {
      final String v$g$3 = "__volatile__";

      yyValue = GNode.create("VolatileQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("const")) {
      final String v$g$1 = "const";

      yyValue = GNode.create("ConstantQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__const")) {
      final String v$g$2 = "__const";

      yyValue = GNode.create("ConstantQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__const__")) {
      final String v$g$3 = "__const__";

      yyValue = GNode.create("ConstantQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("restrict")) {
      final String v$g$1 = "restrict";

      yyValue = GNode.create("RestrictQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__restrict")) {
      final String v$g$2 = "__restrict";

      yyValue = GNode.create("RestrictQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__restrict__")) {
      final String v$g$3 = "__restrict__";

      yyValue = GNode.create("RestrictQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("type qualifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.TypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$TypeSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Enumeration>.

    yyResult = pCommandC$EnumerationTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Structure>.

    yyResult = pCommandC$StructureTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Union>.

    yyResult = pCommandC$UnionTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Floating>.

    yyResult = pCommandC$FloatingPointTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Integer>.

    yyResult = pCommandC$IntegerTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <JavaTyp>.

    yyResult = pCommandC$JavaType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String id = yyResult.semanticValue();

      if (yyState.isType(toText(id))) {

        yyValue = GNode.create("TypedefName", id);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 8.

    yyResult = p$$Shared9(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pCommandC$TypeName(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("TypeofSpecifier", v$g$1);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }

        // Nested alternative 2.

        yyResult = pCommandC$CommaExpression(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("TypeofSpecifier", v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 9.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("void")) {

      yyValue = GNode.create("VoidTypeSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__builtin_va_list")) {

      yyValue = GNode.create("VarArgListSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.EnumerationTypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$EnumerationTypeSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("enum")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pCommandC$AttributeSpecifierList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = cast(yyOpValue1);

        final int yyChoice1 = yyOption1;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pCIdentifier$Identifier(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final String v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$2.
          final String v$g$2 = cast(yyOpValue1);

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("{")) {

            yyResult = pCommandC$EnumeratorList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(",")) {

                yyOption1  = yyResult.index;
              } else {
                yyError = yyError.select("',' expected", yyBase);
              }

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue("}")) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pCommandC$AttributeSpecifierList(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  final Node v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
                { // Start scope for v$g$4.
                  final Node v$g$4 = cast(yyOpValue1);

                  yyValue = GNode.create("EnumerationTypeDefinition", v$g$1, v$g$2, v$g$3, v$g$4);
                  yyValue.setLocation(location(yyStart));

                  return new SemanticValue(yyValue, yyOption1, yyError);
                } // End scope for v$g$4.
              } else {
                yyError = yyError.select("'}' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("'{' expected", yyBase);
          }
        } // End scope for v$g$2.

        // Nested alternative 2.

        yyResult = pCIdentifier$Identifier(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("EnumerationTypeReference", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("enumeration type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.EnumeratorList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$EnumeratorList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <List>.

    yyResult = pCommandC$Enumerator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pCommandC$Enumerator(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("EnumeratorList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.Enumerator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$Enumerator(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Enumerator>.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String id = yyResult.semanticValue();

      yyState.bind(toText(id), false);

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("=")) {

        yyResult = pCommandC$ConditionalExpression(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = yyOpValue1;

        yyValue = GNode.create("Enumerator", id, v$g$1);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.StructureTypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$StructureTypeSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("struct")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pCommandC$AttributeSpecifierList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = cast(yyOpValue1);

        final int yyChoice1 = yyOption1;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pCIdentifier$Identifier(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final String v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$2.
          final String v$g$2 = cast(yyOpValue1);

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("{")) {

            yyResult = pPushScope(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pEnterStructure(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pCommandC$StructureDeclarationList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$3 = yyResult.semanticValue();

                  yyBase   = yyResult.index;
                  yyResult = pSymbol(yyBase);
                  if (yyResult.hasValue("}")) {

                    yyResult = pExitStructure(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pPopScope(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyOption1  = yyResult.index;
                        yyOpValue1 = null;

                        yyResult = 
                          pCommandC$AttributeSpecifierList(yyOption1);
                        yyError  = yyResult.select(yyError, yyOption1);
                        if (yyResult.hasValue()) {
                          final Node v$el$3 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$3;
                        }
                        { // Start scope for v$g$4.
                          final Node v$g$4 = cast(yyOpValue1);

                          yyValue = GNode.create("StructureTypeDefinition", v$g$1, v$g$2, v$g$3, v$g$4);
                          yyValue.setLocation(location(yyStart));

                          return new SemanticValue(yyValue, yyOption1, yyError);
                        } // End scope for v$g$4.
                      }
                    }
                  } else {
                    yyError = yyError.select("'}' expected", yyBase);
                  }
                }
              }
            }
          } else {
            yyError = yyError.select("'{' expected", yyBase);
          }
        } // End scope for v$g$2.

        // Nested alternative 2.

        yyResult = pCIdentifier$Identifier(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("StructureTypeReference", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("structure type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.UnionTypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$UnionTypeSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("union")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pCommandC$AttributeSpecifierList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = cast(yyOpValue1);

        final int yyChoice1 = yyOption1;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pCIdentifier$Identifier(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final String v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$2.
          final String v$g$2 = cast(yyOpValue1);

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("{")) {

            yyResult = pPushScope(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pEnterStructure(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {

                yyResult = pCommandC$StructureDeclarationList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$3 = yyResult.semanticValue();

                  yyBase   = yyResult.index;
                  yyResult = pSymbol(yyBase);
                  if (yyResult.hasValue("}")) {

                    yyResult = pExitStructure(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pPopScope(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyOption1  = yyResult.index;
                        yyOpValue1 = null;

                        yyResult = 
                          pCommandC$AttributeSpecifierList(yyOption1);
                        yyError  = yyResult.select(yyError, yyOption1);
                        if (yyResult.hasValue()) {
                          final Node v$el$3 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$3;
                        }
                        { // Start scope for v$g$4.
                          final Node v$g$4 = cast(yyOpValue1);

                          yyValue = GNode.create("UnionTypeDefinition", v$g$1, v$g$2, v$g$3, v$g$4);
                          yyValue.setLocation(location(yyStart));

                          return new SemanticValue(yyValue, yyOption1, yyError);
                        } // End scope for v$g$4.
                      }
                    }
                  } else {
                    yyError = yyError.select("'}' expected", yyBase);
                  }
                }
              }
            }
          } else {
            yyError = yyError.select("'{' expected", yyBase);
          }
        } // End scope for v$g$2.

        // Nested alternative 2.

        yyResult = pCIdentifier$Identifier(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("UnionTypeReference", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("union type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.StructureDeclarationList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$StructureDeclarationList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Regular>.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pCommandC$AnnotatedStructureDeclaration(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyResult = p$$Shared6(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("StructureDeclarationList", v$g$1.size() + 1).
          addAll(v$g$1).add(v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Empty>.

    if (GCC) {

      yyResult = p$$Shared6(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("StructureDeclarationList", v$g$3);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("structure declaration list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.AnnotatedStructureDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AnnotatedStructureDeclaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative 1.

    yyState.mark();

    yyResult = pCommandC$StructureDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node d = yyResult.semanticValue();

      yyValue = yyState.annotate(d);

      // Commit the state modification.
      yyState.commit();

      setLocation(yyValue, yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.StructureDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$StructureDeclaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declaration>.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pKeyword(yyBase);
    if (yyResult.hasValue("__extension__")) {
      final String v$el$1 = "__extension__";

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    } else {
      yyError = yyError.select("'__extension__' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final String v$g$1 = yyOpValue1;

      yyResult = pCommandC$SpecifierQualifierList(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pCommandC$OptionalStructureDeclaratorList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyOption1  = yyResult.index;

            if (GCC) {

              yyRepetition1 = yyOption1;
              yyRepeated1   = false;
              while (true) {

                yyBase   = yyRepetition1;
                yyResult = pSymbol(yyBase);
                if (yyResult.hasValue(";")) {

                  yyRepetition1 = yyResult.index;
                  yyRepeated1   = true;
                  continue;
                } else {
                  yyError = yyError.select("';' expected", yyBase);
                }
                break;
              }

              if (yyRepeated1) {

                yyOption1  = yyRepetition1;
              }
            }

            yyValue = GNode.create("StructureDeclaration", v$g$1, v$g$2, v$g$3);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      }
    } // End scope for v$g$1.

    // Done.
    yyError = yyError.select("structure declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.SpecifierQualifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$SpecifierQualifierList(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fCommandC$SpecifierQualifierList) 
      yyColumn.chunk8.fCommandC$SpecifierQualifierList = pCommandC$SpecifierQualifierList$1(yyStart);
    return yyColumn.chunk8.fCommandC$SpecifierQualifierList;
  }

  /** Actually parse xtc.lang.blink.CommandC.SpecifierQualifierList. */
  private Result pCommandC$SpecifierQualifierList$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandC$SpecifierQualifierPlus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("SpecifierQualifierList", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.SpecifierQualifierPlus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$SpecifierQualifierPlus(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pCommandC$SpecifierQualifier(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.SpecifierQualifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$SpecifierQualifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <TypeSpecifier>.

    yyResult = pCommandC$TypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pTypeSpecContext(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <TypeQualifier>.

    yyResult = pCommandC$TypeQualifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Attribute>.

    yyResult = pCommandC$AttributeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * xtc.lang.blink.CommandC.OptionalStructureDeclaratorList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$OptionalStructureDeclaratorList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <List>.

    yyResult = pCommandC$StructureDeclaratorList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Null>.

    if (GCC) {
      { // Start scope for yyValue.
        yyValue = null;

        return new SemanticValue(yyValue, yyStart, yyError);
      } // End scope for yyValue.
    }

    // Done.
    yyError = yyError.select("optional structure declarator list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.StructureDeclaratorList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$StructureDeclaratorList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <List>.

    yyResult = pCommandC$StructureDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pCommandC$StructureDeclarator(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("StructureDeclaratorList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.StructureDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$StructureDeclarator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pCommandC$AttributeSpecifierList(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyOpValue1 = null;

      yyResult = pCommandC$Declarator(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(":")) {

          yyResult = pCommandC$ConditionalExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pCommandC$AttributeSpecifierList(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
            { // Start scope for v$g$4.
              final Node v$g$4 = yyOpValue1;

              yyValue = GNode.create("BitField", v$g$1, v$g$2, v$g$3, v$g$4);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$g$4.
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      } // End scope for v$g$2.
    } // End scope for v$g$1.

    // Alternative <Simple>.

    yyResult = pCommandC$AttributedDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.AttributedDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AttributedDeclarator(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fCommandC$AttributedDeclarator) 
      yyColumn.chunk8.fCommandC$AttributedDeclarator = pCommandC$AttributedDeclarator$1(yyStart);
    return yyColumn.chunk8.fCommandC$AttributedDeclarator;
  }

  /** Actually parse xtc.lang.blink.CommandC.AttributedDeclarator. */
  private Result pCommandC$AttributedDeclarator$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pCommandC$AttributeSpecifierList(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pCommandC$Declarator(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pCommandC$AttributeSpecifierList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyValue = GNode.create("AttributedDeclarator", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$3.
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.Declarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$Declarator(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fCommandC$Declarator) 
      yyColumn.chunk8.fCommandC$Declarator = pCommandC$Declarator$1(yyStart);
    return yyColumn.chunk8.fCommandC$Declarator;
  }

  /** Actually parse xtc.lang.blink.CommandC.Declarator. */
  private Result pCommandC$Declarator$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Pointer>.

    yyResult = pCommandC$PointerDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Direct>.

    yyResult = pCommandC$DirectDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.PointerDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$PointerDeclarator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandC$Pointer(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pCommandC$DirectDeclarator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("PointerDeclarator", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.Pointer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$Pointer(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fCommandC$Pointer) 
      yyColumn.chunk8.fCommandC$Pointer = pCommandC$Pointer$1(yyStart);
    return yyColumn.chunk8.fCommandC$Pointer;
  }

  /** Actually parse xtc.lang.blink.CommandC.Pointer. */
  private Result pCommandC$Pointer$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("*")) {

      yyResult = pCommandC$TypeQualifierList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pCommandC$Pointer(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$2.
          final Node v$g$2 = yyOpValue1;

          yyValue = GNode.create("Pointer", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("pointer expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.TypeQualifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$TypeQualifierList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pCommandC$TypeQualifierList$$Choice1(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("TypeQualifierList", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.TypeQualifierList$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$TypeQualifierList$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandC$TypeQualifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pCommandC$AttributeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.DirectDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$DirectDeclarator(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyBase;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <FullBase>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pCommandC$AttributedDeclarator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$7 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pCommandC$DirectDeclarator$$Tail1(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Action<Node> v$8 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Action<Node>>(v$8, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for v$9.
            final Pair<Action<Node>> v$9 = yyRepValue1.reverse();

            yyValue = apply(v$9, v$g$7, yyStart);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for v$9.
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative <SimpleBase>.

    yyResult = pCommandC$SimpleDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$10 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandC$DirectDeclarator$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$11 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$11, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$12.
        final Pair<Action<Node>> v$12 = yyRepValue1.reverse();

        yyValue = apply(v$12, v$g$10, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$12.
    }

    // Done.
    yyError = yyError.select("direct declarator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.DirectDeclarator$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$DirectDeclarator$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyOption1;
    Node         yyOpValue1;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pPushScope(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pCommandC$ParameterTypeList(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pParameterContext(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pCommandC$JavaThrows(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node javaThrows = yyResult.semanticValue();

                yyValue = new Action<Node>() {
                  public Node run(Node v$1) {
                    return GNode.create("FunctionDeclarator", v$1, v$g$2, javaThrows);
                  }};

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }

        // Nested alternative 2.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pCommandC$IdentifierList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pParameterContext(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pCommandC$JavaThrows(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node javaThrows = yyResult.semanticValue();

                yyValue = new Action<Node>() {
                  public Node run(Node v$1) {
                    return GNode.create("FunctionDeclarator", v$1, v$g$3, javaThrows);
                  }};

                return yyResult.createValue(yyValue, yyError);
              }
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$g$3.
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {

      yyResult = pCommandC$ArrayQualifierList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pCommandC$AssignmentExpression(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$5.
          final Node v$g$5 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("]")) {

            yyValue = new Action<Node>() {
              public Node run(Node v$1) {
                return GNode.create("ArrayDeclarator", v$1, v$g$4, v$g$5);
              }};

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("']' expected", yyBase);
          }
        } // End scope for v$g$5.

        // Nested alternative 2.

        yyResult = pCommandC$VariableLength(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$6 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("]")) {

            yyValue = new Action<Node>() {
              public Node run(Node v$1) {
                return GNode.create("ArrayDeclarator", v$1, v$g$4, v$g$6);
              }};

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("']' expected", yyBase);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("direct declarator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.VariableLength.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$VariableLength(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fCommandC$VariableLength) 
      yyColumn.chunk8.fCommandC$VariableLength = pCommandC$VariableLength$1(yyStart);
    return yyColumn.chunk8.fCommandC$VariableLength;
  }

  /** Actually parse xtc.lang.blink.CommandC.VariableLength. */
  private Result pCommandC$VariableLength$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("*")) {

      yyValue = GNode.create("VariableLength", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("variable length expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.SimpleDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$SimpleDeclarator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declarator>.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String id = yyResult.semanticValue();

      yyState.bind(toText(id));

      yyValue = GNode.create("SimpleDeclarator", id);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.ParameterTypeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$ParameterTypeList(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fCommandC$ParameterTypeList) 
      yyColumn.chunk8.fCommandC$ParameterTypeList = pCommandC$ParameterTypeList$1(yyStart);
    return yyColumn.chunk8.fCommandC$ParameterTypeList;
  }

  /** Actually parse xtc.lang.blink.CommandC.ParameterTypeList. */
  private Result pCommandC$ParameterTypeList$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandC$ParameterList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(",")) {

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("...")) {
          final String v$el$1 = "...";

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        } else {
          yyError = yyError.select("'...' expected", yyBase);
        }
      } else {
        yyError = yyError.select("',' expected", yyBase);
      }
      { // Start scope for v$g$2.
        final String v$g$2 = yyOpValue1;

        yyValue = GNode.create("ParameterTypeList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.ParameterList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$ParameterList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandC$ParameterDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pCommandC$ParameterDeclaration(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("ParameterList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.ParameterDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$ParameterDeclaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative 1.

    yyResult = pCommandC$DeclarationSpecifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pCommandC$Declarator(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pCommandC$AttributeSpecifierList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyValue = GNode.create("ParameterDeclaration", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          // Commit the state modification.
          yyState.commit();

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$3.
      }

      // Nested alternative 2.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pCommandC$AbstractDeclarator(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for v$g$4.
        final Node v$g$4 = yyOpValue1;

        yyOpValue1 = null;

        yyResult = pCommandC$AttributeSpecifierList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
        { // Start scope for v$g$5.
          final Node v$g$5 = yyOpValue1;

          yyValue = GNode.create("ParameterDeclaration", v$g$1, v$g$4, v$g$5);
          yyValue.setLocation(location(yyStart));

          // Commit the state modification.
          yyState.commit();

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$5.
      } // End scope for v$g$4.
    }

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.AttributedAbstractDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AttributedAbstractDeclarator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pCommandC$AttributeSpecifierList(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pCommandC$AbstractDeclarator(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("AttributedAbstractDeclarator", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.AbstractDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AbstractDeclarator(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fCommandC$AbstractDeclarator) 
      yyColumn.chunk8.fCommandC$AbstractDeclarator = pCommandC$AbstractDeclarator$1(yyStart);
    return yyColumn.chunk8.fCommandC$AbstractDeclarator;
  }

  /** Actually parse xtc.lang.blink.CommandC.AbstractDeclarator. */
  private Result pCommandC$AbstractDeclarator$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pCommandC$Pointer(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for p.
      final Node p = yyOpValue1;

      yyResult = pCommandC$DirectAbstractDeclarator(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node d = yyResult.semanticValue();

        if ((null != p) || (null != d)) {

          yyValue = GNode.create("AbstractDeclarator", p, d);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } // End scope for p.

    // Done.
    yyError = yyError.select("abstract declarator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.DirectAbstractDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$DirectAbstractDeclarator(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyBase;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Parenthesized>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pCommandC$AttributedAbstractDeclarator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$7 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = 
              pCommandC$DirectAbstractDeclarator$$Tail1(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Action<Node> v$8 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Action<Node>>(v$8, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for v$9.
            final Pair<Action<Node>> v$9 = yyRepValue1.reverse();

            yyValue = apply(v$9, v$g$7, yyStart);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for v$9.
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative <Empty>.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pCommandC$DirectAbstractDeclarator$$Tail1(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Action<Node> v$11 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Action<Node>>(v$11, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$12.
      final Pair<Action<Node>> v$12 = yyRepValue1.reverse();

      yyValue = apply(v$12, null, yyStart);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$12.
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.DirectAbstractDeclarator$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$DirectAbstractDeclarator$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyOption1;
    Node         yyOpValue1;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {
      final String v$g$2 = "[";

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pCommandC$AssignmentExpression(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$3.
        final Node v$g$3 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("DirectAbstractDeclarator", v$1, v$g$2, v$g$3);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      } // End scope for v$g$3.

      // Nested alternative 2.

      yyResult = pCommandC$VariableLength(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("DirectAbstractDeclarator", v$1, v$g$2, v$g$4);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {
      final String v$g$5 = "(";

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pCommandC$ParameterTypeList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for v$g$6.
        final Node v$g$6 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("DirectAbstractDeclarator", v$1, v$g$5, v$g$6);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      } // End scope for v$g$6.
    }

    // Done.
    yyError = yyError.select("direct abstract declarator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.IdentifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$IdentifierList(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Node         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String id1 = yyResult.semanticValue();

      yyState.bind(toText(id1));

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pCIdentifier$Identifier(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final String id2 = yyResult.semanticValue();

            yyState.bind(toText(id2));

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<String>(id2, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$1.
        final Pair<String> v$g$1 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("IdentifierList", id1, v$g$1);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.ArrayQualifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$ArrayQualifierList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pCommandC$ArrayQualifierList$$Choice1(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("ArrayQualifierList", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.ArrayQualifierList$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$ArrayQualifierList$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("static")) {

      yyValue = GNode.create("StaticSpecifier", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("volatile")) {
      final String v$g$1 = "volatile";

      yyValue = GNode.create("VolatileQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__volatile")) {
      final String v$g$2 = "__volatile";

      yyValue = GNode.create("VolatileQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__volatile__")) {
      final String v$g$3 = "__volatile__";

      yyValue = GNode.create("VolatileQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("restrict")) {
      final String v$g$1 = "restrict";

      yyValue = GNode.create("RestrictQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__restrict")) {
      final String v$g$2 = "__restrict";

      yyValue = GNode.create("RestrictQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__restrict__")) {
      final String v$g$3 = "__restrict__";

      yyValue = GNode.create("RestrictQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("const")) {
      final String v$g$1 = "const";

      yyValue = GNode.create("ConstantQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__const")) {
      final String v$g$2 = "__const";

      yyValue = GNode.create("ConstantQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__const__")) {
      final String v$g$3 = "__const__";

      yyValue = GNode.create("ConstantQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 11.

    yyResult = pCommandC$AttributeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("array qualifier list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.FloatingPointTypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$FloatingPointTypeSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("_Complex")) {
      final String v$g$1 = "_Complex";

      yyValue = GNode.create("Complex", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__complex__")) {
      final String v$g$2 = "__complex__";

      yyValue = GNode.create("Complex", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("double")) {

      yyValue = GNode.create("Double", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("float")) {

      yyValue = GNode.create("Float", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("floating point type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.IntegerTypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$IntegerTypeSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("long")) {

      yyValue = GNode.create("Long", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("int")) {

      yyValue = GNode.create("Int", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("short")) {

      yyValue = GNode.create("Short", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("char")) {

      yyValue = GNode.create("Char", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("_Bool")) {

      yyValue = GNode.create("Bool", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("unsigned")) {

      yyValue = GNode.create("Unsigned", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("signed")) {
      final String v$g$1 = "signed";

      yyValue = GNode.create("Signed", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__signed")) {
      final String v$g$2 = "__signed";

      yyValue = GNode.create("Signed", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__signed__")) {
      final String v$g$3 = "__signed__";

      yyValue = GNode.create("Signed", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("integer type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.Initializer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$Initializer(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Complex>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyResult = pCommandC$InitializerList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyOption1  = yyResult.index;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyOption1  = yyResult.index;
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("}")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      }
    }

    // Alternative <Simple>.

    yyResult = pCommandC$AssignmentExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("initializer expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.InitializerList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$InitializerList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandC$InitializerListEntry(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pCommandC$InitializerListEntry(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("InitializerList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Alternative 2.

    if (GCC) {

      yyValue = GNode.create("InitializerList", false);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyStart, yyError);
    }

    // Done.
    yyError = yyError.select("initializer list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.InitializerListEntry.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$InitializerListEntry(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pCommandC$Designation(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pCommandC$Initializer(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("InitializerListEntry", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.Designation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$Designation(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Standard>.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pCommandC$Designator(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyBase   = yyRepetition1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("=")) {

        yyValue = GNode.createFromPair("Designation", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Alternative 2.

    if (GCC) {

      final int yyChoice1 = yyStart;

      // Nested alternative 1.

      yyResult = pCommandC$ObsoleteArrayDesignation(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pCommandC$ObsoleteFieldDesignation(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("designation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.Designator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$Designator(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Array>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {
      final String v$g$1 = "[";

      yyResult = pCommandC$ConditionalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = GNode.create("Designator", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative <ArrayRange>.

    if (GCC) {

      yyResult = pSymbol(yyStart);
      if (yyResult.hasValue("[")) {
        final String v$g$3 = "[";

        yyResult = pCommandC$ConditionalExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("...")) {

            yyResult = pCommandC$ConditionalExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$5 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue("]")) {

                yyValue = GNode.create("Designator", v$g$3, v$g$4, v$g$5);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("']' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("'...' expected", yyBase);
          }
        }
      }
    }

    // Alternative <Structure>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(".")) {
      final String v$g$6 = ".";

      yyResult = pCommandC$PrimaryIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$7 = yyResult.semanticValue();

        yyValue = GNode.create("Designator", v$g$6, v$g$7);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("designator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.ObsoleteArrayDesignation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$ObsoleteArrayDesignation(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {
      final String v$g$1 = "[";

      yyResult = pCommandC$ConditionalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyBase   = yyChoice1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = GNode.create("ObsoleteArrayDesignation", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }

        // Nested alternative 2.

        yyBase   = yyChoice1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("...")) {

          yyResult = pCommandC$ConditionalExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$3 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue("]")) {

              yyValue = GNode.create("ObsoleteArrayDesignation", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("']' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'...' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("obsolete array designation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.ObsoleteFieldDesignation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$ObsoleteFieldDesignation(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyValue = GNode.create("ObsoleteFieldDesignation", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.TypeName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$TypeName(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fCommandC$TypeName) 
      yyColumn.chunk8.fCommandC$TypeName = pCommandC$TypeName$1(yyStart);
    return yyColumn.chunk8.fCommandC$TypeName;
  }

  /** Actually parse xtc.lang.blink.CommandC.TypeName. */
  private Result pCommandC$TypeName$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative 1.

    yyResult = pCommandC$SpecifierQualifierList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pCommandC$AbstractDeclarator(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("TypeName", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        // Commit the state modification.
        yyState.commit();

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.AttributeSpecifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AttributeSpecifierList(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk8) yyColumn.chunk8 = new Chunk8();
    if (null == yyColumn.chunk8.fCommandC$AttributeSpecifierList) 
      yyColumn.chunk8.fCommandC$AttributeSpecifierList = pCommandC$AttributeSpecifierList$1(yyStart);
    return yyColumn.chunk8.fCommandC$AttributeSpecifierList;
  }

  /** Actually parse xtc.lang.blink.CommandC.AttributeSpecifierList. */
  private Result pCommandC$AttributeSpecifierList$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandC$AttributeSpecifierPlus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("AttributeSpecifierList", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.AttributeSpecifierPlus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AttributeSpecifierPlus(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pCommandC$AttributeSpecifier(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.AttributeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AttributeSpecifier(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fCommandC$AttributeSpecifier) 
      yyColumn.chunk9.fCommandC$AttributeSpecifier = pCommandC$AttributeSpecifier$1(yyStart);
    return yyColumn.chunk9.fCommandC$AttributeSpecifier;
  }

  /** Actually parse xtc.lang.blink.CommandC.AttributeSpecifier. */
  private Result pCommandC$AttributeSpecifier$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared10(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("(")) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pCommandC$AttributeList(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$1.
            final Node v$g$1 = yyOpValue1;

            yyBase   = yyOption1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(")")) {

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(")")) {

                yyValue = GNode.create("AttributeSpecifier", v$g$1);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          } // End scope for v$g$1.
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.AttributeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AttributeList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandC$AttributeListEntry(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pCommandC$AttributeListEntry(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("AttributeList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.AttributeListEntry.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AttributeListEntry(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    int        yyOption2;
    Node       yyOpValue2;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCIdentifier$Word(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyOption2  = yyResult.index;
        yyOpValue2 = null;

        yyResult = pCommandC$ExpressionList(yyOption2);
        yyError  = yyResult.select(yyError, yyOption2);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption2  = yyResult.index;
          yyOpValue2 = v$el$2;
        }
        { // Start scope for v$el$1.
          final Node v$el$1 = yyOpValue2;

          yyBase   = yyOption2;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$el$1.
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("AttributeListEntry", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$Statement(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fCommandC$Statement) 
      yyColumn.chunk9.fCommandC$Statement = pCommandC$Statement$1(yyStart);
    return yyColumn.chunk9.fCommandC$Statement;
  }

  /** Actually parse xtc.lang.blink.CommandC.Statement. */
  private Result pCommandC$Statement$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandC$CommaExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(";")) {

        yyValue = GNode.create("ExpressionStatement", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative <JavaInCStatement>.

    yyResult = pCommandC$JavaInCStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Cancel>.

    yyResult = pCommandC$CancelStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Commit>.

    yyResult = pCommandC$CommitStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <With>.

    yyResult = pCommandC$WithStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Compound>.

    yyResult = pCommandC$CompoundStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("if")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pCommandC$CommaExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pCommandC$Statement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              final int yyChoice1 = yyResult.index;

              // Nested alternative 1.

              yyBase   = yyChoice1;
              yyResult = pKeyword(yyBase);
              if (yyResult.hasValue("else")) {

                yyResult = pCommandC$Statement(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$3 = yyResult.semanticValue();

                  yyValue = GNode.create("IfElseStatement", v$g$1, v$g$2, v$g$3);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                }
              } else {
                yyError = yyError.select("'else' expected", yyBase);
              }

              // Nested alternative 2.

              yyValue = GNode.create("IfStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyChoice1, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 8.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("while")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pCommandC$CommaExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pCommandC$Statement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyValue = GNode.create("WhileStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 9.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("do")) {

      yyResult = pCommandC$Statement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pKeyword(yyBase);
        if (yyResult.hasValue("while")) {

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("(")) {

            yyResult = pCommandC$CommaExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(")")) {

                yyBase   = yyResult.index;
                yyResult = pSymbol(yyBase);
                if (yyResult.hasValue(";")) {

                  yyValue = GNode.create("DoStatement", v$g$1, v$g$2);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                } else {
                  yyError = yyError.select("';' expected", yyBase);
                }
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("'(' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'while' expected", yyBase);
        }
      }
    }

    // Alternative 10.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("for")) {

      yyResult = pPushScope(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("(")) {

          yyResult = pCommandC$InitialClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pCommandC$CommaExpression(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
            { // Start scope for v$g$2.
              final Node v$g$2 = yyOpValue1;

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(";")) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pCommandC$CommaExpression(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  final Node v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
                { // Start scope for v$g$3.
                  final Node v$g$3 = yyOpValue1;

                  yyBase   = yyOption1;
                  yyResult = pSymbol(yyBase);
                  if (yyResult.hasValue(")")) {

                    yyResult = pCommandC$Statement(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      final Node v$g$4 = yyResult.semanticValue();

                      yyResult = pPopScope(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyValue = GNode.create("ForStatement", v$g$1, v$g$2, v$g$3, v$g$4);
                        yyValue.setLocation(location(yyStart));

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  } else {
                    yyError = yyError.select("')' expected", yyBase);
                  }
                } // End scope for v$g$3.
              } else {
                yyError = yyError.select("';' expected", yyBase);
              }
            } // End scope for v$g$2.
          }
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      }
    }

    // Alternative 11.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("switch")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pCommandC$CommaExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pCommandC$Statement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyValue = GNode.create("SwitchStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative <Complete>.

    yyResult = pCommandC$Label(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pCommandC$Statement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("LabeledStatement", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Incomplete>.

    if (GCC) {

      yyResult = pCommandC$Label(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("LabeledStatement", v$g$3, null);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 14.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("break")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(";")) {

        yyValue = GNode.create("BreakStatement", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 15.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("continue")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(";")) {

        yyValue = GNode.create("ContinueStatement", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 16.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("return")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pCommandC$CommaExpression(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("ReturnStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Alternative <Direct>.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("goto")) {

      yyResult = pCommandC$PrimaryIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("GotoStatement", null, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Alternative <Computed>.

    if (GCC) {

      yyResult = pKeyword(yyStart);
      if (yyResult.hasValue("goto")) {

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("*")) {
          final String v$g$3 = "*";

          yyResult = pCommandC$CommaExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$4 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(";")) {

              yyValue = GNode.create("GotoStatement", v$g$3, v$g$4);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("';' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'*' expected", yyBase);
        }
      }
    }

    // Alternative 19.

    yyResult = p$$Shared18(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pCommandC$TypeQualifier(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("(")) {

          yyResult = pCommandC$AssemblyArgument(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(")")) {

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(";")) {
                final String v$g$3 = ";";

                yyValue = GNode.create("AssemblyStatement", v$g$1, v$g$2, v$g$3);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("';' expected", yyBase);
              }
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Alternative 20.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(";")) {

      yyValue = GNode.create("EmptyStatement", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.Label.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$Label(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Label>.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pCommandC$AttributeSpecifierList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$2.
          final Node v$g$2 = yyOpValue1;

          yyValue = GNode.create("NamedLabel", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$2.
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Alternative <Range>.

    if (GCC) {

      yyResult = pKeyword(yyStart);
      if (yyResult.hasValue("case")) {

        yyResult = pCommandC$ConditionalExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("...")) {

            yyResult = pCommandC$ConditionalExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(":")) {

                yyValue = GNode.create("CaseLabel", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("':' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("'...' expected", yyBase);
          }
        }
      }
    }

    // Alternative <Simple>.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("case")) {

      yyResult = pCommandC$ConditionalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(":")) {

          yyValue = GNode.create("CaseLabel", v$g$3);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("default")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyValue = GNode.create("DefaultLabel", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("label expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.CompoundStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$CompoundStatement(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fCommandC$CompoundStatement) 
      yyColumn.chunk9.fCommandC$CompoundStatement = pCommandC$CompoundStatement$1(yyStart);
    return yyColumn.chunk9.fCommandC$CompoundStatement;
  }

  /** Actually parse xtc.lang.blink.CommandC.CompoundStatement. */
  private Result pCommandC$CompoundStatement$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <CBlock>.

    yyResult = pCommandC$CInCBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <JavaBlock>.

    yyResult = pCommandC$JavaInCBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.LocalLabelDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$LocalLabelDeclaration(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyRepetition1;
    Pair<String> yyRepValue1;
    Node         yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__label__")) {

      yyResult = pCIdentifier$Identifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pCIdentifier$Identifier(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final String v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<String>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<String> v$g$2 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyValue = GNode.createFromPair("LocalLabelDeclaration", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("local label declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.DeclarationOrStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$DeclarationOrStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative <Declaration>.

    yyState.mark();

    yyResult = pCommandC$Declaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node d = yyResult.semanticValue();

      yyValue = yyState.annotate(d);

      // Commit the state modification.
      yyState.commit();

      setLocation(yyValue, yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Statement>.

    yyResult = pCommandC$Statement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node s = yyResult.semanticValue();

      yyValue = yyState.annotate(s);

      // Commit the state modification.
      yyState.commit();

      setLocation(yyValue, yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.InitialClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$InitialClause(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative <Declaration>.

    yyResult = pCommandC$Declaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      // Commit the state modification.
      yyState.commit();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Expression>.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pCommandC$CommaExpression(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$3 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$3;
    }
    { // Start scope for yyValue.
      yyValue = yyOpValue1;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(";")) {

        // Commit the state modification.
        yyState.commit();

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    } // End scope for yyValue.

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.CommaExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$CommaExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fCommandC$CommaExpression) 
      yyColumn.chunk9.fCommandC$CommaExpression = pCommandC$CommaExpression$1(yyStart);
    return yyColumn.chunk9.fCommandC$CommaExpression;
  }

  /** Actually parse xtc.lang.blink.CommandC.CommaExpression. */
  private Result pCommandC$CommaExpression$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandC$AssignmentExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandC$CommaExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.CommaExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$CommaExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Comma>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pCommandC$AssignmentExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("CommaExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("comma expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.AssignmentExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AssignmentExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fCommandC$AssignmentExpression) 
      yyColumn.chunk9.fCommandC$AssignmentExpression = pCommandC$AssignmentExpression$1(yyStart);
    return yyColumn.chunk9.fCommandC$AssignmentExpression;
  }

  /** Actually parse xtc.lang.blink.CommandC.AssignmentExpression. */
  private Result pCommandC$AssignmentExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Assignment>.

    yyResult = pCommandC$UnaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = p$$Shared11(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$2 = yyResult.semanticValue();

        yyResult = pCommandC$AssignmentExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("AssignmentExpression", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pCommandC$ConditionalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.ConditionalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$ConditionalExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fCommandC$ConditionalExpression) 
      yyColumn.chunk9.fCommandC$ConditionalExpression = pCommandC$ConditionalExpression$1(yyStart);
    return yyColumn.chunk9.fCommandC$ConditionalExpression;
  }

  /** Actually parse xtc.lang.blink.CommandC.ConditionalExpression. */
  private Result pCommandC$ConditionalExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Conditional>.

    yyResult = pCommandC$LogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("?")) {

        yyResult = pCommandC$CommaExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(":")) {

            yyResult = pCommandC$ConditionalExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("ConditionalExpression", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'?' expected", yyBase);
      }
    }

    // Alternative <IncompleteConditional>.

    if (GCC) {

      yyResult = pCommandC$LogicalOrExpression(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("?")) {

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(":")) {

            yyResult = pCommandC$ConditionalExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$6 = yyResult.semanticValue();

              yyValue = GNode.create("ConditionalExpression", v$g$4, null, v$g$6);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'?' expected", yyBase);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pCommandC$LogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("conditional expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.LogicalOrExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$LogicalOrExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fCommandC$LogicalOrExpression) 
      yyColumn.chunk9.fCommandC$LogicalOrExpression = pCommandC$LogicalOrExpression$1(yyStart);
    return yyColumn.chunk9.fCommandC$LogicalOrExpression;
  }

  /** Actually parse xtc.lang.blink.CommandC.LogicalOrExpression. */
  private Result pCommandC$LogicalOrExpression$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandC$LogicalAndExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandC$LogicalOrExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.LogicalOrExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$LogicalOrExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Or>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("||")) {

      yyResult = pCommandC$LogicalAndExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalOrExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical or expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.LogicalAndExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$LogicalAndExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandC$BitwiseOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandC$LogicalAndExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.LogicalAndExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$LogicalAndExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <And>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&&")) {

      yyResult = pCommandC$BitwiseOrExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalAndExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical and expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.BitwiseOrExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$BitwiseOrExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandC$BitwiseXorExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandC$BitwiseOrExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.BitwiseOrExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$BitwiseOrExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Or>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("|")) {

      yyResult = pCommandC$BitwiseXorExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseOrExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise or expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.BitwiseXorExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$BitwiseXorExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandC$BitwiseAndExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandC$BitwiseXorExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.BitwiseXorExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$BitwiseXorExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Xor>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("^")) {

      yyResult = pCommandC$BitwiseAndExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseXorExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise xor expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.BitwiseAndExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$BitwiseAndExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandC$EqualityExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandC$BitwiseAndExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.BitwiseAndExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$BitwiseAndExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <And>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&")) {

      yyResult = pCommandC$EqualityExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseAndExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise and expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.EqualityExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$EqualityExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandC$RelationalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandC$EqualityExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.EqualityExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$EqualityExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared12(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pCommandC$RelationalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("EqualityExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.RelationalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$RelationalExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandC$ShiftExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandC$RelationalExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.RelationalExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$RelationalExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared13(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pCommandC$ShiftExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("RelationalExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.ShiftExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$ShiftExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandC$AdditiveExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandC$ShiftExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.ShiftExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$ShiftExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared14(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pCommandC$AdditiveExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("ShiftExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.AdditiveExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AdditiveExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandC$MultiplicativeExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandC$AdditiveExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.AdditiveExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AdditiveExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared15(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pCommandC$MultiplicativeExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("AdditiveExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.MultiplicativeExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$MultiplicativeExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandC$CastExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandC$MultiplicativeExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.MultiplicativeExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$MultiplicativeExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared16(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pCommandC$CastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("MultiplicativeExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.CastExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$CastExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fCommandC$CastExpression) 
      yyColumn.chunk9.fCommandC$CastExpression = pCommandC$CastExpression$1(yyStart);
    return yyColumn.chunk9.fCommandC$CastExpression;
  }

  /** Actually parse xtc.lang.blink.CommandC.CastExpression. */
  private Result pCommandC$CastExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Cast>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pCommandC$TypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyResult = pCommandC$CastExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("CastExpression", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pCommandC$UnaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("cast expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.UnaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$UnaryExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fCommandC$UnaryExpression) 
      yyColumn.chunk9.fCommandC$UnaryExpression = pCommandC$UnaryExpression$1(yyStart);
    return yyColumn.chunk9.fCommandC$UnaryExpression;
  }

  /** Actually parse xtc.lang.blink.CommandC.UnaryExpression. */
  private Result pCommandC$UnaryExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("sizeof")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pCommandC$TypeName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyPredMatched = false;

            yyPredResult = pSymbol(yyResult.index);
            if (yyPredResult.hasValue("{")) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = GNode.create("SizeofExpression", v$g$1);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("unary expression expected", yyStart);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }

      // Nested alternative 2.

      yyResult = pCommandC$UnaryExpression(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("SizeofExpression", v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = p$$Shared17(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pCommandC$TypeName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyPredMatched = false;

            yyPredResult = pSymbol(yyResult.index);
            if (yyPredResult.hasValue("{")) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {

              yyValue = GNode.create("AlignofExpression", v$g$1);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("unary expression expected", yyStart);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }

      // Nested alternative 2.

      yyResult = pCommandC$UnaryExpression(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("AlignofExpression", v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__builtin_offsetof")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pCommandC$TypeName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pCommandC$PostfixExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(")")) {

                yyValue = GNode.create("OffsetofExpression", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__builtin_types_compatible_p")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pCommandC$TypeName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pCommandC$TypeName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(")")) {

                yyValue = GNode.create("TypeCompatibilityExpression", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 5.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("-")) {

      yyResult = pCommandC$CastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryMinusExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 6.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("+")) {

      yyResult = pCommandC$CastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryPlusExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <JavaInCExpression>.

    yyResult = pCommandC$JavaInCExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("!")) {

      yyResult = pCommandC$CastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("LogicalNegationExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 9.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("~")) {

      yyResult = pCommandC$CastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("BitwiseNegationExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 10.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&")) {

      yyResult = pCommandC$CastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("AddressExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <LabelAddress>.

    if (GCC) {

      yyResult = pSymbol(yyStart);
      if (yyResult.hasValue("&&")) {

        yyResult = pCIdentifier$Identifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$1 = yyResult.semanticValue();

          yyValue = GNode.create("LabelAddressExpression", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 12.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("*")) {

      yyResult = pCommandC$CastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("IndirectionExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 13.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("++")) {

      yyResult = pCommandC$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("PreincrementExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 14.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("--")) {

      yyResult = pCommandC$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("PredecrementExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Extension>.

    if (GCC) {

      yyResult = pKeyword(yyStart);
      if (yyResult.hasValue("__extension__")) {

        yyResult = pCommandC$CastExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyValue = GNode.create("ExtensionExpression", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pCommandC$PostfixExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("unary expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.PostfixExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$PostfixExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Compound>.

    yyResult = pCommandC$CompoundLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$6 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandC$PostfixExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$7 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$7, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$8.
        final Pair<Action<Node>> v$8 = yyRepValue1.reverse();

        yyValue = apply(v$8, v$g$6, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$8.
    }

    // Alternative <Primary>.

    yyResult = pCommandC$PrimaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$9 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandC$PostfixExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$10 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$10, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$11.
        final Pair<Action<Node>> v$11 = yyRepValue1.reverse();

        yyValue = apply(v$11, v$g$9, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$11.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.PostfixExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$PostfixExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyOption1;
    Node         yyOpValue1;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {

      yyResult = pCommandC$CommaExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("SubscriptExpression", v$1, v$g$2);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(".")) {

      yyResult = pCIdentifier$Identifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("DirectComponentSelection", v$1, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("->")) {

      yyResult = pCIdentifier$Identifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$4 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("IndirectComponentSelection", v$1, v$g$4);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pCommandC$ExpressionList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$5.
        final Node v$g$5 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("FunctionCall", v$1, v$g$5);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      } // End scope for v$g$5.
    }

    // Alternative 5.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("++")) {

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          return GNode.create("PostincrementExpression", v$1);
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("--")) {

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          return GNode.create("PostdecrementExpression", v$1);
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("postfix expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.ExpressionList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$ExpressionList(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk9) yyColumn.chunk9 = new Chunk9();
    if (null == yyColumn.chunk9.fCommandC$ExpressionList) 
      yyColumn.chunk9.fCommandC$ExpressionList = pCommandC$ExpressionList$1(yyStart);
    return yyColumn.chunk9.fCommandC$ExpressionList;
  }

  /** Actually parse xtc.lang.blink.CommandC.ExpressionList. */
  private Result pCommandC$ExpressionList$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Expressions>.

    yyResult = pCommandC$AssignmentExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pCommandC$ExpressionList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("ExpressionList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.ExpressionList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$ExpressionList$$Star1(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fCommandC$ExpressionList$$Star1) 
      yyColumn.chunk10.fCommandC$ExpressionList$$Star1 = pCommandC$ExpressionList$$Star1$1(yyStart);
    return yyColumn.chunk10.fCommandC$ExpressionList$$Star1;
  }

  /** Actually parse CommandC.ExpressionList$$Star1. */
  private Result pCommandC$ExpressionList$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pCommandC$AssignmentExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyResult = pCommandC$ExpressionList$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.CompoundLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$CompoundLiteral(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pCommandC$TypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("{")) {

            yyResult = pCommandC$InitializerList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(",")) {

                yyOption1  = yyResult.index;
              } else {
                yyError = yyError.select("',' expected", yyBase);
              }

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue("}")) {

                yyValue = GNode.create("CompoundLiteral", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("'}' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("'{' expected", yyBase);
          }
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("compound literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.PrimaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$PrimaryExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Meta>.

    yyResult = pMetaVariable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Constant>.

    yyResult = pConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("PrimaryIdentifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    if (GCC) {

      yyResult = pSymbol(yyStart);
      if (yyResult.hasValue("(")) {

        yyResult = pCommandC$CompoundStatement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("StatementAsExpression", v$g$1);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      }
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("__builtin_va_arg")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pCommandC$AssignmentExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pCommandC$TypeName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(")")) {

                yyValue = GNode.create("VariableArgumentAccess", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative <ParenthesizedExpression>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pCommandC$CommaExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("primary expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.PrimaryIdentifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$PrimaryIdentifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("PrimaryIdentifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.SimpleAssemblyExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$SimpleAssemblyExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared18(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pCConstant$StringConstant(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.create("SimpleAssemblyExpression", v$g$1);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.AssemblyArgument.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AssemblyArgument(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCConstant$StringConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pCommandC$AssemblyOperands(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$2.
          final Node v$g$2 = yyOpValue1;

          final int yyChoice2 = yyOption1;

          // Nested alternative 1.

          yyBase   = yyChoice2;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(":")) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pCommandC$AssemblyOperands(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$3.
              final Node v$g$3 = yyOpValue1;

              final int yyChoice3 = yyOption1;

              // Nested alternative 1.

              yyBase   = yyChoice3;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(":")) {

                yyResult = pCommandC$AssemblyClobbers(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$4 = yyResult.semanticValue();

                  yyValue = GNode.create("AssemblyArgument", v$g$1, v$g$2, v$g$3, v$g$4);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                }
              } else {
                yyError = yyError.select("':' expected", yyBase);
              }

              // Nested alternative 2.

              yyValue = GNode.create("AssemblyArgument", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyChoice3, yyError);
            } // End scope for v$g$3.
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }

          // Nested alternative 2.

          yyValue = GNode.create("AssemblyArgument", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice2, yyError);
        } // End scope for v$g$2.
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }

      // Nested alternative 2.

      yyValue = GNode.create("AssemblyArgument", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.AssemblyOperands.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AssemblyOperands(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fCommandC$AssemblyOperands) 
      yyColumn.chunk10.fCommandC$AssemblyOperands = pCommandC$AssemblyOperands$1(yyStart);
    return yyColumn.chunk10.fCommandC$AssemblyOperands;
  }

  /** Actually parse xtc.lang.blink.CommandC.AssemblyOperands. */
  private Result pCommandC$AssemblyOperands$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandC$AssemblyOperand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pCommandC$AssemblyOperands$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("AssemblyOperands", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.AssemblyOperands$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AssemblyOperands$$Star1(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fCommandC$AssemblyOperands$$Star1) 
      yyColumn.chunk10.fCommandC$AssemblyOperands$$Star1 = pCommandC$AssemblyOperands$$Star1$1(yyStart);
    return yyColumn.chunk10.fCommandC$AssemblyOperands$$Star1;
  }

  /** Actually parse CommandC.AssemblyOperands$$Star1. */
  private Result pCommandC$AssemblyOperands$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pCommandC$AssemblyOperand(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyResult = pCommandC$AssemblyOperands$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.AssemblyOperand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AssemblyOperand(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fCommandC$AssemblyOperand) 
      yyColumn.chunk10.fCommandC$AssemblyOperand = pCommandC$AssemblyOperand$1(yyStart);
    return yyColumn.chunk10.fCommandC$AssemblyOperand;
  }

  /** Actually parse xtc.lang.blink.CommandC.AssemblyOperand. */
  private Result pCommandC$AssemblyOperand$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    String     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pSymbol(yyBase);
    if (yyResult.hasValue("[")) {

      yyResult = pCIdentifier$Word(yyResult.index);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final String v$el$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    } else {
      yyError = yyError.select("'[' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final String v$g$1 = yyOpValue1;

      yyResult = pCConstant$StringConstant(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("(")) {

          yyResult = pCommandC$CommaExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$3 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(")")) {

              yyValue = GNode.create("AssemblyOperand", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.AssemblyClobbers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$AssemblyClobbers(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCConstant$StringConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pCConstant$StringConstant(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("AssemblyClobbers", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.WithStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$WithStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("_with")) {

      yyResult = pPushScope(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("(")) {

          yyResult = pCommandC$WithInitializer(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$1 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(")")) {

              yyResult = pCommandC$CInCBlock(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$2 = yyResult.semanticValue();

                yyResult = pPopScope(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyValue = GNode.create("WithStatement", v$g$1, v$g$2);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                }
              }
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("with statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.WithInitializer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$WithInitializer(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declaration>.

    yyResult = pCommandC$DeclarationNoSemicolon(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Assignment>.

    yyResult = pCommandC$AssignmentExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.DeclarationNoSemicolon.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$DeclarationNoSemicolon(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandC$DeclarationSpecifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$2 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pCommandC$InitializedDeclaratorList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for l.
        final Node l = yyOpValue1;

        if (yyState.isValid(l)) {

          yyValue = GNode.create("Declaration", null, v$g$2, l);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      } // End scope for l.
    }

    // Done.
    yyError = yyError.select("declaration no semicolon expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.CancelStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$CancelStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("_cancel")) {

      yyResult = pCommandC$PrimaryIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("CancelStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("cancel statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.CommitStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$CommitStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue("_commit")) {

      yyResult = pCommandC$PrimaryIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("CommitStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("commit statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.CInCBlock.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$CInCBlock(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fCommandC$CInCBlock) 
      yyColumn.chunk10.fCommandC$CInCBlock = pCommandC$CInCBlock$1(yyStart);
    return yyColumn.chunk10.fCommandC$CInCBlock;
  }

  /** Actually parse xtc.lang.blink.CommandC.CInCBlock. */
  private Result pCommandC$CInCBlock$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyResult = pPushScope(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pCommandC$CInCBlock$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$g$1 = yyResult.semanticValue();

          yyResult = pCommandC$CInCBlock$$Star2(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Pair<Node> v$g$2 = yyResult.semanticValue();

            yyResult = p$$Shared6(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyBase = yyResult.index;
              yyC    = character(yyBase);
              if ('}' == yyC) {
                yyIndex = yyResult.index + 1;

                yyResult = pSpacing(yyIndex);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {

                  yyResult = pPopScope(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyValue = GNode.create("CInCBlock", v$g$1.size() + v$g$2.size() + 1).
                      addAll(v$g$1).addAll(v$g$2).add(v$g$3);
                    yyValue.setLocation(location(yyStart));

                    return yyResult.createValue(yyValue, yyError);
                  }
                }
              } else {
                yyError = yyError.select("'}' expected", yyBase);
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("c in c block expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.CInCBlock$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$CInCBlock$$Star1(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fCommandC$CInCBlock$$Star1) 
      yyColumn.chunk10.fCommandC$CInCBlock$$Star1 = pCommandC$CInCBlock$$Star1$1(yyStart);
    return yyColumn.chunk10.fCommandC$CInCBlock$$Star1;
  }

  /** Actually parse CommandC.CInCBlock$$Star1. */
  private Result pCommandC$CInCBlock$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandC$LocalLabelDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyResult = pCommandC$CInCBlock$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandC.CInCBlock$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$CInCBlock$$Star2(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fCommandC$CInCBlock$$Star2) 
      yyColumn.chunk10.fCommandC$CInCBlock$$Star2 = pCommandC$CInCBlock$$Star2$1(yyStart);
    return yyColumn.chunk10.fCommandC$CInCBlock$$Star2;
  }

  /** Actually parse CommandC.CInCBlock$$Star2. */
  private Result pCommandC$CInCBlock$$Star2$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandC$DeclarationOrStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$el$3 = yyResult.semanticValue();

      yyResult = pCommandC$CInCBlock$$Star2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$4 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$3, v$4);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.JavaInCBlock.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$JavaInCBlock(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared25(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pJeannieJava$JavaInJavaBlock(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("JavaInCBlock", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.JavaInCExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$JavaInCExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared25(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pJeannieJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("JavaInCExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.JavaInCStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$JavaInCStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared25(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pJeannieJava$TryCatchFinallyStatement(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("JavaInCStatement", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pJeannieJava$SynchronizedStatement(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("JavaInCStatement", v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 3.

      yyResult = pJeannieJava$ThrowStatement(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("JavaInCStatement", v$g$3);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.JavaThrows.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$JavaThrows(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fCommandC$JavaThrows) 
      yyColumn.chunk10.fCommandC$JavaThrows = pCommandC$JavaThrows$1(yyStart);
    return yyColumn.chunk10.fCommandC$JavaThrows;
  }

  /** Actually parse xtc.lang.blink.CommandC.JavaThrows. */
  private Result pCommandC$JavaThrows$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = p$$Shared25(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {

      yyResult = pJeannieJava$ThrowsClause(yyResult.index);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyValue = GNode.create("JavaThrows", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyOption1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandC.JavaType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandC$JavaType(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared25(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pJavaType$TypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("JavaType", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.Modifiers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$Modifiers(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fJeannieJava$Modifiers) 
      yyColumn.chunk10.fJeannieJava$Modifiers = pJeannieJava$Modifiers$1(yyStart);
    return yyColumn.chunk10.fJeannieJava$Modifiers;
  }

  /** Actually parse xtc.lang.jeannie.JeannieJava.Modifiers. */
  private Result pJeannieJava$Modifiers$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieJava$ModifierList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("Modifiers", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.ModifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$ModifierList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pJeannieJava$Modifier(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for yyValue.
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for yyValue.
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.Modifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$Modifier(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Public>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("public")) {
      final String v$g$1 = "public";

      yyValue = GNode.create("Modifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Protected>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("protected")) {
      final String v$g$2 = "protected";

      yyValue = GNode.create("Modifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Private>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("private")) {
      final String v$g$3 = "private";

      yyValue = GNode.create("Modifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Static>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("static")) {
      final String v$g$4 = "static";

      yyValue = GNode.create("Modifier", v$g$4);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Abstract>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("abstract")) {
      final String v$g$5 = "abstract";

      yyValue = GNode.create("Modifier", v$g$5);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Final>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("final")) {
      final String v$g$6 = "final";

      yyValue = GNode.create("Modifier", v$g$6);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Native>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("native")) {
      final String v$g$7 = "native";

      yyValue = GNode.create("Modifier", v$g$7);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Synchronized>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("synchronized")) {
      final String v$g$8 = "synchronized";

      yyValue = GNode.create("Modifier", v$g$8);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Transient>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("transient")) {
      final String v$g$9 = "transient";

      yyValue = GNode.create("Modifier", v$g$9);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Volatile>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("volatile")) {
      final String v$g$10 = "volatile";

      yyValue = GNode.create("Modifier", v$g$10);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Strictfp>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("strictfp")) {
      final String v$g$11 = "strictfp";

      yyValue = GNode.create("Modifier", v$g$11);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("modifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.FormalParameter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$FormalParameter(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Parameter>.

    yyResult = pJeannieJava$VariableModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pJavaIdentifier$Identifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$4 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pDimensions(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$5.
            final Node v$g$5 = yyOpValue1;

            yyValue = GNode.create("FormalParameter", v$g$1, v$g$2, null, v$g$4, v$g$5);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for v$g$5.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.VariableModifiers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$VariableModifiers(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Final>.

    yyResult = pJeannieJava$FinalModifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Modifiers", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Nonfinal>.

    yyValue = GNode.create("Modifiers", false);
    yyValue.setLocation(location(yyStart));

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.FinalModifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$FinalModifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("final")) {
      final String v$g$1 = "final";

      yyValue = GNode.create("Modifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("final modifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.FormalParameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$FormalParameters(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk10) yyColumn.chunk10 = new Chunk10();
    if (null == yyColumn.chunk10.fJeannieJava$FormalParameters) 
      yyColumn.chunk10.fJeannieJava$FormalParameters = pJeannieJava$FormalParameters$1(yyStart);
    return yyColumn.chunk10.fJeannieJava$FormalParameters;
  }

  /** Actually parse xtc.lang.jeannie.JeannieJava.FormalParameters. */
  private Result pJeannieJava$FormalParameters$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pJeannieJava$FormalParameter(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyResult = pJeannieJava$FormalParameters$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.createFromPair("FormalParameters", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(")")) {

        yyValue = GNode.create("FormalParameters", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("')' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("formal parameters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieJava.FormalParameters$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$FormalParameters$$Star1(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fJeannieJava$FormalParameters$$Star1) 
      yyColumn.chunk11.fJeannieJava$FormalParameters$$Star1 = pJeannieJava$FormalParameters$$Star1$1(yyStart);
    return yyColumn.chunk11.fJeannieJava$FormalParameters$$Star1;
  }

  /** Actually parse JeannieJava.FormalParameters$$Star1. */
  private Result pJeannieJava$FormalParameters$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pJeannieJava$FormalParameter(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyResult = pJeannieJava$FormalParameters$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.Declarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$Declarator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declarator>.

    yyResult = pJavaIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pDimensions(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyOpValue1 = null;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("=")) {

          yyResult = pJeannieJava$VariableInitializer(yyResult.index);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        } else {
          yyError = yyError.select("'=' expected", yyBase);
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyValue = GNode.create("Declarator", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$3.
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.Declarators.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$Declarators(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fJeannieJava$Declarators) 
      yyColumn.chunk11.fJeannieJava$Declarators = pJeannieJava$Declarators$1(yyStart);
    return yyColumn.chunk11.fJeannieJava$Declarators;
  }

  /** Actually parse xtc.lang.jeannie.JeannieJava.Declarators. */
  private Result pJeannieJava$Declarators$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieJava$Declarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pJeannieJava$Declarators$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("Declarators", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieJava.Declarators$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$Declarators$$Star1(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fJeannieJava$Declarators$$Star1) 
      yyColumn.chunk11.fJeannieJava$Declarators$$Star1 = pJeannieJava$Declarators$$Star1$1(yyStart);
    return yyColumn.chunk11.fJeannieJava$Declarators$$Star1;
  }

  /** Actually parse JeannieJava.Declarators$$Star1. */
  private Result pJeannieJava$Declarators$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pJeannieJava$Declarator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyResult = pJeannieJava$Declarators$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.ClassBody.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$ClassBody(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Body>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieJava$Declaration(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$g$1.
        final Pair<Node> v$g$1 = yyRepValue1.reverse();

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("}")) {

          yyValue = GNode.createFromPair("ClassBody", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("class body expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.Declaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$Declaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieJava$Modifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pType(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pJeannieJava$Declarators(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyValue = GNode.create("FieldDeclaration", v$g$1, v$g$2, v$g$3);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      }

      // Nested alternative 2.
      { // Start scope for nested choice.

        final int yyChoice2 = yyChoice1;

        // Nested alternative 1.

        yyResult = pResultType(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyResult = pJavaIdentifier$Identifier(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final String v$g$4 = yyResult.semanticValue();

            yyResult = pJeannieJava$FormalParameters(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$5 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pDimensions(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                final Node v$el$1 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$1;
              }
              { // Start scope for v$g$6.
                final Node v$g$6 = cast(yyOpValue1);

                yyOpValue1 = null;

                yyResult = pJeannieJava$ThrowsClause(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  final Node v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
                { // Start scope for v$g$7.
                  final Node v$g$7 = cast(yyOpValue1);

                  final int yyChoice3 = yyOption1;

                  // Nested alternative 1.

                  yyResult = pJeannieJava$Block(yyChoice3);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    final Node v$g$8 = yyResult.semanticValue();

                    yyValue = GNode.create("MethodDeclaration", v$g$1, null, v$g$3, v$g$4, v$g$5, v$g$6, v$g$7, v$g$8);
                    yyValue.setLocation(location(yyStart));

                    return yyResult.createValue(yyValue, yyError);
                  }

                  // Nested alternative 2.

                  yyBase   = yyChoice3;
                  yyResult = pSymbol(yyBase);
                  if (yyResult.hasValue(";")) {

                    yyValue = GNode.create("MethodDeclaration", v$g$1, null, v$g$3, v$g$4, v$g$5, v$g$6, v$g$7, null);
                    yyValue.setLocation(location(yyStart));

                    return yyResult.createValue(yyValue, yyError);
                  } else {
                    yyError = yyError.select("';' expected", yyBase);
                  }
                } // End scope for v$g$7.
              } // End scope for v$g$6.
            }
          }
        }

        // Nested alternative 2.

        yyResult = pJavaIdentifier$Identifier(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$3 = yyResult.semanticValue();

          yyResult = pJeannieJava$FormalParameters(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$4 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pJeannieJava$ThrowsClause(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
            { // Start scope for v$g$5.
              final Node v$g$5 = cast(yyOpValue1);

              yyResult = pJeannieJava$Block(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$6 = yyResult.semanticValue();

                yyValue = GNode.create("ConstructorDeclaration", v$g$1, null, v$g$3, v$g$4, v$g$5, v$g$6);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            } // End scope for v$g$5.
          }
        }
      } // End scope for nested choice.

      // Nested alternative 3.

      yyBase   = yyChoice1;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("class")) {

        yyResult = pJavaIdentifier$Identifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pJeannieJava$Extension(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$4.
            final Node v$g$4 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pJeannieJava$Implementation(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$5.
              final Node v$g$5 = cast(yyOpValue1);

              yyResult = pJeannieJava$ClassBody(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$6 = yyResult.semanticValue();

                yyValue = GNode.create("ClassDeclaration", v$g$1, v$g$2, null, v$g$4, v$g$5, v$g$6);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            } // End scope for v$g$5.
          } // End scope for v$g$4.
        }
      } else {
        yyError = yyError.select("'class' expected", yyBase);
      }

      // Nested alternative 4.

      yyBase   = yyChoice1;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("interface")) {

        yyResult = pJavaIdentifier$Identifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pJeannieJava$Extension(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$4.
            final Node v$g$4 = cast(yyOpValue1);

            yyResult = pJeannieJava$ClassBody(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$5 = yyResult.semanticValue();

              yyValue = GNode.create("InterfaceDeclaration", v$g$1, v$g$2, null, v$g$4, v$g$5);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } // End scope for v$g$4.
        }
      } else {
        yyError = yyError.select("'interface' expected", yyBase);
      }
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pJavaIdentifier$Word(yyBase);
    if (yyResult.hasValue("static")) {
      final String v$el$1 = "static";

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    } else {
      yyError = yyError.select("'static' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final String v$g$1 = cast(yyOpValue1);

      yyResult = pJeannieJava$Block(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("BlockDeclaration", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for v$g$1.

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(";")) {

      yyValue = GNode.create("EmptyDeclaration", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.ThrowsClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$ThrowsClause(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("throws")) {

      yyResult = pQualifiedIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pQualifiedIdentifier(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("ThrowsClause", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("throws clause expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.Extension.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$Extension(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("extends")) {

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pType(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("Extension", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("extension expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.Implementation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$Implementation(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("implements")) {

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pType(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("Implementation", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("implementation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.Block.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$Block(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fJeannieJava$Block) 
      yyColumn.chunk11.fJeannieJava$Block = pJeannieJava$Block$1(yyStart);
    return yyColumn.chunk11.fJeannieJava$Block;
  }

  /** Actually parse xtc.lang.jeannie.JeannieJava.Block. */
  private Result pJeannieJava$Block$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <JavaBlock>.

    yyResult = pJeannieJava$JavaInJavaBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <CBlock>.

    yyResult = pJeannieJava$CInJavaBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.DeclarationOrStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$DeclarationOrStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declaration>.

    yyResult = pJeannieJava$InBlockDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Statement>.

    yyResult = pJeannieJava$Statement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.InBlockDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$InBlockDeclaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Variable>.

    yyResult = pJeannieJava$VariableDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pJeannieJava$Modifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("class")) {

        yyResult = pJavaIdentifier$Identifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pJeannieJava$Extension(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$4.
            final Node v$g$4 = yyOpValue1;

            yyOpValue1 = null;

            yyResult = pJeannieJava$Implementation(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$5.
              final Node v$g$5 = yyOpValue1;

              yyResult = pJeannieJava$ClassBody(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$6 = yyResult.semanticValue();

                yyValue = GNode.create("ClassDeclaration", v$g$1, v$g$2, null, v$g$4, v$g$5, v$g$6);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            } // End scope for v$g$5.
          } // End scope for v$g$4.
        }
      } else {
        yyError = yyError.select("'class' expected", yyBase);
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("interface")) {

        yyResult = pJavaIdentifier$Identifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pJeannieJava$Extension(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$4.
            final Node v$g$4 = yyOpValue1;

            yyResult = pJeannieJava$ClassBody(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$5 = yyResult.semanticValue();

              yyValue = GNode.create("InterfaceDeclaration", v$g$1, v$g$2, null, v$g$4, v$g$5);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } // End scope for v$g$4.
        }
      } else {
        yyError = yyError.select("'interface' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.VariableDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$VariableDeclaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declaration>.

    yyResult = pJeannieJava$VariableModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pJeannieJava$Declarators(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyValue = GNode.create("FieldDeclaration", v$g$1, v$g$2, v$g$3);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$Statement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Block>.

    yyResult = pJeannieJava$Block(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("if")) {

      yyResult = pJeannieJava$ParExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyResult = pJeannieJava$Statement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyBase   = yyChoice1;
          yyResult = pJavaIdentifier$Word(yyBase);
          if (yyResult.hasValue("else")) {

            yyResult = pJeannieJava$Statement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("ConditionalStatement", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("'else' expected", yyBase);
          }

          // Nested alternative 2.

          yyValue = GNode.create("ConditionalStatement", v$g$1, v$g$2, null);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("for")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pJeannieJava$BasicForControl(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pJeannieJava$Statement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyValue = GNode.create("ForStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 4.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("while")) {

      yyResult = pJeannieJava$ParExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyResult = pJeannieJava$Statement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("WhileStatement", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("do")) {

      yyResult = pJeannieJava$Statement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pJavaIdentifier$Word(yyBase);
        if (yyResult.hasValue("while")) {

          yyResult = pJeannieJava$ParExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(";")) {

              yyValue = GNode.create("DoWhileStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("';' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'while' expected", yyBase);
        }
      }
    }

    // Alternative 6.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("try")) {

      yyResult = pJeannieJava$Block(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyRepetition1 = yyChoice1;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pJeannieJava$CatchClause(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$3.
          final Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pJavaIdentifier$Word(yyBase);
          if (yyResult.hasValue("finally")) {

            yyResult = pJeannieJava$Block(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$4 = yyResult.semanticValue();

              yyValue = GNode.create("TryCatchFinallyStatement", v$g$3.size() + 3).
                add(null).add(v$g$2).addAll(v$g$3).add(v$g$4);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("'finally' expected", yyBase);
          }
        } // End scope for v$g$3.

        // Nested alternative 2.

        yyRepetition1 = yyChoice1;
        yyRepeated1   = false;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pJeannieJava$CatchClause(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepeated1   = true;
            yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
            continue;
          }
          break;
        }

        if (yyRepeated1) {
          final Pair<Node> v$g$5 = yyRepValue1.reverse();

          yyValue = GNode.create("TryCatchFinallyStatement", v$g$5.size() + 3).
            add(null).add(v$g$2).addAll(v$g$5).add(null);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        }
      }
    }

    // Alternative 7.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("switch")) {

      yyResult = pJeannieJava$ParExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("{")) {

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pJeannieJava$SwitchClause(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for v$g$2.
            final Pair<Node> v$g$2 = yyRepValue1.reverse();

            yyBase   = yyRepetition1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue("}")) {

              yyValue = GNode.createFromPair("SwitchStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("'}' expected", yyBase);
            }
          } // End scope for v$g$2.
        } else {
          yyError = yyError.select("'{' expected", yyBase);
        }
      }
    }

    // Alternative 8.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("synchronized")) {

      yyResult = pJeannieJava$ParExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyResult = pJeannieJava$Block(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("SynchronizedStatement", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 9.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("return")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pJeannieJava$Expression(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = cast(yyOpValue1);

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("ReturnStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Alternative 10.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("throw")) {

      yyResult = pJeannieJava$Expression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("ThrowStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Alternative 11.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("break")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pJavaIdentifier$Identifier(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final String v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final String v$g$1 = cast(yyOpValue1);

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("BreakStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Alternative 12.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("continue")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pJavaIdentifier$Identifier(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final String v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final String v$g$1 = cast(yyOpValue1);

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("ContinueStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Alternative 13.

    yyResult = pJavaIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pJeannieJava$Statement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("LabeledStatement", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Alternative 14.

    yyResult = pJeannieJava$Expression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(";")) {

        yyValue = GNode.create("ExpressionStatement", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 15.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("assert")) {

      yyResult = pJeannieJava$Expression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(":")) {

          yyResult = pJeannieJava$Expression(yyResult.index);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
        { // Start scope for v$g$2.
          final Node v$g$2 = cast(yyOpValue1);

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyValue = GNode.create("AssertStatement", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        } // End scope for v$g$2.
      }
    }

    // Alternative 16.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(";")) {

      yyValue = GNode.create("EmptyStatement", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.BasicForControl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$BasicForControl(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declaration>.

    yyResult = pJeannieJava$VariableModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pJeannieJava$Declarators(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pJeannieJava$Expression(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
            { // Start scope for v$g$4.
              final Node v$g$4 = yyOpValue1;

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(";")) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pJeannieJava$ExpressionList(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  final Node v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
                { // Start scope for v$g$5.
                  final Node v$g$5 = yyOpValue1;

                  yyValue = GNode.create("BasicForControl", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);
                  yyValue.setLocation(location(yyStart));

                  return new SemanticValue(yyValue, yyOption1, yyError);
                } // End scope for v$g$5.
              } else {
                yyError = yyError.select("';' expected", yyBase);
              }
            } // End scope for v$g$4.
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      }
    }

    // Alternative <Initialization>.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pJeannieJava$ExpressionList(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$3 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$3;
    }
    { // Start scope for v$g$8.
      final Node v$g$8 = yyOpValue1;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(";")) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pJeannieJava$Expression(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$4 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$4;
        }
        { // Start scope for v$g$9.
          final Node v$g$9 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pJeannieJava$ExpressionList(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$5 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$5;
            }
            { // Start scope for v$g$10.
              final Node v$g$10 = yyOpValue1;

              yyValue = GNode.create("BasicForControl", null, null, v$g$8, v$g$9, v$g$10);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$g$10.
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        } // End scope for v$g$9.
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    } // End scope for v$g$8.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.ParExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$ParExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fJeannieJava$ParExpression) 
      yyColumn.chunk11.fJeannieJava$ParExpression = pJeannieJava$ParExpression$1(yyStart);
    return yyColumn.chunk11.fJeannieJava$ParExpression;
  }

  /** Actually parse xtc.lang.jeannie.JeannieJava.ParExpression. */
  private Result pJeannieJava$ParExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pJeannieJava$Expression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("par expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.TryCatchFinallyStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$TryCatchFinallyStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("try")) {

      yyResult = pJeannieJava$Block(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyRepetition1 = yyChoice1;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pJeannieJava$CatchClause(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$3.
          final Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pJavaIdentifier$Word(yyBase);
          if (yyResult.hasValue("finally")) {

            yyResult = pJeannieJava$Block(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$4 = yyResult.semanticValue();

              yyValue = GNode.create("TryCatchFinallyStatement", v$g$3.size() + 3).
                add(null).add(v$g$2).addAll(v$g$3).add(v$g$4);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("'finally' expected", yyBase);
          }
        } // End scope for v$g$3.

        // Nested alternative 2.

        yyRepetition1 = yyChoice1;
        yyRepeated1   = false;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pJeannieJava$CatchClause(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepeated1   = true;
            yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
            continue;
          }
          break;
        }

        if (yyRepeated1) {
          final Pair<Node> v$g$5 = yyRepValue1.reverse();

          yyValue = GNode.create("TryCatchFinallyStatement", v$g$5.size() + 3).
            add(null).add(v$g$2).addAll(v$g$5).add(null);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("try catch finally statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.CatchClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$CatchClause(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fJeannieJava$CatchClause) 
      yyColumn.chunk11.fJeannieJava$CatchClause = pJeannieJava$CatchClause$1(yyStart);
    return yyColumn.chunk11.fJeannieJava$CatchClause;
  }

  /** Actually parse xtc.lang.jeannie.JeannieJava.CatchClause. */
  private Result pJeannieJava$CatchClause$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Catch>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("catch")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pJeannieJava$FormalParameter(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pJeannieJava$Block(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyValue = GNode.create("CatchClause", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("catch clause expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.SwitchClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$SwitchClause(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("case")) {

      yyResult = pJeannieJava$Expression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(":")) {

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pJeannieJava$DeclarationOrStatement(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for v$g$2.
            final Pair<Node> v$g$2 = yyRepValue1.reverse();

            yyValue = GNode.createFromPair("CaseClause", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for v$g$2.
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("default")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pJeannieJava$DeclarationOrStatement(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$1.
          final Pair<Node> v$g$1 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("DefaultClause", v$g$1);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$1.
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("switch clause expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.SynchronizedStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$SynchronizedStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("synchronized")) {

      yyResult = pJeannieJava$ParExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyResult = pJeannieJava$Block(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("SynchronizedStatement", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("synchronized statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.ThrowStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$ThrowStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("throw")) {

      yyResult = pJeannieJava$Expression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("ThrowStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("throw statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.ExpressionList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$ExpressionList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieJava$Expression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pJeannieJava$Expression(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("ExpressionList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.Expression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$Expression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fJeannieJava$Expression) 
      yyColumn.chunk11.fJeannieJava$Expression = pJeannieJava$Expression$1(yyStart);
    return yyColumn.chunk11.fJeannieJava$Expression;
  }

  /** Actually parse xtc.lang.jeannie.JeannieJava.Expression. */
  private Result pJeannieJava$Expression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Assignment>.

    yyResult = pJeannieJava$ConditionalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = p$$Shared21(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$2 = yyResult.semanticValue();

        yyResult = pJeannieJava$Expression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("Expression", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pJeannieJava$ConditionalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared21.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieJava.AssignmentOperator 
   * and xtc.lang.blink.CommandJava.AssignmentOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared21(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.f$$Shared21) 
      yyColumn.chunk11.f$$Shared21 = p$$Shared21$1(yyStart);
    return yyColumn.chunk11.f$$Shared21;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared21. */
  private Result p$$Shared21$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Equal>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("=")) {
      yyValue = "=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <PlusEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("+=")) {
      yyValue = "+=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <MinusEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("-=")) {
      yyValue = "-=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <StarEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("*=")) {
      yyValue = "*=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <SlashEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("/=")) {
      yyValue = "/=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <AmpersandEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&=")) {
      yyValue = "&=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <BarEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("|=")) {
      yyValue = "|=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <CaretEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("^=")) {
      yyValue = "^=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <PercentEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("%=")) {
      yyValue = "%=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <DoubleLessEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<<=")) {
      yyValue = "<<=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <DoubleGreaterEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">>=")) {
      yyValue = ">>=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <TripleGreaterEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">>>=")) {
      yyValue = ">>>=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.ConditionalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$ConditionalExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fJeannieJava$ConditionalExpression) 
      yyColumn.chunk11.fJeannieJava$ConditionalExpression = pJeannieJava$ConditionalExpression$1(yyStart);
    return yyColumn.chunk11.fJeannieJava$ConditionalExpression;
  }

  /** Actually parse xtc.lang.jeannie.JeannieJava.ConditionalExpression. */
  private Result pJeannieJava$ConditionalExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Conditional>.

    yyResult = pJeannieJava$LogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("?")) {

        yyResult = pJeannieJava$Expression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(":")) {

            yyResult = pJeannieJava$ConditionalExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("ConditionalExpression", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'?' expected", yyBase);
      }
    }

    // Alternative <Base>.

    yyResult = pJeannieJava$LogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.LogicalOrExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$LogicalOrExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk11) yyColumn.chunk11 = new Chunk11();
    if (null == yyColumn.chunk11.fJeannieJava$LogicalOrExpression) 
      yyColumn.chunk11.fJeannieJava$LogicalOrExpression = pJeannieJava$LogicalOrExpression$1(yyStart);
    return yyColumn.chunk11.fJeannieJava$LogicalOrExpression;
  }

  /** Actually parse xtc.lang.jeannie.JeannieJava.LogicalOrExpression. */
  private Result pJeannieJava$LogicalOrExpression$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieJava$LogicalAndExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieJava$LogicalOrExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieJava.LogicalOrExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$LogicalOrExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Or>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("||")) {

      yyResult = pJeannieJava$LogicalAndExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalOrExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical or expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.LogicalAndExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$LogicalAndExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieJava$BitwiseOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieJava$LogicalAndExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieJava.LogicalAndExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$LogicalAndExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <And>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&&")) {

      yyResult = pJeannieJava$BitwiseOrExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalAndExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical and expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.BitwiseOrExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$BitwiseOrExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieJava$BitwiseXorExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieJava$BitwiseOrExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieJava.BitwiseOrExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$BitwiseOrExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Or>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("|")) {

      yyResult = pJeannieJava$BitwiseXorExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseOrExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise or expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.BitwiseXorExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$BitwiseXorExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieJava$BitwiseAndExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieJava$BitwiseXorExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieJava.BitwiseXorExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$BitwiseXorExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Xor>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("^")) {

      yyResult = pJeannieJava$BitwiseAndExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseXorExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise xor expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.BitwiseAndExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$BitwiseAndExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieJava$EqualityExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieJava$BitwiseAndExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieJava.BitwiseAndExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$BitwiseAndExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <And>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&")) {

      yyResult = pJeannieJava$EqualityExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseAndExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise and expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.EqualityExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$EqualityExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieJava$InstanceOfExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieJava$EqualityExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieJava.EqualityExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$EqualityExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared12(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pJeannieJava$InstanceOfExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("EqualityExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.InstanceOfExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$InstanceOfExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Instanceof>.

    yyResult = pJeannieJava$RelationalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("instanceof")) {

        yyResult = pType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("InstanceOfExpression", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'instanceof' expected", yyBase);
      }
    }

    // Alternative <Base>.

    yyResult = pJeannieJava$RelationalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.RelationalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$RelationalExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fJeannieJava$RelationalExpression) 
      yyColumn.chunk12.fJeannieJava$RelationalExpression = pJeannieJava$RelationalExpression$1(yyStart);
    return yyColumn.chunk12.fJeannieJava$RelationalExpression;
  }

  /** Actually parse xtc.lang.jeannie.JeannieJava.RelationalExpression. */
  private Result pJeannieJava$RelationalExpression$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieJava$ShiftExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieJava$RelationalExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieJava.RelationalExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$RelationalExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared22(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pJeannieJava$ShiftExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("RelationalExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared22.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieJava.RelationalOperator 
   * and xtc.lang.blink.CommandJava.RelationalOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared22(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.f$$Shared22) 
      yyColumn.chunk12.f$$Shared22 = p$$Shared22$1(yyStart);
    return yyColumn.chunk12.f$$Shared22;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared22. */
  private Result p$$Shared22$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Less>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<")) {
      yyValue = "<";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Greater>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">")) {
      yyValue = ">";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <LessEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<=")) {
      yyValue = "<=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <GreaterEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">=")) {
      yyValue = ">=";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.ShiftExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$ShiftExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieJava$AdditiveExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieJava$ShiftExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieJava.ShiftExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$ShiftExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared23(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pJeannieJava$AdditiveExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("ShiftExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared23.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieJava.ShiftOperator 
   * and xtc.lang.blink.CommandJava.ShiftOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared23(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.f$$Shared23) 
      yyColumn.chunk12.f$$Shared23 = p$$Shared23$1(yyStart);
    return yyColumn.chunk12.f$$Shared23;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared23. */
  private Result p$$Shared23$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Left>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("<<")) {
      yyValue = "<<";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Right>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">>")) {
      yyValue = ">>";

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <UnsignedRight>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(">>>")) {
      yyValue = ">>>";

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.AdditiveExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$AdditiveExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieJava$MultiplicativeExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieJava$AdditiveExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieJava.AdditiveExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$AdditiveExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared15(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pJeannieJava$MultiplicativeExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("AdditiveExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.MultiplicativeExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$MultiplicativeExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieJava$UnaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = 
          pJeannieJava$MultiplicativeExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieJava.MultiplicativeExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$MultiplicativeExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Times>.

    yyResult = p$$Shared16(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pJeannieJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("MultiplicativeExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.UnaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$UnaryExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Plus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("+")) {
      final String v$g$1 = "+";

      yyResult = pJeannieJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryExpression", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Minus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("-")) {
      final String v$g$3 = "-";

      yyResult = pJeannieJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryExpression", v$g$3, v$g$4);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Increment>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("++")) {
      final String v$g$5 = "++";

      yyResult = pJeannieJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$6 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryExpression", v$g$5, v$g$6);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Decrement>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("--")) {
      final String v$g$7 = "--";

      yyResult = pJeannieJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$8 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryExpression", v$g$7, v$g$8);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Base>.

    yyResult = pJeannieJava$UnaryExpressionNotPlusMinus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("unary expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal 
   * xtc.lang.jeannie.JeannieJava.UnaryExpressionNotPlusMinus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$UnaryExpressionNotPlusMinus(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("~")) {

      yyResult = pJeannieJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("BitwiseNegationExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <CInJavaExpression>.

    yyResult = pJeannieJava$CInJavaExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("!")) {

      yyResult = pJeannieJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("LogicalNegationExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pPrimitiveType(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pDimensions(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$2.
          final Node v$g$2 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pJeannieJava$UnaryExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("BasicCastExpression", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$g$2.
      }

      // Nested alternative 2.

      yyResult = pType(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyResult = pJeannieJava$UnaryExpressionNotPlusMinus(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("CastExpression", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pJeannieJava$PostfixExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("unary expression not plus minus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.PostfixExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$PostfixExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pJeannieJava$PrimaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$15 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pJeannieJava$PostfixExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$16 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$16, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$17.
        final Pair<Action<Node>> v$17 = yyRepValue1.reverse();

        yyValue = apply(v$17, v$g$15, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$17.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieJava.PostfixExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$PostfixExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyOption1;
    Node         yyOpValue1;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(".")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.
      { // Start scope for nested choice.

        final int yyChoice2 = yyChoice1;

        // Nested alternative 1.

        yyResult = pJavaIdentifier$Identifier(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$3 = yyResult.semanticValue();

          yyResult = pJeannieJava$Arguments(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$4 = yyResult.semanticValue();

            yyValue = new Action<Node>() {
              public Node run(Node v$1) {
                return GNode.create("CallExpression", v$1, null, v$g$3, v$g$4);
              }};

            return yyResult.createValue(yyValue, yyError);
          }
        }

        // Nested alternative 2.

        yyBase   = yyChoice2;
        yyResult = pJavaIdentifier$Word(yyBase);
        if (yyResult.hasValue("super")) {
          final String v$g$5 = "super";

          yyResult = pJeannieJava$Arguments(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$6 = yyResult.semanticValue();

            yyValue = new Action<Node>() {
              public Node run(Node v$1) {
                return GNode.create("CallExpression", v$1, null, v$g$5, v$g$6);
              }};

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'super' expected", yyBase);
        }
      } // End scope for nested choice.

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("super")) {

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("SuperExpression", v$1);
          }};

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'super' expected", yyBase);
      }

      // Nested alternative 3.

      yyResult = pJavaIdentifier$Identifier(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$7 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("SelectionExpression", v$1, v$g$7);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {

      yyResult = pJeannieJava$Expression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$8 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("SubscriptExpression", v$1, v$g$8);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("++")) {
      final String v$g$9 = "++";

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          return GNode.create("PostfixExpression", v$1, v$g$9);
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("--")) {
      final String v$g$10 = "--";

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          return GNode.create("PostfixExpression", v$1, v$g$10);
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(".")) {

      yyBase   = yyResult.index;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("new")) {

        yyResult = pJavaType$TypeName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$12 = yyResult.semanticValue();

          yyResult = pJeannieJava$Arguments(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$13 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pJeannieJava$ClassBody(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
            { // Start scope for v$g$14.
              final Node v$g$14 = yyOpValue1;

              yyValue = new Action<Node>() {
                public Node run(Node v$1) {
                  return GNode.create("NewClassExpression", v$1, null, v$g$12, v$g$13, v$g$14);
                }};

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$g$14.
          }
        }
      } else {
        yyError = yyError.select("'new' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("postfix expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.PrimaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$PrimaryExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Literal>.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Expression>.

    yyResult = pJavaIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$3 = yyResult.semanticValue();

      yyResult = pJeannieJava$Arguments(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        yyValue = GNode.create("CallExpression", null, null, v$g$3, v$g$4);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Expression>.

    yyResult = pResultType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(".")) {

        yyBase   = yyResult.index;
        yyResult = pJavaIdentifier$Word(yyBase);
        if (yyResult.hasValue("class")) {

          yyValue = GNode.create("ClassLiteralExpression", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'class' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'.' expected", yyBase);
      }
    }

    // Alternative <Expression>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("this")) {
      final String v$g$3 = "this";

      yyResult = pJeannieJava$Arguments(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        yyValue = GNode.create("CallExpression", null, null, v$g$3, v$g$4);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Expression>.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pQualifiedIdentifier(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(".")) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      } else {
        yyError = yyError.select("'.' expected", yyBase);
      }
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyBase   = yyOption1;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("this")) {

        yyValue = GNode.create("ThisExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'this' expected", yyBase);
      }
    } // End scope for v$g$1.

    // Alternative 6.
    { // Start scope for nested choice.

      final int yyChoice1 = yyStart;

      // Nested alternative 1.

      yyResult = pJavaIdentifier$Word(yyChoice1);
      if (yyResult.hasValue("super")) {
        final String v$g$3 = "super";

        yyResult = pJeannieJava$Arguments(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$4 = yyResult.semanticValue();

          yyValue = GNode.create("CallExpression", null, null, v$g$3, v$g$4);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("super")) {

        yyValue = GNode.create("SuperExpression", null);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'super' expected", yyBase);
      }
    } // End scope for nested choice.

    // Alternative 7.

    yyResult = pJavaIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("PrimaryIdentifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Expression>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("new")) {

      yyResult = pJavaType$TypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyResult = pJeannieJava$Arguments(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$4 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pJeannieJava$ClassBody(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$5.
            final Node v$g$5 = yyOpValue1;

            yyValue = GNode.create("NewClassExpression", null, null, v$g$3, v$g$4, v$g$5);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for v$g$5.
        }
      }
    }

    // Alternative 9.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("new")) {

      yyResult = pJavaType$TypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pJeannieJava$ConcreteDimensions(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pDimensions(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$3.
            final Node v$g$3 = yyOpValue1;

            yyValue = GNode.create("NewArrayExpression", v$g$1, v$g$2, v$g$3, null);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for v$g$3.
        }

        // Nested alternative 2.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pDimensions(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$6.
          final Node v$g$6 = yyOpValue1;

          yyResult = pJeannieJava$ArrayInitializer(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$7 = yyResult.semanticValue();

            yyValue = GNode.create("NewArrayExpression", v$g$1, null, v$g$6, v$g$7);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } // End scope for v$g$6.
      }
    }

    // Alternative <Nested>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pJeannieJava$Expression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("primary expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.ConcreteDimensions.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$ConcreteDimensions(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pJeannieJava$ConcreteDimension(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("ConcreteDimensions", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.ConcreteDimension.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$ConcreteDimension(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {

      yyResult = pJeannieJava$Expression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("concrete dimension expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.ArrayInitializer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$ArrayInitializer(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pJeannieJava$VariableInitializer(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pJeannieJava$VariableInitializer(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyOption1  = yyRepetition1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyOption1  = yyResult.index;
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("}")) {

            yyValue = GNode.createFromPair("ArrayInitializer", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("'}' expected", yyBase);
          }
        } // End scope for v$g$2.
      }

      // Nested alternative 2.

      yyOption1  = yyChoice1;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(",")) {

        yyOption1  = yyResult.index;
      } else {
        yyError = yyError.select("',' expected", yyBase);
      }

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("}")) {

        yyValue = GNode.create("ArrayInitializer", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'}' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("array initializer expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.VariableInitializer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$VariableInitializer(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fJeannieJava$VariableInitializer) 
      yyColumn.chunk12.fJeannieJava$VariableInitializer = pJeannieJava$VariableInitializer$1(yyStart);
    return yyColumn.chunk12.fJeannieJava$VariableInitializer;
  }

  /** Actually parse xtc.lang.jeannie.JeannieJava.VariableInitializer. */
  private Result pJeannieJava$VariableInitializer$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Array>.

    yyResult = pJeannieJava$ArrayInitializer(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Expression>.

    yyResult = pJeannieJava$Expression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.Arguments.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$Arguments(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pJeannieJava$Expression(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pJeannieJava$Expression(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.createFromPair("Arguments", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$g$2.
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(")")) {

        yyValue = GNode.create("Arguments", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("')' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("arguments expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.blink.Command.$$Shared26.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.jeannie.JeannieJava.CInJava 
   * and xtc.lang.blink.CommandJava.CInJava.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared26(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.f$$Shared26) 
      yyColumn.chunk12.f$$Shared26 = p$$Shared26$1(yyStart);
    return yyColumn.chunk12.f$$Shared26;
  }

  /** Actually parse xtc.lang.blink.Command.$$Shared26. */
  private Result p$$Shared26$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("`")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(".")) {

        yyBase = yyResult.index;
        yyC    = character(yyBase);
        if ('C' == yyC) {
          yyIndex = yyResult.index + 1;

          yyResult = pSpacing(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'C' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'.' expected", yyBase);
      }

      // Nested alternative 2.

      yyValue = null;

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.JavaInJavaBlock.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$JavaInJavaBlock(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fJeannieJava$JavaInJavaBlock) 
      yyColumn.chunk12.fJeannieJava$JavaInJavaBlock = pJeannieJava$JavaInJavaBlock$1(yyStart);
    return yyColumn.chunk12.fJeannieJava$JavaInJavaBlock;
  }

  /** Actually parse xtc.lang.jeannie.JeannieJava.JavaInJavaBlock. */
  private Result pJeannieJava$JavaInJavaBlock$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyResult = pJeannieJava$JavaInJavaBlock$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("}")) {

          yyValue = GNode.createFromPair("JavaInJavaBlock", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("java in java block expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal JeannieJava.JavaInJavaBlock$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$JavaInJavaBlock$$Star1(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fJeannieJava$JavaInJavaBlock$$Star1) 
      yyColumn.chunk12.fJeannieJava$JavaInJavaBlock$$Star1 = pJeannieJava$JavaInJavaBlock$$Star1$1(yyStart);
    return yyColumn.chunk12.fJeannieJava$JavaInJavaBlock$$Star1;
  }

  /** Actually parse JeannieJava.JavaInJavaBlock$$Star1. */
  private Result pJeannieJava$JavaInJavaBlock$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJeannieJava$DeclarationOrStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyResult = pJeannieJava$JavaInJavaBlock$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.CInJavaBlock.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$CInJavaBlock(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared26(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pJeannieC$CInCBlock(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("CInJavaBlock", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.jeannie.JeannieJava.CInJavaExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pJeannieJava$CInJavaExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared26(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pJeannieC$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("CInJavaExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.Modifiers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$Modifiers(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fCommandJava$Modifiers) 
      yyColumn.chunk12.fCommandJava$Modifiers = pCommandJava$Modifiers$1(yyStart);
    return yyColumn.chunk12.fCommandJava$Modifiers;
  }

  /** Actually parse xtc.lang.blink.CommandJava.Modifiers. */
  private Result pCommandJava$Modifiers$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandJava$ModifierList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("Modifiers", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.ModifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$ModifierList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pCommandJava$Modifier(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for yyValue.
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for yyValue.
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.Modifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$Modifier(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Public>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("public")) {
      final String v$g$1 = "public";

      yyValue = GNode.create("Modifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Protected>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("protected")) {
      final String v$g$2 = "protected";

      yyValue = GNode.create("Modifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Private>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("private")) {
      final String v$g$3 = "private";

      yyValue = GNode.create("Modifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Static>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("static")) {
      final String v$g$4 = "static";

      yyValue = GNode.create("Modifier", v$g$4);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Abstract>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("abstract")) {
      final String v$g$5 = "abstract";

      yyValue = GNode.create("Modifier", v$g$5);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Final>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("final")) {
      final String v$g$6 = "final";

      yyValue = GNode.create("Modifier", v$g$6);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Native>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("native")) {
      final String v$g$7 = "native";

      yyValue = GNode.create("Modifier", v$g$7);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Synchronized>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("synchronized")) {
      final String v$g$8 = "synchronized";

      yyValue = GNode.create("Modifier", v$g$8);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Transient>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("transient")) {
      final String v$g$9 = "transient";

      yyValue = GNode.create("Modifier", v$g$9);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Volatile>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("volatile")) {
      final String v$g$10 = "volatile";

      yyValue = GNode.create("Modifier", v$g$10);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Strictfp>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("strictfp")) {
      final String v$g$11 = "strictfp";

      yyValue = GNode.create("Modifier", v$g$11);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("modifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.FormalParameter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$FormalParameter(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Parameter>.

    yyResult = pCommandJava$VariableModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pJavaIdentifier$Identifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$4 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pDimensions(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$5.
            final Node v$g$5 = yyOpValue1;

            yyValue = GNode.create("FormalParameter", v$g$1, v$g$2, null, v$g$4, v$g$5);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for v$g$5.
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.VariableModifiers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$VariableModifiers(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Final>.

    yyResult = pCommandJava$FinalModifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Modifiers", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Nonfinal>.

    yyValue = GNode.create("Modifiers", false);
    yyValue.setLocation(location(yyStart));

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.FinalModifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$FinalModifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("final")) {
      final String v$g$1 = "final";

      yyValue = GNode.create("Modifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("final modifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.FormalParameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$FormalParameters(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fCommandJava$FormalParameters) 
      yyColumn.chunk12.fCommandJava$FormalParameters = pCommandJava$FormalParameters$1(yyStart);
    return yyColumn.chunk12.fCommandJava$FormalParameters;
  }

  /** Actually parse xtc.lang.blink.CommandJava.FormalParameters. */
  private Result pCommandJava$FormalParameters$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pCommandJava$FormalParameter(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyResult = pCommandJava$FormalParameters$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.createFromPair("FormalParameters", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(")")) {

        yyValue = GNode.create("FormalParameters", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("')' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("formal parameters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandJava.FormalParameters$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$FormalParameters$$Star1(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk12) yyColumn.chunk12 = new Chunk12();
    if (null == yyColumn.chunk12.fCommandJava$FormalParameters$$Star1) 
      yyColumn.chunk12.fCommandJava$FormalParameters$$Star1 = pCommandJava$FormalParameters$$Star1$1(yyStart);
    return yyColumn.chunk12.fCommandJava$FormalParameters$$Star1;
  }

  /** Actually parse CommandJava.FormalParameters$$Star1. */
  private Result pCommandJava$FormalParameters$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pCommandJava$FormalParameter(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyResult = pCommandJava$FormalParameters$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.Declarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$Declarator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declarator>.

    yyResult = pJavaIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pDimensions(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyOpValue1 = null;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("=")) {

          yyResult = pCommandJava$VariableInitializer(yyResult.index);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        } else {
          yyError = yyError.select("'=' expected", yyBase);
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyValue = GNode.create("Declarator", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$3.
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.Declarators.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$Declarators(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fCommandJava$Declarators) 
      yyColumn.chunk13.fCommandJava$Declarators = pCommandJava$Declarators$1(yyStart);
    return yyColumn.chunk13.fCommandJava$Declarators;
  }

  /** Actually parse xtc.lang.blink.CommandJava.Declarators. */
  private Result pCommandJava$Declarators$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandJava$Declarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pCommandJava$Declarators$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("Declarators", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandJava.Declarators$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$Declarators$$Star1(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fCommandJava$Declarators$$Star1) 
      yyColumn.chunk13.fCommandJava$Declarators$$Star1 = pCommandJava$Declarators$$Star1$1(yyStart);
    return yyColumn.chunk13.fCommandJava$Declarators$$Star1;
  }

  /** Actually parse CommandJava.Declarators$$Star1. */
  private Result pCommandJava$Declarators$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pCommandJava$Declarator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyResult = pCommandJava$Declarators$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.ClassBody.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$ClassBody(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Body>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandJava$Declaration(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$g$1.
        final Pair<Node> v$g$1 = yyRepValue1.reverse();

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("}")) {

          yyValue = GNode.createFromPair("ClassBody", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("class body expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.Declaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$Declaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandJava$Modifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pType(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pCommandJava$Declarators(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyValue = GNode.create("FieldDeclaration", v$g$1, v$g$2, v$g$3);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      }

      // Nested alternative 2.
      { // Start scope for nested choice.

        final int yyChoice2 = yyChoice1;

        // Nested alternative 1.

        yyResult = pResultType(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyResult = pJavaIdentifier$Identifier(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final String v$g$4 = yyResult.semanticValue();

            yyResult = pCommandJava$FormalParameters(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$5 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pDimensions(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                final Node v$el$1 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$1;
              }
              { // Start scope for v$g$6.
                final Node v$g$6 = cast(yyOpValue1);

                yyOpValue1 = null;

                yyResult = pCommandJava$ThrowsClause(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  final Node v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
                { // Start scope for v$g$7.
                  final Node v$g$7 = cast(yyOpValue1);

                  final int yyChoice3 = yyOption1;

                  // Nested alternative 1.

                  yyResult = pCommandJava$Block(yyChoice3);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    final Node v$g$8 = yyResult.semanticValue();

                    yyValue = GNode.create("MethodDeclaration", v$g$1, null, v$g$3, v$g$4, v$g$5, v$g$6, v$g$7, v$g$8);
                    yyValue.setLocation(location(yyStart));

                    return yyResult.createValue(yyValue, yyError);
                  }

                  // Nested alternative 2.

                  yyBase   = yyChoice3;
                  yyResult = pSymbol(yyBase);
                  if (yyResult.hasValue(";")) {

                    yyValue = GNode.create("MethodDeclaration", v$g$1, null, v$g$3, v$g$4, v$g$5, v$g$6, v$g$7, null);
                    yyValue.setLocation(location(yyStart));

                    return yyResult.createValue(yyValue, yyError);
                  } else {
                    yyError = yyError.select("';' expected", yyBase);
                  }
                } // End scope for v$g$7.
              } // End scope for v$g$6.
            }
          }
        }

        // Nested alternative 2.

        yyResult = pJavaIdentifier$Identifier(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$3 = yyResult.semanticValue();

          yyResult = pCommandJava$FormalParameters(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$4 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pCommandJava$ThrowsClause(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
            { // Start scope for v$g$5.
              final Node v$g$5 = cast(yyOpValue1);

              yyResult = pCommandJava$Block(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$6 = yyResult.semanticValue();

                yyValue = GNode.create("ConstructorDeclaration", v$g$1, null, v$g$3, v$g$4, v$g$5, v$g$6);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            } // End scope for v$g$5.
          }
        }
      } // End scope for nested choice.

      // Nested alternative 3.

      yyBase   = yyChoice1;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("class")) {

        yyResult = pJavaIdentifier$Identifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pCommandJava$Extension(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$4.
            final Node v$g$4 = cast(yyOpValue1);

            yyOpValue1 = null;

            yyResult = pCommandJava$Implementation(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$5.
              final Node v$g$5 = cast(yyOpValue1);

              yyResult = pCommandJava$ClassBody(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$6 = yyResult.semanticValue();

                yyValue = GNode.create("ClassDeclaration", v$g$1, v$g$2, null, v$g$4, v$g$5, v$g$6);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            } // End scope for v$g$5.
          } // End scope for v$g$4.
        }
      } else {
        yyError = yyError.select("'class' expected", yyBase);
      }

      // Nested alternative 4.

      yyBase   = yyChoice1;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("interface")) {

        yyResult = pJavaIdentifier$Identifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pCommandJava$Extension(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$4.
            final Node v$g$4 = cast(yyOpValue1);

            yyResult = pCommandJava$ClassBody(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$5 = yyResult.semanticValue();

              yyValue = GNode.create("InterfaceDeclaration", v$g$1, v$g$2, null, v$g$4, v$g$5);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } // End scope for v$g$4.
        }
      } else {
        yyError = yyError.select("'interface' expected", yyBase);
      }
    }

    // Alternative 2.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pJavaIdentifier$Word(yyBase);
    if (yyResult.hasValue("static")) {
      final String v$el$1 = "static";

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    } else {
      yyError = yyError.select("'static' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final String v$g$1 = cast(yyOpValue1);

      yyResult = pCommandJava$Block(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("BlockDeclaration", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for v$g$1.

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(";")) {

      yyValue = GNode.create("EmptyDeclaration", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.ThrowsClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$ThrowsClause(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("throws")) {

      yyResult = pQualifiedIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pQualifiedIdentifier(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("ThrowsClause", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("throws clause expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.Extension.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$Extension(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("extends")) {

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pType(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("Extension", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("extension expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.Implementation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$Implementation(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("implements")) {

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pType(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("Implementation", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("implementation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.Block.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$Block(final int yyStart) throws IOException {
    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fCommandJava$Block) 
      yyColumn.chunk13.fCommandJava$Block = pCommandJava$Block$1(yyStart);
    return yyColumn.chunk13.fCommandJava$Block;
  }

  /** Actually parse xtc.lang.blink.CommandJava.Block. */
  private Result pCommandJava$Block$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <JavaBlock>.

    yyResult = pCommandJava$JavaInJavaBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <CBlock>.

    yyResult = pCommandJava$CInJavaBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.DeclarationOrStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$DeclarationOrStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declaration>.

    yyResult = pCommandJava$InBlockDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Statement>.

    yyResult = pCommandJava$Statement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.InBlockDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$InBlockDeclaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Variable>.

    yyResult = pCommandJava$VariableDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pCommandJava$Modifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("class")) {

        yyResult = pJavaIdentifier$Identifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pCommandJava$Extension(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$4.
            final Node v$g$4 = yyOpValue1;

            yyOpValue1 = null;

            yyResult = pCommandJava$Implementation(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$5.
              final Node v$g$5 = yyOpValue1;

              yyResult = pCommandJava$ClassBody(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$6 = yyResult.semanticValue();

                yyValue = GNode.create("ClassDeclaration", v$g$1, v$g$2, null, v$g$4, v$g$5, v$g$6);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            } // End scope for v$g$5.
          } // End scope for v$g$4.
        }
      } else {
        yyError = yyError.select("'class' expected", yyBase);
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("interface")) {

        yyResult = pJavaIdentifier$Identifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pCommandJava$Extension(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$4.
            final Node v$g$4 = yyOpValue1;

            yyResult = pCommandJava$ClassBody(yyOption1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$5 = yyResult.semanticValue();

              yyValue = GNode.create("InterfaceDeclaration", v$g$1, v$g$2, null, v$g$4, v$g$5);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } // End scope for v$g$4.
        }
      } else {
        yyError = yyError.select("'interface' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.VariableDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$VariableDeclaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declaration>.

    yyResult = pCommandJava$VariableModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pCommandJava$Declarators(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyValue = GNode.create("FieldDeclaration", v$g$1, v$g$2, v$g$3);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$Statement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Object     yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Block>.

    yyResult = pCommandJava$Block(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("if")) {

      yyResult = pCommandJava$ParExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyResult = pCommandJava$Statement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyBase   = yyChoice1;
          yyResult = pJavaIdentifier$Word(yyBase);
          if (yyResult.hasValue("else")) {

            yyResult = pCommandJava$Statement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("ConditionalStatement", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("'else' expected", yyBase);
          }

          // Nested alternative 2.

          yyValue = GNode.create("ConditionalStatement", v$g$1, v$g$2, null);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("for")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pCommandJava$BasicForControl(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pCommandJava$Statement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyValue = GNode.create("ForStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 4.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("while")) {

      yyResult = pCommandJava$ParExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyResult = pCommandJava$Statement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("WhileStatement", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("do")) {

      yyResult = pCommandJava$Statement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pJavaIdentifier$Word(yyBase);
        if (yyResult.hasValue("while")) {

          yyResult = pCommandJava$ParExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue(";")) {

              yyValue = GNode.create("DoWhileStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("';' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'while' expected", yyBase);
        }
      }
    }

    // Alternative 6.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("try")) {

      yyResult = pCommandJava$Block(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyRepetition1 = yyChoice1;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pCommandJava$CatchClause(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$3.
          final Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pJavaIdentifier$Word(yyBase);
          if (yyResult.hasValue("finally")) {

            yyResult = pCommandJava$Block(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$4 = yyResult.semanticValue();

              yyValue = GNode.create("TryCatchFinallyStatement", v$g$3.size() + 3).
                add(null).add(v$g$2).addAll(v$g$3).add(v$g$4);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("'finally' expected", yyBase);
          }
        } // End scope for v$g$3.

        // Nested alternative 2.

        yyRepetition1 = yyChoice1;
        yyRepeated1   = false;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pCommandJava$CatchClause(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepeated1   = true;
            yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
            continue;
          }
          break;
        }

        if (yyRepeated1) {
          final Pair<Node> v$g$5 = yyRepValue1.reverse();

          yyValue = GNode.create("TryCatchFinallyStatement", v$g$5.size() + 3).
            add(null).add(v$g$2).addAll(v$g$5).add(null);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        }
      }
    }

    // Alternative 7.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("switch")) {

      yyResult = pCommandJava$ParExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("{")) {

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pCommandJava$SwitchClause(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for v$g$2.
            final Pair<Node> v$g$2 = yyRepValue1.reverse();

            yyBase   = yyRepetition1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue("}")) {

              yyValue = GNode.createFromPair("SwitchStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("'}' expected", yyBase);
            }
          } // End scope for v$g$2.
        } else {
          yyError = yyError.select("'{' expected", yyBase);
        }
      }
    }

    // Alternative 8.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("synchronized")) {

      yyResult = pCommandJava$ParExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyResult = pCommandJava$Block(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("SynchronizedStatement", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 9.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("return")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pCommandJava$Expression(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = cast(yyOpValue1);

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("ReturnStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Alternative 10.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("throw")) {

      yyResult = pCommandJava$Expression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("ThrowStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Alternative 11.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("break")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pJavaIdentifier$Identifier(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final String v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final String v$g$1 = cast(yyOpValue1);

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("BreakStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Alternative 12.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("continue")) {

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pJavaIdentifier$Identifier(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final String v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$1.
        final String v$g$1 = cast(yyOpValue1);

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(";")) {

          yyValue = GNode.create("ContinueStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Alternative 13.

    yyResult = pJavaIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pCommandJava$Statement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("LabeledStatement", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Alternative 14.

    yyResult = pCommandJava$Expression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(";")) {

        yyValue = GNode.create("ExpressionStatement", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 15.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("assert")) {

      yyResult = pCommandJava$Expression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(":")) {

          yyResult = pCommandJava$Expression(yyResult.index);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
        { // Start scope for v$g$2.
          final Node v$g$2 = cast(yyOpValue1);

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyValue = GNode.create("AssertStatement", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        } // End scope for v$g$2.
      }
    }

    // Alternative 16.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(";")) {

      yyValue = GNode.create("EmptyStatement", false);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.BasicForControl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$BasicForControl(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declaration>.

    yyResult = pCommandJava$VariableModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pCommandJava$Declarators(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pCommandJava$Expression(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
            { // Start scope for v$g$4.
              final Node v$g$4 = yyOpValue1;

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue(";")) {

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pCommandJava$ExpressionList(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  final Node v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
                { // Start scope for v$g$5.
                  final Node v$g$5 = yyOpValue1;

                  yyValue = GNode.create("BasicForControl", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);
                  yyValue.setLocation(location(yyStart));

                  return new SemanticValue(yyValue, yyOption1, yyError);
                } // End scope for v$g$5.
              } else {
                yyError = yyError.select("';' expected", yyBase);
              }
            } // End scope for v$g$4.
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      }
    }

    // Alternative <Initialization>.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pCommandJava$ExpressionList(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$3 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$3;
    }
    { // Start scope for v$g$8.
      final Node v$g$8 = yyOpValue1;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(";")) {

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pCommandJava$Expression(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$4 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$4;
        }
        { // Start scope for v$g$9.
          final Node v$g$9 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(";")) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pCommandJava$ExpressionList(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$5 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$5;
            }
            { // Start scope for v$g$10.
              final Node v$g$10 = yyOpValue1;

              yyValue = GNode.create("BasicForControl", null, null, v$g$8, v$g$9, v$g$10);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$g$10.
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        } // End scope for v$g$9.
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    } // End scope for v$g$8.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.ParExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$ParExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fCommandJava$ParExpression) 
      yyColumn.chunk13.fCommandJava$ParExpression = pCommandJava$ParExpression$1(yyStart);
    return yyColumn.chunk13.fCommandJava$ParExpression;
  }

  /** Actually parse xtc.lang.blink.CommandJava.ParExpression. */
  private Result pCommandJava$ParExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pCommandJava$Expression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("par expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.CatchClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$CatchClause(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fCommandJava$CatchClause) 
      yyColumn.chunk13.fCommandJava$CatchClause = pCommandJava$CatchClause$1(yyStart);
    return yyColumn.chunk13.fCommandJava$CatchClause;
  }

  /** Actually parse xtc.lang.blink.CommandJava.CatchClause. */
  private Result pCommandJava$CatchClause$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Catch>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("catch")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pCommandJava$FormalParameter(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pCommandJava$Block(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyValue = GNode.create("CatchClause", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("catch clause expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.SwitchClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$SwitchClause(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("case")) {

      yyResult = pCommandJava$Expression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(":")) {

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pCommandJava$DeclarationOrStatement(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for v$g$2.
            final Pair<Node> v$g$2 = yyRepValue1.reverse();

            yyValue = GNode.createFromPair("CaseClause", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for v$g$2.
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("default")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(":")) {

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pCommandJava$DeclarationOrStatement(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$1.
          final Pair<Node> v$g$1 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("DefaultClause", v$g$1);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$1.
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("switch clause expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.ExpressionList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$ExpressionList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommandJava$Expression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(",")) {

          yyResult = pCommandJava$Expression(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("ExpressionList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.Expression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$Expression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fCommandJava$Expression) 
      yyColumn.chunk13.fCommandJava$Expression = pCommandJava$Expression$1(yyStart);
    return yyColumn.chunk13.fCommandJava$Expression;
  }

  /** Actually parse xtc.lang.blink.CommandJava.Expression. */
  private Result pCommandJava$Expression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Assignment>.

    yyResult = pCommandJava$ConditionalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = p$$Shared21(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$2 = yyResult.semanticValue();

        yyResult = pCommandJava$Expression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("Expression", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pCommandJava$ConditionalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.ConditionalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$ConditionalExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fCommandJava$ConditionalExpression) 
      yyColumn.chunk13.fCommandJava$ConditionalExpression = pCommandJava$ConditionalExpression$1(yyStart);
    return yyColumn.chunk13.fCommandJava$ConditionalExpression;
  }

  /** Actually parse xtc.lang.blink.CommandJava.ConditionalExpression. */
  private Result pCommandJava$ConditionalExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Conditional>.

    yyResult = pCommandJava$LogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("?")) {

        yyResult = pCommandJava$Expression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(":")) {

            yyResult = pCommandJava$ConditionalExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("ConditionalExpression", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'?' expected", yyBase);
      }
    }

    // Alternative <Base>.

    yyResult = pCommandJava$LogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.LogicalOrExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$LogicalOrExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fCommandJava$LogicalOrExpression) 
      yyColumn.chunk13.fCommandJava$LogicalOrExpression = pCommandJava$LogicalOrExpression$1(yyStart);
    return yyColumn.chunk13.fCommandJava$LogicalOrExpression;
  }

  /** Actually parse xtc.lang.blink.CommandJava.LogicalOrExpression. */
  private Result pCommandJava$LogicalOrExpression$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandJava$LogicalAndExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandJava$LogicalOrExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandJava.LogicalOrExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$LogicalOrExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Or>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("||")) {

      yyResult = pCommandJava$LogicalAndExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalOrExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical or expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.LogicalAndExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$LogicalAndExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandJava$BitwiseOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandJava$LogicalAndExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandJava.LogicalAndExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$LogicalAndExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <And>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&&")) {

      yyResult = pCommandJava$BitwiseOrExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalAndExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical and expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.BitwiseOrExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$BitwiseOrExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandJava$BitwiseXorExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandJava$BitwiseOrExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandJava.BitwiseOrExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$BitwiseOrExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Or>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("|")) {

      yyResult = pCommandJava$BitwiseXorExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseOrExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise or expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.BitwiseXorExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$BitwiseXorExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandJava$BitwiseAndExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandJava$BitwiseXorExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandJava.BitwiseXorExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$BitwiseXorExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Xor>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("^")) {

      yyResult = pCommandJava$BitwiseAndExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseXorExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise xor expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.BitwiseAndExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$BitwiseAndExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandJava$EqualityExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandJava$BitwiseAndExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandJava.BitwiseAndExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$BitwiseAndExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <And>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("&")) {

      yyResult = pCommandJava$EqualityExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseAndExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise and expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.EqualityExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$EqualityExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandJava$InstanceOfExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandJava$EqualityExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandJava.EqualityExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$EqualityExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared12(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pCommandJava$InstanceOfExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("EqualityExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.InstanceOfExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$InstanceOfExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Instanceof>.

    yyResult = pCommandJava$RelationalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("instanceof")) {

        yyResult = pType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("InstanceOfExpression", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'instanceof' expected", yyBase);
      }
    }

    // Alternative <Base>.

    yyResult = pCommandJava$RelationalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.RelationalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$RelationalExpression(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fCommandJava$RelationalExpression) 
      yyColumn.chunk13.fCommandJava$RelationalExpression = pCommandJava$RelationalExpression$1(yyStart);
    return yyColumn.chunk13.fCommandJava$RelationalExpression;
  }

  /** Actually parse xtc.lang.blink.CommandJava.RelationalExpression. */
  private Result pCommandJava$RelationalExpression$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandJava$ShiftExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandJava$RelationalExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandJava.RelationalExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$RelationalExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared22(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pCommandJava$ShiftExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("RelationalExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.ShiftExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$ShiftExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandJava$AdditiveExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandJava$ShiftExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandJava.ShiftExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$ShiftExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared23(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pCommandJava$AdditiveExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("ShiftExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.AdditiveExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$AdditiveExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandJava$MultiplicativeExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandJava$AdditiveExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandJava.AdditiveExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$AdditiveExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = p$$Shared15(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pCommandJava$MultiplicativeExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("AdditiveExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.MultiplicativeExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$MultiplicativeExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandJava$UnaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = 
          pCommandJava$MultiplicativeExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandJava.MultiplicativeExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$MultiplicativeExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Times>.

    yyResult = p$$Shared16(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$2 = yyResult.semanticValue();

      yyResult = pCommandJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("MultiplicativeExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.UnaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$UnaryExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Plus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("+")) {
      final String v$g$1 = "+";

      yyResult = pCommandJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryExpression", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Minus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("-")) {
      final String v$g$3 = "-";

      yyResult = pCommandJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryExpression", v$g$3, v$g$4);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Increment>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("++")) {
      final String v$g$5 = "++";

      yyResult = pCommandJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$6 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryExpression", v$g$5, v$g$6);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Decrement>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("--")) {
      final String v$g$7 = "--";

      yyResult = pCommandJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$8 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryExpression", v$g$7, v$g$8);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Base>.

    yyResult = pCommandJava$UnaryExpressionNotPlusMinus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("unary expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.UnaryExpressionNotPlusMinus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$UnaryExpressionNotPlusMinus(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("~")) {

      yyResult = pCommandJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("BitwiseNegationExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <CInJavaExpression>.

    yyResult = pCommandJava$CInJavaExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("!")) {

      yyResult = pCommandJava$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("LogicalNegationExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pPrimitiveType(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pDimensions(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$2.
          final Node v$g$2 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyResult = pCommandJava$UnaryExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("BasicCastExpression", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$g$2.
      }

      // Nested alternative 2.

      yyResult = pType(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          yyResult = pCommandJava$UnaryExpressionNotPlusMinus(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("CastExpression", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pCommandJava$PostfixExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("unary expression not plus minus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.PostfixExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$PostfixExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCommandJava$PrimaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$15 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandJava$PostfixExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$16 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$16, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$17.
        final Pair<Action<Node>> v$17 = yyRepValue1.reverse();

        yyValue = apply(v$17, v$g$15, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$17.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal CommandJava.PostfixExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$PostfixExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyOption1;
    Node         yyOpValue1;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(".")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.
      { // Start scope for nested choice.

        final int yyChoice2 = yyChoice1;

        // Nested alternative 1.

        yyResult = pJavaIdentifier$Identifier(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String v$g$3 = yyResult.semanticValue();

          yyResult = pCommandJava$Arguments(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$4 = yyResult.semanticValue();

            yyValue = new Action<Node>() {
              public Node run(Node v$1) {
                return GNode.create("CallExpression", v$1, null, v$g$3, v$g$4);
              }};

            return yyResult.createValue(yyValue, yyError);
          }
        }

        // Nested alternative 2.

        yyBase   = yyChoice2;
        yyResult = pJavaIdentifier$Word(yyBase);
        if (yyResult.hasValue("super")) {
          final String v$g$5 = "super";

          yyResult = pCommandJava$Arguments(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$6 = yyResult.semanticValue();

            yyValue = new Action<Node>() {
              public Node run(Node v$1) {
                return GNode.create("CallExpression", v$1, null, v$g$5, v$g$6);
              }};

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'super' expected", yyBase);
        }
      } // End scope for nested choice.

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("super")) {

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("SuperExpression", v$1);
          }};

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'super' expected", yyBase);
      }

      // Nested alternative 3.

      yyResult = pJavaIdentifier$Identifier(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final String v$g$7 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("SelectionExpression", v$1, v$g$7);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {

      yyResult = pCommandJava$Expression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$8 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("SubscriptExpression", v$1, v$g$8);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("++")) {
      final String v$g$9 = "++";

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          return GNode.create("PostfixExpression", v$1, v$g$9);
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("--")) {
      final String v$g$10 = "--";

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          return GNode.create("PostfixExpression", v$1, v$g$10);
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue(".")) {

      yyBase   = yyResult.index;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("new")) {

        yyResult = pJavaType$TypeName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$12 = yyResult.semanticValue();

          yyResult = pCommandJava$Arguments(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$13 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pCommandJava$ClassBody(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
            { // Start scope for v$g$14.
              final Node v$g$14 = yyOpValue1;

              yyValue = new Action<Node>() {
                public Node run(Node v$1) {
                  return GNode.create("NewClassExpression", v$1, null, v$g$12, v$g$13, v$g$14);
                }};

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$g$14.
          }
        }
      } else {
        yyError = yyError.select("'new' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("postfix expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.PrimaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$PrimaryExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Meta>.

    yyResult = pMetaVariable(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Literal>.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Expression>.

    yyResult = pJavaIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$3 = yyResult.semanticValue();

      yyResult = pCommandJava$Arguments(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        yyValue = GNode.create("CallExpression", null, null, v$g$3, v$g$4);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Expression>.

    yyResult = pResultType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(".")) {

        yyBase   = yyResult.index;
        yyResult = pJavaIdentifier$Word(yyBase);
        if (yyResult.hasValue("class")) {

          yyValue = GNode.create("ClassLiteralExpression", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'class' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'.' expected", yyBase);
      }
    }

    // Alternative <Expression>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("this")) {
      final String v$g$3 = "this";

      yyResult = pCommandJava$Arguments(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        yyValue = GNode.create("CallExpression", null, null, v$g$3, v$g$4);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Expression>.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pQualifiedIdentifier(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(".")) {

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      } else {
        yyError = yyError.select("'.' expected", yyBase);
      }
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyBase   = yyOption1;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("this")) {

        yyValue = GNode.create("ThisExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'this' expected", yyBase);
      }
    } // End scope for v$g$1.

    // Alternative 7.
    { // Start scope for nested choice.

      final int yyChoice1 = yyStart;

      // Nested alternative 1.

      yyResult = pJavaIdentifier$Word(yyChoice1);
      if (yyResult.hasValue("super")) {
        final String v$g$3 = "super";

        yyResult = pCommandJava$Arguments(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$4 = yyResult.semanticValue();

          yyValue = GNode.create("CallExpression", null, null, v$g$3, v$g$4);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pJavaIdentifier$Word(yyBase);
      if (yyResult.hasValue("super")) {

        yyValue = GNode.create("SuperExpression", null);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'super' expected", yyBase);
      }
    } // End scope for nested choice.

    // Alternative 8.

    yyResult = pJavaIdentifier$Identifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final String v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("PrimaryIdentifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Expression>.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("new")) {

      yyResult = pJavaType$TypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyResult = pCommandJava$Arguments(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$4 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pCommandJava$ClassBody(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$5.
            final Node v$g$5 = yyOpValue1;

            yyValue = GNode.create("NewClassExpression", null, null, v$g$3, v$g$4, v$g$5);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for v$g$5.
        }
      }
    }

    // Alternative 10.

    yyResult = pJavaIdentifier$Word(yyStart);
    if (yyResult.hasValue("new")) {

      yyResult = pJavaType$TypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pCommandJava$ConcreteDimensions(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pDimensions(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$3.
            final Node v$g$3 = yyOpValue1;

            yyValue = GNode.create("NewArrayExpression", v$g$1, v$g$2, v$g$3, null);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for v$g$3.
        }

        // Nested alternative 2.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pDimensions(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$6.
          final Node v$g$6 = yyOpValue1;

          yyResult = pCommandJava$ArrayInitializer(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$7 = yyResult.semanticValue();

            yyValue = GNode.create("NewArrayExpression", v$g$1, null, v$g$6, v$g$7);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } // End scope for v$g$6.
      }
    }

    // Alternative <Nested>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pCommandJava$Expression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue(")")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("primary expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.ConcreteDimensions.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$ConcreteDimensions(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pCommandJava$ConcreteDimension(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("ConcreteDimensions", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.ConcreteDimension.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$ConcreteDimension(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("[")) {

      yyResult = pCommandJava$Expression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("]")) {

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("concrete dimension expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.ArrayInitializer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$ArrayInitializer(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pCommandJava$VariableInitializer(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pCommandJava$VariableInitializer(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyOption1  = yyRepetition1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyOption1  = yyResult.index;
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue("}")) {

            yyValue = GNode.createFromPair("ArrayInitializer", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("'}' expected", yyBase);
          }
        } // End scope for v$g$2.
      }

      // Nested alternative 2.

      yyOption1  = yyChoice1;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(",")) {

        yyOption1  = yyResult.index;
      } else {
        yyError = yyError.select("',' expected", yyBase);
      }

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue("}")) {

        yyValue = GNode.create("ArrayInitializer", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'}' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("array initializer expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.VariableInitializer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$VariableInitializer(final int yyStart) 
    throws IOException {

    CommandParserColumn yyColumn = (CommandParserColumn)column(yyStart);
    if (null == yyColumn.chunk13) yyColumn.chunk13 = new Chunk13();
    if (null == yyColumn.chunk13.fCommandJava$VariableInitializer) 
      yyColumn.chunk13.fCommandJava$VariableInitializer = pCommandJava$VariableInitializer$1(yyStart);
    return yyColumn.chunk13.fCommandJava$VariableInitializer;
  }

  /** Actually parse xtc.lang.blink.CommandJava.VariableInitializer. */
  private Result pCommandJava$VariableInitializer$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Array>.

    yyResult = pCommandJava$ArrayInitializer(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Expression>.

    yyResult = pCommandJava$Expression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.Arguments.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$Arguments(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("(")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pCommandJava$Expression(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(",")) {

            yyResult = pCommandJava$Expression(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = GNode.createFromPair("Arguments", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$g$2.
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue(")")) {

        yyValue = GNode.create("Arguments", false);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("')' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("arguments expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.JavaInJavaBlock.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$JavaInJavaBlock(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue("{")) {

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommandJava$DeclarationOrStatement(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$g$1.
        final Pair<Node> v$g$1 = yyRepValue1.reverse();

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue("}")) {

          yyValue = GNode.createFromPair("JavaInJavaBlock", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      } // End scope for v$g$1.
    }

    // Done.
    yyError = yyError.select("java in java block expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.CInJavaBlock.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$CInJavaBlock(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared26(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pJeannieC$CInCBlock(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("CInJavaBlock", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.blink.CommandJava.CInJavaExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommandJava$CInJavaExpression(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = p$$Shared26(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pJeannieC$UnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$1 = yyResult.semanticValue();

        yyValue = GNode.create("CInJavaExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  static {
    add(JAVA_KEYWORDS, new String[] {
      "abstract",  "continue",  "for",         "new",        "switch",
      "assert",    "default",   "if",          "package",    "synchronized",
      "boolean",   "do",        "goto",        "private",    "this",
      "break",     "double",    "implements",  "protected",  "throw",
      "byte",      "else",      "import",      "public",     "throws",
      "case",                   "instanceof",  "return",     "transient",
      "catch",     "extends",   "int",         "short",      "try",
      "char",      "final",     "interface",   "static",     "void",
      "class",     "finally",   "long",        "strictfp",   "volatile",
      "const",     "float",     "native",      "super",      "while"
    });
  }
  static {
    add(C_KEYWORDS, new String[] { "_cancel", "_commit", "_with" });
  }
  static {
    add(C_KEYWORDS, new String[] {
      "auto",       "break",      "case",       "char",
      "const",      "continue",   "default",    "do",
      "double",     "else",       "enum",       "extern",
      "float",      "for",        "goto",       "if",
      "int",        "long",       "register",   "return",
      "short",      "signed",     "sizeof",     "static",
      "struct",     "switch",     "typedef",    "union",
      "unsigned",   "void",       "volatile",   "while"
    });
    
    if (C99) add(C_KEYWORDS, new String[] {
      "_Bool",      "_Complex",   "inline",
      "restrict"
    });
    
    if (GCC) add(C_KEYWORDS, new String[] {
      "__alignof",   "__alignof__",
      "asm",         "__asm",         "__asm__",
      "__attribute", "__attribute__",
      "__builtin_offsetof",
      "__builtin_types_compatible_p",
      "__builtin_va_arg",             "__builtin_va_list",
      "__complex__",
      "__const",     "__const__",
      "__extension__",
      "__inline",    "__inline__",
      "__label__",
      "__restrict",  "__restrict__",
      "__signed",    "__signed__",
      "__thread",
      "typeof",      "__typeof",      "__typeof__",
      "__volatile",  "__volatile__"
    });
    
  }

  // =========================================================================

  /**
   * Get the specified text.
   *
   * @param s The text.
   * @return The text.
   */
  protected static final String toText(String s) {
    return s;
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
