/* This source file is generated by GenerateJNIFunctionProxy.java
Please, do not edit manually.*/
#include <string.h>
#include <assert.h>
#include <jni.h>
#include <jvmti.h>
#include "agent_main.h"
#include "state.h"
#include "util.h"
#include "agent.h"
#include "options.h"
#include "jnicheck.h"
#include "classfile_constants.h"

static jniNativeInterface* proxy_jni_funcs = NULL;

/* proxy for GetVersion*/
static jint JNICALL bda_c2j_proxy_GetVersion(JNIEnv * env)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetVersion")
    && bda_check_no_exeception(s, "GetVersion")
    && bda_check_no_critical(s, "GetVersion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetVersion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetVersion(env);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for DefineClass*/
static jclass JNICALL bda_c2j_proxy_DefineClass(JNIEnv * env, const char * p1, jobject p2, const jbyte * p3, jsize p4)
{
  /* local variables */
  jclass result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "DefineClass")
    && bda_check_no_exeception(s, "DefineClass")
    && bda_check_no_critical(s, "DefineClass")
    && bda_check_non_null(s, p1,  1, "DefineClass")
    && bda_check_non_null(s, p3,  3, "DefineClass")
    && bda_check_ref_dangling(s, p2, 2, "DefineClass")
    && bda_check_assignable_jobject_jclass(s, p2, bda_clazz_classloader, 2, "DefineClass")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_DefineClass;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->DefineClass(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "DefineClass")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for FindClass*/
static jclass JNICALL bda_c2j_proxy_FindClass(JNIEnv * env, const char * p1)
{
  /* local variables */
  jclass result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "FindClass")
    && bda_check_no_exeception(s, "FindClass")
    && bda_check_no_critical(s, "FindClass")
    && bda_check_non_null(s, p1,  1, "FindClass")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_FindClass;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->FindClass(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "FindClass")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for FromReflectedMethod*/
static jmethodID JNICALL bda_c2j_proxy_FromReflectedMethod(JNIEnv * env, jobject p1)
{
  /* local variables */
  jmethodID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "FromReflectedMethod")
    && bda_check_no_exeception(s, "FromReflectedMethod")
    && bda_check_no_critical(s, "FromReflectedMethod")
    && bda_check_non_null(s, p1,  1, "FromReflectedMethod")
    && bda_check_ref_dangling(s, p1, 1, "FromReflectedMethod")
    && bda_check_jobject_reflected_method(s, p1, 1, "FromReflectedMethod")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_FromReflectedMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->FromReflectedMethod(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for FromReflectedField*/
static jfieldID JNICALL bda_c2j_proxy_FromReflectedField(JNIEnv * env, jobject p1)
{
  /* local variables */
  jfieldID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "FromReflectedField")
    && bda_check_no_exeception(s, "FromReflectedField")
    && bda_check_no_critical(s, "FromReflectedField")
    && bda_check_non_null(s, p1,  1, "FromReflectedField")
    && bda_check_ref_dangling(s, p1, 1, "FromReflectedField")
    && bda_check_instance_jobject_jclass(s, p1, bda_clazz_field, 1, "FromReflectedField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_FromReflectedField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->FromReflectedField(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for ToReflectedMethod*/
static jobject JNICALL bda_c2j_proxy_ToReflectedMethod(JNIEnv * env, jclass p1, jmethodID p2, jboolean p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ToReflectedMethod")
    && bda_check_no_exeception(s, "ToReflectedMethod")
    && bda_check_no_critical(s, "ToReflectedMethod")
    && bda_check_non_null(s, p1,  1, "ToReflectedMethod")
    && bda_check_non_null(s, p2,  2, "ToReflectedMethod")
    && bda_check_ref_dangling(s, p1, 1, "ToReflectedMethod")
    && bda_check_jclass(s, p1, 1, "ToReflectedMethod")
    && bda_check_jmethodid_to_reflected(s, p1, p2, p3, "ToReflectedMethod")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ToReflectedMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->ToReflectedMethod(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "ToReflectedMethod")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetSuperclass*/
static jclass JNICALL bda_c2j_proxy_GetSuperclass(JNIEnv * env, jclass p1)
{
  /* local variables */
  jclass result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetSuperclass")
    && bda_check_no_exeception(s, "GetSuperclass")
    && bda_check_no_critical(s, "GetSuperclass")
    && bda_check_non_null(s, p1,  1, "GetSuperclass")
    && bda_check_ref_dangling(s, p1, 1, "GetSuperclass")
    && bda_check_jclass(s, p1, 1, "GetSuperclass")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetSuperclass;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetSuperclass(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "GetSuperclass")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for IsAssignableFrom*/
static jboolean JNICALL bda_c2j_proxy_IsAssignableFrom(JNIEnv * env, jclass p1, jclass p2)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "IsAssignableFrom")
    && bda_check_no_exeception(s, "IsAssignableFrom")
    && bda_check_no_critical(s, "IsAssignableFrom")
    && bda_check_non_null(s, p1,  1, "IsAssignableFrom")
    && bda_check_non_null(s, p2,  2, "IsAssignableFrom")
    && bda_check_ref_dangling(s, p1, 1, "IsAssignableFrom")
    && bda_check_jclass(s, p1, 1, "IsAssignableFrom")
    && bda_check_ref_dangling(s, p2, 2, "IsAssignableFrom")
    && bda_check_jclass(s, p2, 2, "IsAssignableFrom")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_IsAssignableFrom;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->IsAssignableFrom(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for ToReflectedField*/
static jobject JNICALL bda_c2j_proxy_ToReflectedField(JNIEnv * env, jclass p1, jfieldID p2, jboolean p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ToReflectedField")
    && bda_check_no_exeception(s, "ToReflectedField")
    && bda_check_no_critical(s, "ToReflectedField")
    && bda_check_non_null(s, p1,  1, "ToReflectedField")
    && bda_check_non_null(s, p2,  2, "ToReflectedField")
    && bda_check_ref_dangling(s, p1, 1, "ToReflectedField")
    && bda_check_jclass(s, p1, 1, "ToReflectedField")
    && bda_check_jfieldid_to_reflected_field(s, p1, p2, p3, "ToReflectedField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ToReflectedField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->ToReflectedField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "ToReflectedField")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for Throw*/
static jint JNICALL bda_c2j_proxy_Throw(JNIEnv * env, jthrowable p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "Throw")
    && bda_check_no_exeception(s, "Throw")
    && bda_check_no_critical(s, "Throw")
    && bda_check_non_null(s, p1,  1, "Throw")
    && bda_check_ref_dangling(s, p1, 1, "Throw")
    && bda_check_jthrowable(s, p1, 1, "Throw")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_Throw;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->Throw(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for ThrowNew*/
static jint JNICALL bda_c2j_proxy_ThrowNew(JNIEnv * env, jclass p1, const char * p2)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ThrowNew")
    && bda_check_no_exeception(s, "ThrowNew")
    && bda_check_no_critical(s, "ThrowNew")
    && bda_check_non_null(s, p1,  1, "ThrowNew")
    && bda_check_non_null(s, p2,  2, "ThrowNew")
    && bda_check_ref_dangling(s, p1, 1, "ThrowNew")
    && bda_check_jclass(s, p1, 1, "ThrowNew")
    && bda_check_assignable_jclass_jclass(s, p1, bda_clazz_throwable, 1, "ThrowNew")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ThrowNew;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->ThrowNew(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for ExceptionOccurred*/
static jthrowable JNICALL bda_c2j_proxy_ExceptionOccurred(JNIEnv * env)
{
  /* local variables */
  jthrowable result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ExceptionOccurred")
    && bda_check_no_critical(s, "ExceptionOccurred")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ExceptionOccurred;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->ExceptionOccurred(env);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "ExceptionOccurred")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for ExceptionDescribe*/
static void JNICALL bda_c2j_proxy_ExceptionDescribe(JNIEnv * env)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ExceptionDescribe")
    && bda_check_no_critical(s, "ExceptionDescribe")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ExceptionDescribe;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ExceptionDescribe(env);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for ExceptionClear*/
static void JNICALL bda_c2j_proxy_ExceptionClear(JNIEnv * env)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ExceptionClear")
    && bda_check_no_critical(s, "ExceptionClear")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ExceptionClear;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ExceptionClear(env);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for FatalError*/
static void JNICALL bda_c2j_proxy_FatalError(JNIEnv * env, const char * p1)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "FatalError")
    && bda_check_no_exeception(s, "FatalError")
    && bda_check_no_critical(s, "FatalError")
    && bda_check_non_null(s, p1,  1, "FatalError")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_FatalError;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->FatalError(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for PushLocalFrame*/
static jint JNICALL bda_c2j_proxy_PushLocalFrame(JNIEnv * env, jint p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "PushLocalFrame")
    && bda_check_no_exeception(s, "PushLocalFrame")
    && bda_check_no_critical(s, "PushLocalFrame")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_PushLocalFrame;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->PushLocalFrame(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result == 0) {
     bda_local_ref_enter(s, p1, 0);
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for PopLocalFrame*/
static jobject JNICALL bda_c2j_proxy_PopLocalFrame(JNIEnv * env, jobject p1)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "PopLocalFrame")
    && bda_check_no_exeception(s, "PopLocalFrame")
    && bda_check_local_frame_double_free(s)
    && bda_check_no_critical(s, "PopLocalFrame")
    && bda_check_ref_dangling(s, p1, 1, "PopLocalFrame")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_PopLocalFrame;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->PopLocalFrame(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    bda_local_ref_leave(s);
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "PopLocalFrame")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for NewGlobalRef*/
static jobject JNICALL bda_c2j_proxy_NewGlobalRef(JNIEnv * env, jobject p1)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewGlobalRef")
    && bda_check_no_exeception(s, "NewGlobalRef")
    && bda_check_no_critical(s, "NewGlobalRef")
    && bda_check_non_null(s, p1,  1, "NewGlobalRef")
    && bda_check_ref_dangling(s, p1, 1, "NewGlobalRef")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewGlobalRef;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewGlobalRef(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
    if (result != NULL) {
      bda_global_ref_add(result, 0);
    }
  }

  return result;
}


/* proxy for DeleteGlobalRef*/
static void JNICALL bda_c2j_proxy_DeleteGlobalRef(JNIEnv * env, jobject p1)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "DeleteGlobalRef")
    && bda_check_no_critical(s, "DeleteGlobalRef")
    && bda_check_non_null(s, p1,  1, "DeleteGlobalRef")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "DeleteGlobalRef"))
    && bda_check_jobject_ref_type(s, p1, JNIGlobalRefType, 1, "DeleteGlobalRef")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_DeleteGlobalRef;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->DeleteGlobalRef(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
   bda_global_ref_delete(p1, 0);
  }

}


/* proxy for DeleteLocalRef*/
static void JNICALL bda_c2j_proxy_DeleteLocalRef(JNIEnv * env, jobject p1)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "DeleteLocalRef")
    && bda_check_no_critical(s, "DeleteLocalRef")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "DeleteLocalRef"))
    && bda_check_jobject_ref_type(s, p1, JNILocalRefType, 1, "DeleteLocalRef")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_DeleteLocalRef;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->DeleteLocalRef(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (p1 != NULL) {
     bda_local_ref_delete(s, p1);
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for IsSameObject*/
static jboolean JNICALL bda_c2j_proxy_IsSameObject(JNIEnv * env, jobject p1, jobject p2)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "IsSameObject")
    && bda_check_no_exeception(s, "IsSameObject")
    && bda_check_no_critical(s, "IsSameObject")
    && bda_check_ref_dangling(s, p1, 1, "IsSameObject")
    && bda_check_ref_dangling(s, p2, 2, "IsSameObject")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_IsSameObject;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->IsSameObject(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for NewLocalRef*/
static jobject JNICALL bda_c2j_proxy_NewLocalRef(JNIEnv * env, jobject p1)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewLocalRef")
    && bda_check_no_exeception(s, "NewLocalRef")
    && bda_check_no_critical(s, "NewLocalRef")
    && bda_check_non_null(s, p1,  1, "NewLocalRef")
    && bda_check_ref_dangling(s, p1, 1, "NewLocalRef")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewLocalRef;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewLocalRef(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewLocalRef")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for EnsureLocalCapacity*/
static jint JNICALL bda_c2j_proxy_EnsureLocalCapacity(JNIEnv * env, jint p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "EnsureLocalCapacity")
    && bda_check_no_exeception(s, "EnsureLocalCapacity")
    && bda_check_no_critical(s, "EnsureLocalCapacity")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_EnsureLocalCapacity;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->EnsureLocalCapacity(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for AllocObject*/
static jobject JNICALL bda_c2j_proxy_AllocObject(JNIEnv * env, jclass p1)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "AllocObject")
    && bda_check_no_exeception(s, "AllocObject")
    && bda_check_no_critical(s, "AllocObject")
    && bda_check_non_null(s, p1,  1, "AllocObject")
    && bda_check_ref_dangling(s, p1, 1, "AllocObject")
    && bda_check_jclass(s, p1, 1, "AllocObject")
    && bda_check_jclass_scalar_allocatable(s, p1, 1, "AllocObject")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_AllocObject;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->AllocObject(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "AllocObject")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for NewObject*/
static jobject JNICALL bda_c2j_proxy_NewObject(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "NewObject")
    && bda_check_no_exeception(s, "NewObject")
    && bda_check_no_critical(s, "NewObject")
    && bda_check_non_null(s, p1,  1, "NewObject")
    && bda_check_non_null(s, p2,  2, "NewObject")
    && bda_check_ref_dangling(s, p1, 1, "NewObject")
    && bda_check_jclass(s, p1, 1, "NewObject")
    && bda_check_jmethodid_new_object(s, p1, p2, awrap, "NewObject")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewObject;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->NewObjectV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewObject")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for NewObjectV*/
static jobject JNICALL bda_c2j_proxy_NewObjectV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
    awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "NewObjectV")
    && bda_check_no_exeception(s, "NewObjectV")
    && bda_check_no_critical(s, "NewObjectV")
    && bda_check_non_null(s, p1,  1, "NewObjectV")
    && bda_check_non_null(s, p2,  2, "NewObjectV")
    && bda_check_ref_dangling(s, p1, 1, "NewObjectV")
    && bda_check_jclass(s, p1, 1, "NewObjectV")
    && bda_check_jmethodid_new_object(s, p1, p2, awrap, "NewObjectV")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewObjectV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewObjectV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewObjectV")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for NewObjectA*/
static jobject JNICALL bda_c2j_proxy_NewObjectA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "NewObjectA")
    && bda_check_no_exeception(s, "NewObjectA")
    && bda_check_no_critical(s, "NewObjectA")
    && bda_check_non_null(s, p1,  1, "NewObjectA")
    && bda_check_non_null(s, p2,  2, "NewObjectA")
    && bda_check_ref_dangling(s, p1, 1, "NewObjectA")
    && bda_check_jclass(s, p1, 1, "NewObjectA")
    && bda_check_jmethodid_new_object(s, p1, p2, awrap, "NewObjectA")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewObjectA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewObjectA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewObjectA")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetObjectClass*/
static jclass JNICALL bda_c2j_proxy_GetObjectClass(JNIEnv * env, jobject p1)
{
  /* local variables */
  jclass result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetObjectClass")
    && bda_check_no_exeception(s, "GetObjectClass")
    && bda_check_no_critical(s, "GetObjectClass")
    && bda_check_non_null(s, p1,  1, "GetObjectClass")
    && bda_check_ref_dangling(s, p1, 1, "GetObjectClass")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetObjectClass;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetObjectClass(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "GetObjectClass")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for IsInstanceOf*/
static jboolean JNICALL bda_c2j_proxy_IsInstanceOf(JNIEnv * env, jobject p1, jclass p2)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "IsInstanceOf")
    && bda_check_no_exeception(s, "IsInstanceOf")
    && bda_check_no_critical(s, "IsInstanceOf")
    && bda_check_non_null(s, p1,  1, "IsInstanceOf")
    && bda_check_non_null(s, p2,  2, "IsInstanceOf")
    && bda_check_ref_dangling(s, p1, 1, "IsInstanceOf")
    && bda_check_ref_dangling(s, p2, 2, "IsInstanceOf")
    && bda_check_jclass(s, p2, 2, "IsInstanceOf")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_IsInstanceOf;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->IsInstanceOf(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetMethodID*/
static jmethodID JNICALL bda_c2j_proxy_GetMethodID(JNIEnv * env, jclass p1, const char * p2, const char * p3)
{
  /* local variables */
  jmethodID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetMethodID")
    && bda_check_no_exeception(s, "GetMethodID")
    && bda_check_no_critical(s, "GetMethodID")
    && bda_check_non_null(s, p1,  1, "GetMethodID")
    && bda_check_non_null(s, p2,  2, "GetMethodID")
    && bda_check_non_null(s, p3,  3, "GetMethodID")
    && bda_check_ref_dangling(s, p1, 1, "GetMethodID")
    && bda_check_jclass(s, p1, 1, "GetMethodID")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetMethodID;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetMethodID(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
       bda_jmethodid_append( result, 0, p1, p2, p3);
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallObjectMethod*/
static jobject JNICALL bda_c2j_proxy_CallObjectMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallObjectMethod")
    && bda_check_no_exeception(s, "CallObjectMethod")
    && bda_check_no_critical(s, "CallObjectMethod")
    && bda_check_non_null(s, p1,  1, "CallObjectMethod")
    && bda_check_non_null(s, p2,  2, "CallObjectMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallObjectMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallObjectMethod", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallObjectMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallObjectMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallObjectMethod")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallObjectMethodV*/
static jobject JNICALL bda_c2j_proxy_CallObjectMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallObjectMethodV")
    && bda_check_no_exeception(s, "CallObjectMethodV")
    && bda_check_no_critical(s, "CallObjectMethodV")
    && bda_check_non_null(s, p1,  1, "CallObjectMethodV")
    && bda_check_non_null(s, p2,  2, "CallObjectMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallObjectMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallObjectMethodV", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallObjectMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallObjectMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallObjectMethodV")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallObjectMethodA*/
static jobject JNICALL bda_c2j_proxy_CallObjectMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallObjectMethodA")
    && bda_check_no_exeception(s, "CallObjectMethodA")
    && bda_check_no_critical(s, "CallObjectMethodA")
    && bda_check_non_null(s, p1,  1, "CallObjectMethodA")
    && bda_check_non_null(s, p2,  2, "CallObjectMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallObjectMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallObjectMethodA", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallObjectMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallObjectMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallObjectMethodA")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallBooleanMethod*/
static jboolean JNICALL bda_c2j_proxy_CallBooleanMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallBooleanMethod")
    && bda_check_no_exeception(s, "CallBooleanMethod")
    && bda_check_no_critical(s, "CallBooleanMethod")
    && bda_check_non_null(s, p1,  1, "CallBooleanMethod")
    && bda_check_non_null(s, p2,  2, "CallBooleanMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallBooleanMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallBooleanMethod", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallBooleanMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallBooleanMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallBooleanMethodV*/
static jboolean JNICALL bda_c2j_proxy_CallBooleanMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallBooleanMethodV")
    && bda_check_no_exeception(s, "CallBooleanMethodV")
    && bda_check_no_critical(s, "CallBooleanMethodV")
    && bda_check_non_null(s, p1,  1, "CallBooleanMethodV")
    && bda_check_non_null(s, p2,  2, "CallBooleanMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallBooleanMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallBooleanMethodV", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallBooleanMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallBooleanMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallBooleanMethodA*/
static jboolean JNICALL bda_c2j_proxy_CallBooleanMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallBooleanMethodA")
    && bda_check_no_exeception(s, "CallBooleanMethodA")
    && bda_check_no_critical(s, "CallBooleanMethodA")
    && bda_check_non_null(s, p1,  1, "CallBooleanMethodA")
    && bda_check_non_null(s, p2,  2, "CallBooleanMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallBooleanMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallBooleanMethodA", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallBooleanMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallBooleanMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallByteMethod*/
static jbyte JNICALL bda_c2j_proxy_CallByteMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallByteMethod")
    && bda_check_no_exeception(s, "CallByteMethod")
    && bda_check_no_critical(s, "CallByteMethod")
    && bda_check_non_null(s, p1,  1, "CallByteMethod")
    && bda_check_non_null(s, p2,  2, "CallByteMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallByteMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallByteMethod", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallByteMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallByteMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallByteMethodV*/
static jbyte JNICALL bda_c2j_proxy_CallByteMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallByteMethodV")
    && bda_check_no_exeception(s, "CallByteMethodV")
    && bda_check_no_critical(s, "CallByteMethodV")
    && bda_check_non_null(s, p1,  1, "CallByteMethodV")
    && bda_check_non_null(s, p2,  2, "CallByteMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallByteMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallByteMethodV", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallByteMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallByteMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallByteMethodA*/
static jbyte JNICALL bda_c2j_proxy_CallByteMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallByteMethodA")
    && bda_check_no_exeception(s, "CallByteMethodA")
    && bda_check_no_critical(s, "CallByteMethodA")
    && bda_check_non_null(s, p1,  1, "CallByteMethodA")
    && bda_check_non_null(s, p2,  2, "CallByteMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallByteMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallByteMethodA", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallByteMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallByteMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallCharMethod*/
static jchar JNICALL bda_c2j_proxy_CallCharMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallCharMethod")
    && bda_check_no_exeception(s, "CallCharMethod")
    && bda_check_no_critical(s, "CallCharMethod")
    && bda_check_non_null(s, p1,  1, "CallCharMethod")
    && bda_check_non_null(s, p2,  2, "CallCharMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallCharMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallCharMethod", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallCharMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallCharMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallCharMethodV*/
static jchar JNICALL bda_c2j_proxy_CallCharMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallCharMethodV")
    && bda_check_no_exeception(s, "CallCharMethodV")
    && bda_check_no_critical(s, "CallCharMethodV")
    && bda_check_non_null(s, p1,  1, "CallCharMethodV")
    && bda_check_non_null(s, p2,  2, "CallCharMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallCharMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallCharMethodV", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallCharMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallCharMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallCharMethodA*/
static jchar JNICALL bda_c2j_proxy_CallCharMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallCharMethodA")
    && bda_check_no_exeception(s, "CallCharMethodA")
    && bda_check_no_critical(s, "CallCharMethodA")
    && bda_check_non_null(s, p1,  1, "CallCharMethodA")
    && bda_check_non_null(s, p2,  2, "CallCharMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallCharMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallCharMethodA", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallCharMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallCharMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallShortMethod*/
static jshort JNICALL bda_c2j_proxy_CallShortMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallShortMethod")
    && bda_check_no_exeception(s, "CallShortMethod")
    && bda_check_no_critical(s, "CallShortMethod")
    && bda_check_non_null(s, p1,  1, "CallShortMethod")
    && bda_check_non_null(s, p2,  2, "CallShortMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallShortMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallShortMethod", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallShortMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallShortMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallShortMethodV*/
static jshort JNICALL bda_c2j_proxy_CallShortMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallShortMethodV")
    && bda_check_no_exeception(s, "CallShortMethodV")
    && bda_check_no_critical(s, "CallShortMethodV")
    && bda_check_non_null(s, p1,  1, "CallShortMethodV")
    && bda_check_non_null(s, p2,  2, "CallShortMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallShortMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallShortMethodV", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallShortMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallShortMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallShortMethodA*/
static jshort JNICALL bda_c2j_proxy_CallShortMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallShortMethodA")
    && bda_check_no_exeception(s, "CallShortMethodA")
    && bda_check_no_critical(s, "CallShortMethodA")
    && bda_check_non_null(s, p1,  1, "CallShortMethodA")
    && bda_check_non_null(s, p2,  2, "CallShortMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallShortMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallShortMethodA", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallShortMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallShortMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallIntMethod*/
static jint JNICALL bda_c2j_proxy_CallIntMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallIntMethod")
    && bda_check_no_exeception(s, "CallIntMethod")
    && bda_check_no_critical(s, "CallIntMethod")
    && bda_check_non_null(s, p1,  1, "CallIntMethod")
    && bda_check_non_null(s, p2,  2, "CallIntMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallIntMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallIntMethod", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallIntMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallIntMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallIntMethodV*/
static jint JNICALL bda_c2j_proxy_CallIntMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallIntMethodV")
    && bda_check_no_exeception(s, "CallIntMethodV")
    && bda_check_no_critical(s, "CallIntMethodV")
    && bda_check_non_null(s, p1,  1, "CallIntMethodV")
    && bda_check_non_null(s, p2,  2, "CallIntMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallIntMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallIntMethodV", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallIntMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallIntMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallIntMethodA*/
static jint JNICALL bda_c2j_proxy_CallIntMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallIntMethodA")
    && bda_check_no_exeception(s, "CallIntMethodA")
    && bda_check_no_critical(s, "CallIntMethodA")
    && bda_check_non_null(s, p1,  1, "CallIntMethodA")
    && bda_check_non_null(s, p2,  2, "CallIntMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallIntMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallIntMethodA", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallIntMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallIntMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallLongMethod*/
static jlong JNICALL bda_c2j_proxy_CallLongMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallLongMethod")
    && bda_check_no_exeception(s, "CallLongMethod")
    && bda_check_no_critical(s, "CallLongMethod")
    && bda_check_non_null(s, p1,  1, "CallLongMethod")
    && bda_check_non_null(s, p2,  2, "CallLongMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallLongMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallLongMethod", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallLongMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallLongMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallLongMethodV*/
static jlong JNICALL bda_c2j_proxy_CallLongMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallLongMethodV")
    && bda_check_no_exeception(s, "CallLongMethodV")
    && bda_check_no_critical(s, "CallLongMethodV")
    && bda_check_non_null(s, p1,  1, "CallLongMethodV")
    && bda_check_non_null(s, p2,  2, "CallLongMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallLongMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallLongMethodV", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallLongMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallLongMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallLongMethodA*/
static jlong JNICALL bda_c2j_proxy_CallLongMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallLongMethodA")
    && bda_check_no_exeception(s, "CallLongMethodA")
    && bda_check_no_critical(s, "CallLongMethodA")
    && bda_check_non_null(s, p1,  1, "CallLongMethodA")
    && bda_check_non_null(s, p2,  2, "CallLongMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallLongMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallLongMethodA", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallLongMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallLongMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallFloatMethod*/
static jfloat JNICALL bda_c2j_proxy_CallFloatMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallFloatMethod")
    && bda_check_no_exeception(s, "CallFloatMethod")
    && bda_check_no_critical(s, "CallFloatMethod")
    && bda_check_non_null(s, p1,  1, "CallFloatMethod")
    && bda_check_non_null(s, p2,  2, "CallFloatMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallFloatMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallFloatMethod", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallFloatMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallFloatMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallFloatMethodV*/
static jfloat JNICALL bda_c2j_proxy_CallFloatMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallFloatMethodV")
    && bda_check_no_exeception(s, "CallFloatMethodV")
    && bda_check_no_critical(s, "CallFloatMethodV")
    && bda_check_non_null(s, p1,  1, "CallFloatMethodV")
    && bda_check_non_null(s, p2,  2, "CallFloatMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallFloatMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallFloatMethodV", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallFloatMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallFloatMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallFloatMethodA*/
static jfloat JNICALL bda_c2j_proxy_CallFloatMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallFloatMethodA")
    && bda_check_no_exeception(s, "CallFloatMethodA")
    && bda_check_no_critical(s, "CallFloatMethodA")
    && bda_check_non_null(s, p1,  1, "CallFloatMethodA")
    && bda_check_non_null(s, p2,  2, "CallFloatMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallFloatMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallFloatMethodA", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallFloatMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallFloatMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallDoubleMethod*/
static jdouble JNICALL bda_c2j_proxy_CallDoubleMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallDoubleMethod")
    && bda_check_no_exeception(s, "CallDoubleMethod")
    && bda_check_no_critical(s, "CallDoubleMethod")
    && bda_check_non_null(s, p1,  1, "CallDoubleMethod")
    && bda_check_non_null(s, p2,  2, "CallDoubleMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallDoubleMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallDoubleMethod", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallDoubleMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallDoubleMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallDoubleMethodV*/
static jdouble JNICALL bda_c2j_proxy_CallDoubleMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallDoubleMethodV")
    && bda_check_no_exeception(s, "CallDoubleMethodV")
    && bda_check_no_critical(s, "CallDoubleMethodV")
    && bda_check_non_null(s, p1,  1, "CallDoubleMethodV")
    && bda_check_non_null(s, p2,  2, "CallDoubleMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallDoubleMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallDoubleMethodV", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallDoubleMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallDoubleMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallDoubleMethodA*/
static jdouble JNICALL bda_c2j_proxy_CallDoubleMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallDoubleMethodA")
    && bda_check_no_exeception(s, "CallDoubleMethodA")
    && bda_check_no_critical(s, "CallDoubleMethodA")
    && bda_check_non_null(s, p1,  1, "CallDoubleMethodA")
    && bda_check_non_null(s, p2,  2, "CallDoubleMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallDoubleMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallDoubleMethodA", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallDoubleMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallDoubleMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallVoidMethod*/
static void JNICALL bda_c2j_proxy_CallVoidMethod(JNIEnv * env, jobject p1, jmethodID p2, ...)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallVoidMethod")
    && bda_check_no_exeception(s, "CallVoidMethod")
    && bda_check_no_critical(s, "CallVoidMethod")
    && bda_check_non_null(s, p1,  1, "CallVoidMethod")
    && bda_check_non_null(s, p2,  2, "CallVoidMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallVoidMethod")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallVoidMethod", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallVoidMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  bda_orig_jni_funcs->CallVoidMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for CallVoidMethodV*/
static void JNICALL bda_c2j_proxy_CallVoidMethodV(JNIEnv * env, jobject p1, jmethodID p2, va_list p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallVoidMethodV")
    && bda_check_no_exeception(s, "CallVoidMethodV")
    && bda_check_no_critical(s, "CallVoidMethodV")
    && bda_check_non_null(s, p1,  1, "CallVoidMethodV")
    && bda_check_non_null(s, p2,  2, "CallVoidMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallVoidMethodV")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallVoidMethodV", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallVoidMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallVoidMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for CallVoidMethodA*/
static void JNICALL bda_c2j_proxy_CallVoidMethodA(JNIEnv * env, jobject p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallVoidMethodA")
    && bda_check_no_exeception(s, "CallVoidMethodA")
    && bda_check_no_critical(s, "CallVoidMethodA")
    && bda_check_non_null(s, p1,  1, "CallVoidMethodA")
    && bda_check_non_null(s, p2,  2, "CallVoidMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallVoidMethodA")
    && bda_check_jmethodid_instance(s, p1, p2, awrap, "CallVoidMethodA", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallVoidMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_INSTANCE;
    c2j.object = p1;
    c2j.class = NULL;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallVoidMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for CallNonvirtualObjectMethod*/
static jobject JNICALL bda_c2j_proxy_CallNonvirtualObjectMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualObjectMethod")
    && bda_check_no_exeception(s, "CallNonvirtualObjectMethod")
    && bda_check_no_critical(s, "CallNonvirtualObjectMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualObjectMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualObjectMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualObjectMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualObjectMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualObjectMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualObjectMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualObjectMethod", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualObjectMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualObjectMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallNonvirtualObjectMethod")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualObjectMethodV*/
static jobject JNICALL bda_c2j_proxy_CallNonvirtualObjectMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualObjectMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualObjectMethodV")
    && bda_check_no_critical(s, "CallNonvirtualObjectMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualObjectMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualObjectMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualObjectMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualObjectMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualObjectMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualObjectMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualObjectMethodV", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualObjectMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualObjectMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallNonvirtualObjectMethodV")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualObjectMethodA*/
static jobject JNICALL bda_c2j_proxy_CallNonvirtualObjectMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualObjectMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualObjectMethodA")
    && bda_check_no_critical(s, "CallNonvirtualObjectMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualObjectMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualObjectMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualObjectMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualObjectMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualObjectMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualObjectMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualObjectMethodA", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualObjectMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualObjectMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallNonvirtualObjectMethodA")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualBooleanMethod*/
static jboolean JNICALL bda_c2j_proxy_CallNonvirtualBooleanMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualBooleanMethod")
    && bda_check_no_exeception(s, "CallNonvirtualBooleanMethod")
    && bda_check_no_critical(s, "CallNonvirtualBooleanMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualBooleanMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualBooleanMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualBooleanMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualBooleanMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualBooleanMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualBooleanMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualBooleanMethod", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualBooleanMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualBooleanMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualBooleanMethodV*/
static jboolean JNICALL bda_c2j_proxy_CallNonvirtualBooleanMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualBooleanMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualBooleanMethodV")
    && bda_check_no_critical(s, "CallNonvirtualBooleanMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualBooleanMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualBooleanMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualBooleanMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualBooleanMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualBooleanMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualBooleanMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualBooleanMethodV", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualBooleanMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualBooleanMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualBooleanMethodA*/
static jboolean JNICALL bda_c2j_proxy_CallNonvirtualBooleanMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualBooleanMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualBooleanMethodA")
    && bda_check_no_critical(s, "CallNonvirtualBooleanMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualBooleanMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualBooleanMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualBooleanMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualBooleanMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualBooleanMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualBooleanMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualBooleanMethodA", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualBooleanMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualBooleanMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualByteMethod*/
static jbyte JNICALL bda_c2j_proxy_CallNonvirtualByteMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualByteMethod")
    && bda_check_no_exeception(s, "CallNonvirtualByteMethod")
    && bda_check_no_critical(s, "CallNonvirtualByteMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualByteMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualByteMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualByteMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualByteMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualByteMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualByteMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualByteMethod", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualByteMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualByteMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualByteMethodV*/
static jbyte JNICALL bda_c2j_proxy_CallNonvirtualByteMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualByteMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualByteMethodV")
    && bda_check_no_critical(s, "CallNonvirtualByteMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualByteMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualByteMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualByteMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualByteMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualByteMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualByteMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualByteMethodV", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualByteMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualByteMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualByteMethodA*/
static jbyte JNICALL bda_c2j_proxy_CallNonvirtualByteMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualByteMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualByteMethodA")
    && bda_check_no_critical(s, "CallNonvirtualByteMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualByteMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualByteMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualByteMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualByteMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualByteMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualByteMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualByteMethodA", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualByteMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualByteMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualCharMethod*/
static jchar JNICALL bda_c2j_proxy_CallNonvirtualCharMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualCharMethod")
    && bda_check_no_exeception(s, "CallNonvirtualCharMethod")
    && bda_check_no_critical(s, "CallNonvirtualCharMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualCharMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualCharMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualCharMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualCharMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualCharMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualCharMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualCharMethod", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualCharMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualCharMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualCharMethodV*/
static jchar JNICALL bda_c2j_proxy_CallNonvirtualCharMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualCharMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualCharMethodV")
    && bda_check_no_critical(s, "CallNonvirtualCharMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualCharMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualCharMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualCharMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualCharMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualCharMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualCharMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualCharMethodV", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualCharMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualCharMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualCharMethodA*/
static jchar JNICALL bda_c2j_proxy_CallNonvirtualCharMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualCharMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualCharMethodA")
    && bda_check_no_critical(s, "CallNonvirtualCharMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualCharMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualCharMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualCharMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualCharMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualCharMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualCharMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualCharMethodA", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualCharMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualCharMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualShortMethod*/
static jshort JNICALL bda_c2j_proxy_CallNonvirtualShortMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualShortMethod")
    && bda_check_no_exeception(s, "CallNonvirtualShortMethod")
    && bda_check_no_critical(s, "CallNonvirtualShortMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualShortMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualShortMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualShortMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualShortMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualShortMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualShortMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualShortMethod", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualShortMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualShortMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualShortMethodV*/
static jshort JNICALL bda_c2j_proxy_CallNonvirtualShortMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualShortMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualShortMethodV")
    && bda_check_no_critical(s, "CallNonvirtualShortMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualShortMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualShortMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualShortMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualShortMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualShortMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualShortMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualShortMethodV", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualShortMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualShortMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualShortMethodA*/
static jshort JNICALL bda_c2j_proxy_CallNonvirtualShortMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualShortMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualShortMethodA")
    && bda_check_no_critical(s, "CallNonvirtualShortMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualShortMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualShortMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualShortMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualShortMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualShortMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualShortMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualShortMethodA", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualShortMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualShortMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualIntMethod*/
static jint JNICALL bda_c2j_proxy_CallNonvirtualIntMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualIntMethod")
    && bda_check_no_exeception(s, "CallNonvirtualIntMethod")
    && bda_check_no_critical(s, "CallNonvirtualIntMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualIntMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualIntMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualIntMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualIntMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualIntMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualIntMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualIntMethod", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualIntMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualIntMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualIntMethodV*/
static jint JNICALL bda_c2j_proxy_CallNonvirtualIntMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualIntMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualIntMethodV")
    && bda_check_no_critical(s, "CallNonvirtualIntMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualIntMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualIntMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualIntMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualIntMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualIntMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualIntMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualIntMethodV", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualIntMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualIntMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualIntMethodA*/
static jint JNICALL bda_c2j_proxy_CallNonvirtualIntMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualIntMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualIntMethodA")
    && bda_check_no_critical(s, "CallNonvirtualIntMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualIntMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualIntMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualIntMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualIntMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualIntMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualIntMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualIntMethodA", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualIntMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualIntMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualLongMethod*/
static jlong JNICALL bda_c2j_proxy_CallNonvirtualLongMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualLongMethod")
    && bda_check_no_exeception(s, "CallNonvirtualLongMethod")
    && bda_check_no_critical(s, "CallNonvirtualLongMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualLongMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualLongMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualLongMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualLongMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualLongMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualLongMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualLongMethod", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualLongMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualLongMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualLongMethodV*/
static jlong JNICALL bda_c2j_proxy_CallNonvirtualLongMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualLongMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualLongMethodV")
    && bda_check_no_critical(s, "CallNonvirtualLongMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualLongMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualLongMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualLongMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualLongMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualLongMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualLongMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualLongMethodV", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualLongMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualLongMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualLongMethodA*/
static jlong JNICALL bda_c2j_proxy_CallNonvirtualLongMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualLongMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualLongMethodA")
    && bda_check_no_critical(s, "CallNonvirtualLongMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualLongMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualLongMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualLongMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualLongMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualLongMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualLongMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualLongMethodA", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualLongMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualLongMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualFloatMethod*/
static jfloat JNICALL bda_c2j_proxy_CallNonvirtualFloatMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualFloatMethod")
    && bda_check_no_exeception(s, "CallNonvirtualFloatMethod")
    && bda_check_no_critical(s, "CallNonvirtualFloatMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualFloatMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualFloatMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualFloatMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualFloatMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualFloatMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualFloatMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualFloatMethod", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualFloatMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualFloatMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualFloatMethodV*/
static jfloat JNICALL bda_c2j_proxy_CallNonvirtualFloatMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualFloatMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualFloatMethodV")
    && bda_check_no_critical(s, "CallNonvirtualFloatMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualFloatMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualFloatMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualFloatMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualFloatMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualFloatMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualFloatMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualFloatMethodV", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualFloatMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualFloatMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualFloatMethodA*/
static jfloat JNICALL bda_c2j_proxy_CallNonvirtualFloatMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualFloatMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualFloatMethodA")
    && bda_check_no_critical(s, "CallNonvirtualFloatMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualFloatMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualFloatMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualFloatMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualFloatMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualFloatMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualFloatMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualFloatMethodA", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualFloatMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualFloatMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualDoubleMethod*/
static jdouble JNICALL bda_c2j_proxy_CallNonvirtualDoubleMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualDoubleMethod")
    && bda_check_no_exeception(s, "CallNonvirtualDoubleMethod")
    && bda_check_no_critical(s, "CallNonvirtualDoubleMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualDoubleMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualDoubleMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualDoubleMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualDoubleMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualDoubleMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualDoubleMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualDoubleMethod", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualDoubleMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  result =   bda_orig_jni_funcs->CallNonvirtualDoubleMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualDoubleMethodV*/
static jdouble JNICALL bda_c2j_proxy_CallNonvirtualDoubleMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualDoubleMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualDoubleMethodV")
    && bda_check_no_critical(s, "CallNonvirtualDoubleMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualDoubleMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualDoubleMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualDoubleMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualDoubleMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualDoubleMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualDoubleMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualDoubleMethodV", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualDoubleMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualDoubleMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualDoubleMethodA*/
static jdouble JNICALL bda_c2j_proxy_CallNonvirtualDoubleMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualDoubleMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualDoubleMethodA")
    && bda_check_no_critical(s, "CallNonvirtualDoubleMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualDoubleMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualDoubleMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualDoubleMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualDoubleMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualDoubleMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualDoubleMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualDoubleMethodA", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualDoubleMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallNonvirtualDoubleMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallNonvirtualVoidMethod*/
static void JNICALL bda_c2j_proxy_CallNonvirtualVoidMethod(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, ...)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p3);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualVoidMethod")
    && bda_check_no_exeception(s, "CallNonvirtualVoidMethod")
    && bda_check_no_critical(s, "CallNonvirtualVoidMethod")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualVoidMethod")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualVoidMethod")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualVoidMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualVoidMethod")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualVoidMethod")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualVoidMethod")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualVoidMethod", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualVoidMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p3);
  bda_orig_jni_funcs->CallNonvirtualVoidMethodV(env, p1, p2, p3, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for CallNonvirtualVoidMethodV*/
static void JNICALL bda_c2j_proxy_CallNonvirtualVoidMethodV(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, va_list p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualVoidMethodV")
    && bda_check_no_exeception(s, "CallNonvirtualVoidMethodV")
    && bda_check_no_critical(s, "CallNonvirtualVoidMethodV")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualVoidMethodV")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualVoidMethodV")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualVoidMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualVoidMethodV")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualVoidMethodV")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualVoidMethodV")
    &&  bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualVoidMethodV", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualVoidMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallNonvirtualVoidMethodV(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for CallNonvirtualVoidMethodA*/
static void JNICALL bda_c2j_proxy_CallNonvirtualVoidMethodA(JNIEnv * env, jobject p1, jclass p2, jmethodID p3, const jvalue * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p4;

    success = 1 
    && bda_check_env_match(s, env, "CallNonvirtualVoidMethodA")
    && bda_check_no_exeception(s, "CallNonvirtualVoidMethodA")
    && bda_check_no_critical(s, "CallNonvirtualVoidMethodA")
    && bda_check_non_null(s, p1,  1, "CallNonvirtualVoidMethodA")
    && bda_check_non_null(s, p2,  2, "CallNonvirtualVoidMethodA")
    && bda_check_non_null(s, p3,  3, "CallNonvirtualVoidMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallNonvirtualVoidMethodA")
    && bda_check_ref_dangling(s, p2, 2, "CallNonvirtualVoidMethodA")
    && bda_check_jclass(s, p2, 2, "CallNonvirtualVoidMethodA")
    && bda_check_jmethodid_nonvirtual(s, p1, p2, p3, awrap, "CallNonvirtualVoidMethodA", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallNonvirtualVoidMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NONVIRTUAL;
    c2j.object = p1;
    c2j.class = p2;
    c2j.mid = p3;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallNonvirtualVoidMethodA(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for GetFieldID*/
static jfieldID JNICALL bda_c2j_proxy_GetFieldID(JNIEnv * env, jclass p1, const char * p2, const char * p3)
{
  /* local variables */
  jfieldID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetFieldID")
    && bda_check_no_exeception(s, "GetFieldID")
    && bda_check_no_critical(s, "GetFieldID")
    && bda_check_non_null(s, p1,  1, "GetFieldID")
    && bda_check_non_null(s, p2,  2, "GetFieldID")
    && bda_check_non_null(s, p3,  3, "GetFieldID")
    && bda_check_ref_dangling(s, p1, 1, "GetFieldID")
    && bda_check_jclass(s, p1, 1, "GetFieldID")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetFieldID;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetFieldID(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
       bda_jfieldid_append(s, result, p1, 0, p2, p3);
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetObjectField*/
static jobject JNICALL bda_c2j_proxy_GetObjectField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetObjectField")
    && bda_check_no_exeception(s, "GetObjectField")
    && bda_check_no_critical(s, "GetObjectField")
    && bda_check_non_null(s, p1,  1, "GetObjectField")
    && bda_check_non_null(s, p2,  2, "GetObjectField")
    && bda_check_ref_dangling(s, p1, 1, "GetObjectField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'O', "GetObjectField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetObjectField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetObjectField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "GetObjectField")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetBooleanField*/
static jboolean JNICALL bda_c2j_proxy_GetBooleanField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetBooleanField")
    && bda_check_no_exeception(s, "GetBooleanField")
    && bda_check_no_critical(s, "GetBooleanField")
    && bda_check_non_null(s, p1,  1, "GetBooleanField")
    && bda_check_non_null(s, p2,  2, "GetBooleanField")
    && bda_check_ref_dangling(s, p1, 1, "GetBooleanField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'Z', "GetBooleanField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetBooleanField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetBooleanField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetByteField*/
static jbyte JNICALL bda_c2j_proxy_GetByteField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetByteField")
    && bda_check_no_exeception(s, "GetByteField")
    && bda_check_no_critical(s, "GetByteField")
    && bda_check_non_null(s, p1,  1, "GetByteField")
    && bda_check_non_null(s, p2,  2, "GetByteField")
    && bda_check_ref_dangling(s, p1, 1, "GetByteField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'B', "GetByteField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetByteField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetByteField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetCharField*/
static jchar JNICALL bda_c2j_proxy_GetCharField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetCharField")
    && bda_check_no_exeception(s, "GetCharField")
    && bda_check_no_critical(s, "GetCharField")
    && bda_check_non_null(s, p1,  1, "GetCharField")
    && bda_check_non_null(s, p2,  2, "GetCharField")
    && bda_check_ref_dangling(s, p1, 1, "GetCharField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'C', "GetCharField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetCharField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetCharField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetShortField*/
static jshort JNICALL bda_c2j_proxy_GetShortField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetShortField")
    && bda_check_no_exeception(s, "GetShortField")
    && bda_check_no_critical(s, "GetShortField")
    && bda_check_non_null(s, p1,  1, "GetShortField")
    && bda_check_non_null(s, p2,  2, "GetShortField")
    && bda_check_ref_dangling(s, p1, 1, "GetShortField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'S', "GetShortField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetShortField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetShortField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetIntField*/
static jint JNICALL bda_c2j_proxy_GetIntField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetIntField")
    && bda_check_no_exeception(s, "GetIntField")
    && bda_check_no_critical(s, "GetIntField")
    && bda_check_non_null(s, p1,  1, "GetIntField")
    && bda_check_non_null(s, p2,  2, "GetIntField")
    && bda_check_ref_dangling(s, p1, 1, "GetIntField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'I', "GetIntField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetIntField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetIntField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetLongField*/
static jlong JNICALL bda_c2j_proxy_GetLongField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetLongField")
    && bda_check_no_exeception(s, "GetLongField")
    && bda_check_no_critical(s, "GetLongField")
    && bda_check_non_null(s, p1,  1, "GetLongField")
    && bda_check_non_null(s, p2,  2, "GetLongField")
    && bda_check_ref_dangling(s, p1, 1, "GetLongField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'J', "GetLongField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetLongField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetLongField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetFloatField*/
static jfloat JNICALL bda_c2j_proxy_GetFloatField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetFloatField")
    && bda_check_no_exeception(s, "GetFloatField")
    && bda_check_no_critical(s, "GetFloatField")
    && bda_check_non_null(s, p1,  1, "GetFloatField")
    && bda_check_non_null(s, p2,  2, "GetFloatField")
    && bda_check_ref_dangling(s, p1, 1, "GetFloatField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'F', "GetFloatField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetFloatField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetFloatField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetDoubleField*/
static jdouble JNICALL bda_c2j_proxy_GetDoubleField(JNIEnv * env, jobject p1, jfieldID p2)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetDoubleField")
    && bda_check_no_exeception(s, "GetDoubleField")
    && bda_check_no_critical(s, "GetDoubleField")
    && bda_check_non_null(s, p1,  1, "GetDoubleField")
    && bda_check_non_null(s, p2,  2, "GetDoubleField")
    && bda_check_ref_dangling(s, p1, 1, "GetDoubleField")
    && bda_check_jfieldid_get_instance(s, p1, p2, 'D', "GetDoubleField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetDoubleField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetDoubleField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for SetObjectField*/
static void JNICALL bda_c2j_proxy_SetObjectField(JNIEnv * env, jobject p1, jfieldID p2, jobject p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.l = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetObjectField")
    && bda_check_no_exeception(s, "SetObjectField")
    && bda_check_no_critical(s, "SetObjectField")
    && bda_check_non_null(s, p1,  1, "SetObjectField")
    && bda_check_non_null(s, p2,  2, "SetObjectField")
    && bda_check_ref_dangling(s, p1, 1, "SetObjectField")
    && bda_check_ref_dangling(s, p3, 3, "SetObjectField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'O', "SetObjectField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetObjectField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetObjectField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetObjectField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetBooleanField*/
static void JNICALL bda_c2j_proxy_SetBooleanField(JNIEnv * env, jobject p1, jfieldID p2, jboolean p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.z = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetBooleanField")
    && bda_check_no_exeception(s, "SetBooleanField")
    && bda_check_no_critical(s, "SetBooleanField")
    && bda_check_non_null(s, p1,  1, "SetBooleanField")
    && bda_check_non_null(s, p2,  2, "SetBooleanField")
    && bda_check_ref_dangling(s, p1, 1, "SetBooleanField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'Z', "SetBooleanField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetBooleanField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetBooleanField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetBooleanField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetByteField*/
static void JNICALL bda_c2j_proxy_SetByteField(JNIEnv * env, jobject p1, jfieldID p2, jbyte p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.b = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetByteField")
    && bda_check_no_exeception(s, "SetByteField")
    && bda_check_no_critical(s, "SetByteField")
    && bda_check_non_null(s, p1,  1, "SetByteField")
    && bda_check_non_null(s, p2,  2, "SetByteField")
    && bda_check_ref_dangling(s, p1, 1, "SetByteField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'B', "SetByteField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetByteField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetByteField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetByteField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetCharField*/
static void JNICALL bda_c2j_proxy_SetCharField(JNIEnv * env, jobject p1, jfieldID p2, jchar p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.c = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetCharField")
    && bda_check_no_exeception(s, "SetCharField")
    && bda_check_no_critical(s, "SetCharField")
    && bda_check_non_null(s, p1,  1, "SetCharField")
    && bda_check_non_null(s, p2,  2, "SetCharField")
    && bda_check_ref_dangling(s, p1, 1, "SetCharField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'C', "SetCharField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetCharField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetCharField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetCharField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetShortField*/
static void JNICALL bda_c2j_proxy_SetShortField(JNIEnv * env, jobject p1, jfieldID p2, jshort p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.s = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetShortField")
    && bda_check_no_exeception(s, "SetShortField")
    && bda_check_no_critical(s, "SetShortField")
    && bda_check_non_null(s, p1,  1, "SetShortField")
    && bda_check_non_null(s, p2,  2, "SetShortField")
    && bda_check_ref_dangling(s, p1, 1, "SetShortField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'S', "SetShortField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetShortField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetShortField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetShortField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetIntField*/
static void JNICALL bda_c2j_proxy_SetIntField(JNIEnv * env, jobject p1, jfieldID p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.i = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetIntField")
    && bda_check_no_exeception(s, "SetIntField")
    && bda_check_no_critical(s, "SetIntField")
    && bda_check_non_null(s, p1,  1, "SetIntField")
    && bda_check_non_null(s, p2,  2, "SetIntField")
    && bda_check_ref_dangling(s, p1, 1, "SetIntField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'I', "SetIntField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetIntField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetIntField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetIntField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetLongField*/
static void JNICALL bda_c2j_proxy_SetLongField(JNIEnv * env, jobject p1, jfieldID p2, jlong p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.j = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetLongField")
    && bda_check_no_exeception(s, "SetLongField")
    && bda_check_no_critical(s, "SetLongField")
    && bda_check_non_null(s, p1,  1, "SetLongField")
    && bda_check_non_null(s, p2,  2, "SetLongField")
    && bda_check_ref_dangling(s, p1, 1, "SetLongField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'J', "SetLongField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetLongField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetLongField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetLongField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetFloatField*/
static void JNICALL bda_c2j_proxy_SetFloatField(JNIEnv * env, jobject p1, jfieldID p2, jfloat p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.f = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetFloatField")
    && bda_check_no_exeception(s, "SetFloatField")
    && bda_check_no_critical(s, "SetFloatField")
    && bda_check_non_null(s, p1,  1, "SetFloatField")
    && bda_check_non_null(s, p2,  2, "SetFloatField")
    && bda_check_ref_dangling(s, p1, 1, "SetFloatField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'F', "SetFloatField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetFloatField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetFloatField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetFloatField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetDoubleField*/
static void JNICALL bda_c2j_proxy_SetDoubleField(JNIEnv * env, jobject p1, jfieldID p2, jdouble p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.d = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetDoubleField")
    && bda_check_no_exeception(s, "SetDoubleField")
    && bda_check_no_critical(s, "SetDoubleField")
    && bda_check_non_null(s, p1,  1, "SetDoubleField")
    && bda_check_non_null(s, p2,  2, "SetDoubleField")
    && bda_check_ref_dangling(s, p1, 1, "SetDoubleField")
    && bda_check_jfieldid_set_instance(s, p1, p2, v, 'D', "SetDoubleField")
    && bda_check_access_set_instance_field(s, p1, p2, 2, "SetDoubleField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetDoubleField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetDoubleField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for GetStaticMethodID*/
static jmethodID JNICALL bda_c2j_proxy_GetStaticMethodID(JNIEnv * env, jclass p1, const char * p2, const char * p3)
{
  /* local variables */
  jmethodID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticMethodID")
    && bda_check_no_exeception(s, "GetStaticMethodID")
    && bda_check_no_critical(s, "GetStaticMethodID")
    && bda_check_non_null(s, p1,  1, "GetStaticMethodID")
    && bda_check_non_null(s, p2,  2, "GetStaticMethodID")
    && bda_check_non_null(s, p3,  3, "GetStaticMethodID")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticMethodID")
    && bda_check_jclass(s, p1, 1, "GetStaticMethodID")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticMethodID;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticMethodID(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
       bda_jmethodid_append(result, 1, p1, p2, p3);
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticObjectMethod*/
static jobject JNICALL bda_c2j_proxy_CallStaticObjectMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticObjectMethod")
    && bda_check_no_exeception(s, "CallStaticObjectMethod")
    && bda_check_no_critical(s, "CallStaticObjectMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticObjectMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticObjectMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticObjectMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticObjectMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticObjectMethod", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticObjectMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticObjectMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallStaticObjectMethod")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticObjectMethodV*/
static jobject JNICALL bda_c2j_proxy_CallStaticObjectMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticObjectMethodV")
    && bda_check_no_exeception(s, "CallStaticObjectMethodV")
    && bda_check_no_critical(s, "CallStaticObjectMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticObjectMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticObjectMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticObjectMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticObjectMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticObjectMethodV", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticObjectMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticObjectMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallStaticObjectMethodV")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticObjectMethodA*/
static jobject JNICALL bda_c2j_proxy_CallStaticObjectMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticObjectMethodA")
    && bda_check_no_exeception(s, "CallStaticObjectMethodA")
    && bda_check_no_critical(s, "CallStaticObjectMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticObjectMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticObjectMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticObjectMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticObjectMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticObjectMethodA", 'O')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticObjectMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticObjectMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "CallStaticObjectMethodA")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticBooleanMethod*/
static jboolean JNICALL bda_c2j_proxy_CallStaticBooleanMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticBooleanMethod")
    && bda_check_no_exeception(s, "CallStaticBooleanMethod")
    && bda_check_no_critical(s, "CallStaticBooleanMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticBooleanMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticBooleanMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticBooleanMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticBooleanMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticBooleanMethod", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticBooleanMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticBooleanMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticBooleanMethodV*/
static jboolean JNICALL bda_c2j_proxy_CallStaticBooleanMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticBooleanMethodV")
    && bda_check_no_exeception(s, "CallStaticBooleanMethodV")
    && bda_check_no_critical(s, "CallStaticBooleanMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticBooleanMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticBooleanMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticBooleanMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticBooleanMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticBooleanMethodV", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticBooleanMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticBooleanMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticBooleanMethodA*/
static jboolean JNICALL bda_c2j_proxy_CallStaticBooleanMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticBooleanMethodA")
    && bda_check_no_exeception(s, "CallStaticBooleanMethodA")
    && bda_check_no_critical(s, "CallStaticBooleanMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticBooleanMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticBooleanMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticBooleanMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticBooleanMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticBooleanMethodA", 'Z')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticBooleanMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticBooleanMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticByteMethod*/
static jbyte JNICALL bda_c2j_proxy_CallStaticByteMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticByteMethod")
    && bda_check_no_exeception(s, "CallStaticByteMethod")
    && bda_check_no_critical(s, "CallStaticByteMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticByteMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticByteMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticByteMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticByteMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticByteMethod", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticByteMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticByteMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticByteMethodV*/
static jbyte JNICALL bda_c2j_proxy_CallStaticByteMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticByteMethodV")
    && bda_check_no_exeception(s, "CallStaticByteMethodV")
    && bda_check_no_critical(s, "CallStaticByteMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticByteMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticByteMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticByteMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticByteMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticByteMethodV", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticByteMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticByteMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticByteMethodA*/
static jbyte JNICALL bda_c2j_proxy_CallStaticByteMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticByteMethodA")
    && bda_check_no_exeception(s, "CallStaticByteMethodA")
    && bda_check_no_critical(s, "CallStaticByteMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticByteMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticByteMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticByteMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticByteMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticByteMethodA", 'B')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticByteMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticByteMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticCharMethod*/
static jchar JNICALL bda_c2j_proxy_CallStaticCharMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticCharMethod")
    && bda_check_no_exeception(s, "CallStaticCharMethod")
    && bda_check_no_critical(s, "CallStaticCharMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticCharMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticCharMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticCharMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticCharMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticCharMethod", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticCharMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticCharMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticCharMethodV*/
static jchar JNICALL bda_c2j_proxy_CallStaticCharMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticCharMethodV")
    && bda_check_no_exeception(s, "CallStaticCharMethodV")
    && bda_check_no_critical(s, "CallStaticCharMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticCharMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticCharMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticCharMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticCharMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticCharMethodV", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticCharMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticCharMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticCharMethodA*/
static jchar JNICALL bda_c2j_proxy_CallStaticCharMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticCharMethodA")
    && bda_check_no_exeception(s, "CallStaticCharMethodA")
    && bda_check_no_critical(s, "CallStaticCharMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticCharMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticCharMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticCharMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticCharMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticCharMethodA", 'C')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticCharMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticCharMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticShortMethod*/
static jshort JNICALL bda_c2j_proxy_CallStaticShortMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticShortMethod")
    && bda_check_no_exeception(s, "CallStaticShortMethod")
    && bda_check_no_critical(s, "CallStaticShortMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticShortMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticShortMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticShortMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticShortMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticShortMethod", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticShortMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticShortMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticShortMethodV*/
static jshort JNICALL bda_c2j_proxy_CallStaticShortMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticShortMethodV")
    && bda_check_no_exeception(s, "CallStaticShortMethodV")
    && bda_check_no_critical(s, "CallStaticShortMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticShortMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticShortMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticShortMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticShortMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticShortMethodV", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticShortMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticShortMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticShortMethodA*/
static jshort JNICALL bda_c2j_proxy_CallStaticShortMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticShortMethodA")
    && bda_check_no_exeception(s, "CallStaticShortMethodA")
    && bda_check_no_critical(s, "CallStaticShortMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticShortMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticShortMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticShortMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticShortMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticShortMethodA", 'S')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticShortMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticShortMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticIntMethod*/
static jint JNICALL bda_c2j_proxy_CallStaticIntMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticIntMethod")
    && bda_check_no_exeception(s, "CallStaticIntMethod")
    && bda_check_no_critical(s, "CallStaticIntMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticIntMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticIntMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticIntMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticIntMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticIntMethod", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticIntMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticIntMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticIntMethodV*/
static jint JNICALL bda_c2j_proxy_CallStaticIntMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticIntMethodV")
    && bda_check_no_exeception(s, "CallStaticIntMethodV")
    && bda_check_no_critical(s, "CallStaticIntMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticIntMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticIntMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticIntMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticIntMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticIntMethodV", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticIntMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticIntMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticIntMethodA*/
static jint JNICALL bda_c2j_proxy_CallStaticIntMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticIntMethodA")
    && bda_check_no_exeception(s, "CallStaticIntMethodA")
    && bda_check_no_critical(s, "CallStaticIntMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticIntMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticIntMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticIntMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticIntMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticIntMethodA", 'I')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticIntMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticIntMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticLongMethod*/
static jlong JNICALL bda_c2j_proxy_CallStaticLongMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticLongMethod")
    && bda_check_no_exeception(s, "CallStaticLongMethod")
    && bda_check_no_critical(s, "CallStaticLongMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticLongMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticLongMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticLongMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticLongMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticLongMethod", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticLongMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticLongMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticLongMethodV*/
static jlong JNICALL bda_c2j_proxy_CallStaticLongMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticLongMethodV")
    && bda_check_no_exeception(s, "CallStaticLongMethodV")
    && bda_check_no_critical(s, "CallStaticLongMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticLongMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticLongMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticLongMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticLongMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticLongMethodV", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticLongMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticLongMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticLongMethodA*/
static jlong JNICALL bda_c2j_proxy_CallStaticLongMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticLongMethodA")
    && bda_check_no_exeception(s, "CallStaticLongMethodA")
    && bda_check_no_critical(s, "CallStaticLongMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticLongMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticLongMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticLongMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticLongMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticLongMethodA", 'J')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticLongMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticLongMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticFloatMethod*/
static jfloat JNICALL bda_c2j_proxy_CallStaticFloatMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticFloatMethod")
    && bda_check_no_exeception(s, "CallStaticFloatMethod")
    && bda_check_no_critical(s, "CallStaticFloatMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticFloatMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticFloatMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticFloatMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticFloatMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticFloatMethod", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticFloatMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticFloatMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticFloatMethodV*/
static jfloat JNICALL bda_c2j_proxy_CallStaticFloatMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticFloatMethodV")
    && bda_check_no_exeception(s, "CallStaticFloatMethodV")
    && bda_check_no_critical(s, "CallStaticFloatMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticFloatMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticFloatMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticFloatMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticFloatMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticFloatMethodV", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticFloatMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticFloatMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticFloatMethodA*/
static jfloat JNICALL bda_c2j_proxy_CallStaticFloatMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticFloatMethodA")
    && bda_check_no_exeception(s, "CallStaticFloatMethodA")
    && bda_check_no_critical(s, "CallStaticFloatMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticFloatMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticFloatMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticFloatMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticFloatMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticFloatMethodA", 'F')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticFloatMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticFloatMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticDoubleMethod*/
static jdouble JNICALL bda_c2j_proxy_CallStaticDoubleMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticDoubleMethod")
    && bda_check_no_exeception(s, "CallStaticDoubleMethod")
    && bda_check_no_critical(s, "CallStaticDoubleMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticDoubleMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticDoubleMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticDoubleMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticDoubleMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticDoubleMethod", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticDoubleMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  result =   bda_orig_jni_funcs->CallStaticDoubleMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticDoubleMethodV*/
static jdouble JNICALL bda_c2j_proxy_CallStaticDoubleMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticDoubleMethodV")
    && bda_check_no_exeception(s, "CallStaticDoubleMethodV")
    && bda_check_no_critical(s, "CallStaticDoubleMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticDoubleMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticDoubleMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticDoubleMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticDoubleMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticDoubleMethodV", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticDoubleMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticDoubleMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticDoubleMethodA*/
static jdouble JNICALL bda_c2j_proxy_CallStaticDoubleMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticDoubleMethodA")
    && bda_check_no_exeception(s, "CallStaticDoubleMethodA")
    && bda_check_no_critical(s, "CallStaticDoubleMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticDoubleMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticDoubleMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticDoubleMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticDoubleMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticDoubleMethodA", 'D')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticDoubleMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->CallStaticDoubleMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for CallStaticVoidMethod*/
static void JNICALL bda_c2j_proxy_CallStaticVoidMethod(JNIEnv * env, jclass p1, jmethodID p2, ...)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  va_list args;
  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    va_start(awrap.value.ap, p2);
    awrap.type = BDA_VA_LIST;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticVoidMethod")
    && bda_check_no_exeception(s, "CallStaticVoidMethod")
    && bda_check_no_critical(s, "CallStaticVoidMethod")
    && bda_check_non_null(s, p1,  1, "CallStaticVoidMethod")
    && bda_check_non_null(s, p2,  2, "CallStaticVoidMethod")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticVoidMethod")
    && bda_check_jclass(s, p1, 1, "CallStaticVoidMethod")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticVoidMethod", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticVoidMethod;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  va_start(args,p2);
  bda_orig_jni_funcs->CallStaticVoidMethodV(env, p1, p2, args);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for CallStaticVoidMethodV*/
static void JNICALL bda_c2j_proxy_CallStaticVoidMethodV(JNIEnv * env, jclass p1, jmethodID p2, va_list p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_VA_LIST;
     awrap.value.ap = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticVoidMethodV")
    && bda_check_no_exeception(s, "CallStaticVoidMethodV")
    && bda_check_no_critical(s, "CallStaticVoidMethodV")
    && bda_check_non_null(s, p1,  1, "CallStaticVoidMethodV")
    && bda_check_non_null(s, p2,  2, "CallStaticVoidMethodV")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticVoidMethodV")
    && bda_check_jclass(s, p1, 1, "CallStaticVoidMethodV")
    &&  bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticVoidMethodV", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticVoidMethodV;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallStaticVoidMethodV(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for CallStaticVoidMethodA*/
static void JNICALL bda_c2j_proxy_CallStaticVoidMethodA(JNIEnv * env, jclass p1, jmethodID p2, const jvalue * p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;    struct bda_var_arg_wrap awrap;
    awrap.type = BDA_JARRAY;
    awrap.value.array = p3;

    success = 1 
    && bda_check_env_match(s, env, "CallStaticVoidMethodA")
    && bda_check_no_exeception(s, "CallStaticVoidMethodA")
    && bda_check_no_critical(s, "CallStaticVoidMethodA")
    && bda_check_non_null(s, p1,  1, "CallStaticVoidMethodA")
    && bda_check_non_null(s, p2,  2, "CallStaticVoidMethodA")
    && bda_check_ref_dangling(s, p1, 1, "CallStaticVoidMethodA")
    && bda_check_jclass(s, p1, 1, "CallStaticVoidMethodA")
    && bda_check_jmethodid_static(s, p1, p2, awrap, "CallStaticVoidMethodA", 'V')
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_CallStaticVoidMethodA;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_STATIC;
    c2j.object = NULL;
    c2j.class = p1;
    c2j.mid = p2;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->CallStaticVoidMethodA(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for GetStaticFieldID*/
static jfieldID JNICALL bda_c2j_proxy_GetStaticFieldID(JNIEnv * env, jclass p1, const char * p2, const char * p3)
{
  /* local variables */
  jfieldID result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticFieldID")
    && bda_check_no_exeception(s, "GetStaticFieldID")
    && bda_check_no_critical(s, "GetStaticFieldID")
    && bda_check_non_null(s, p1,  1, "GetStaticFieldID")
    && bda_check_non_null(s, p2,  2, "GetStaticFieldID")
    && bda_check_non_null(s, p3,  3, "GetStaticFieldID")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticFieldID")
    && bda_check_jclass(s, p1, 1, "GetStaticFieldID")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticFieldID;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticFieldID(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
       bda_jfieldid_append(s, result, p1, 1, p2, p3);
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetStaticObjectField*/
static jobject JNICALL bda_c2j_proxy_GetStaticObjectField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticObjectField")
    && bda_check_no_exeception(s, "GetStaticObjectField")
    && bda_check_no_critical(s, "GetStaticObjectField")
    && bda_check_non_null(s, p1,  1, "GetStaticObjectField")
    && bda_check_non_null(s, p2,  2, "GetStaticObjectField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticObjectField")
    && bda_check_jclass(s, p1, 1, "GetStaticObjectField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'O', "GetStaticObjectField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticObjectField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticObjectField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "GetStaticObjectField")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetStaticBooleanField*/
static jboolean JNICALL bda_c2j_proxy_GetStaticBooleanField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticBooleanField")
    && bda_check_no_exeception(s, "GetStaticBooleanField")
    && bda_check_no_critical(s, "GetStaticBooleanField")
    && bda_check_non_null(s, p1,  1, "GetStaticBooleanField")
    && bda_check_non_null(s, p2,  2, "GetStaticBooleanField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticBooleanField")
    && bda_check_jclass(s, p1, 1, "GetStaticBooleanField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'Z', "GetStaticBooleanField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticBooleanField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticBooleanField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetStaticByteField*/
static jbyte JNICALL bda_c2j_proxy_GetStaticByteField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jbyte result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticByteField")
    && bda_check_no_exeception(s, "GetStaticByteField")
    && bda_check_no_critical(s, "GetStaticByteField")
    && bda_check_non_null(s, p1,  1, "GetStaticByteField")
    && bda_check_non_null(s, p2,  2, "GetStaticByteField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticByteField")
    && bda_check_jclass(s, p1, 1, "GetStaticByteField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'B', "GetStaticByteField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticByteField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticByteField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetStaticCharField*/
static jchar JNICALL bda_c2j_proxy_GetStaticCharField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jchar result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticCharField")
    && bda_check_no_exeception(s, "GetStaticCharField")
    && bda_check_no_critical(s, "GetStaticCharField")
    && bda_check_non_null(s, p1,  1, "GetStaticCharField")
    && bda_check_non_null(s, p2,  2, "GetStaticCharField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticCharField")
    && bda_check_jclass(s, p1, 1, "GetStaticCharField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'C', "GetStaticCharField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticCharField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticCharField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetStaticShortField*/
static jshort JNICALL bda_c2j_proxy_GetStaticShortField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jshort result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticShortField")
    && bda_check_no_exeception(s, "GetStaticShortField")
    && bda_check_no_critical(s, "GetStaticShortField")
    && bda_check_non_null(s, p1,  1, "GetStaticShortField")
    && bda_check_non_null(s, p2,  2, "GetStaticShortField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticShortField")
    && bda_check_jclass(s, p1, 1, "GetStaticShortField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'S', "GetStaticShortField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticShortField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticShortField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetStaticIntField*/
static jint JNICALL bda_c2j_proxy_GetStaticIntField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticIntField")
    && bda_check_no_exeception(s, "GetStaticIntField")
    && bda_check_no_critical(s, "GetStaticIntField")
    && bda_check_non_null(s, p1,  1, "GetStaticIntField")
    && bda_check_non_null(s, p2,  2, "GetStaticIntField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticIntField")
    && bda_check_jclass(s, p1, 1, "GetStaticIntField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'I', "GetStaticIntField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticIntField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticIntField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetStaticLongField*/
static jlong JNICALL bda_c2j_proxy_GetStaticLongField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticLongField")
    && bda_check_no_exeception(s, "GetStaticLongField")
    && bda_check_no_critical(s, "GetStaticLongField")
    && bda_check_non_null(s, p1,  1, "GetStaticLongField")
    && bda_check_non_null(s, p2,  2, "GetStaticLongField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticLongField")
    && bda_check_jclass(s, p1, 1, "GetStaticLongField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'J', "GetStaticLongField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticLongField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticLongField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetStaticFloatField*/
static jfloat JNICALL bda_c2j_proxy_GetStaticFloatField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jfloat result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticFloatField")
    && bda_check_no_exeception(s, "GetStaticFloatField")
    && bda_check_no_critical(s, "GetStaticFloatField")
    && bda_check_non_null(s, p1,  1, "GetStaticFloatField")
    && bda_check_non_null(s, p2,  2, "GetStaticFloatField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticFloatField")
    && bda_check_jclass(s, p1, 1, "GetStaticFloatField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'F', "GetStaticFloatField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticFloatField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticFloatField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetStaticDoubleField*/
static jdouble JNICALL bda_c2j_proxy_GetStaticDoubleField(JNIEnv * env, jclass p1, jfieldID p2)
{
  /* local variables */
  jdouble result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStaticDoubleField")
    && bda_check_no_exeception(s, "GetStaticDoubleField")
    && bda_check_no_critical(s, "GetStaticDoubleField")
    && bda_check_non_null(s, p1,  1, "GetStaticDoubleField")
    && bda_check_non_null(s, p2,  2, "GetStaticDoubleField")
    && bda_check_ref_dangling(s, p1, 1, "GetStaticDoubleField")
    && bda_check_jclass(s, p1, 1, "GetStaticDoubleField")
    && bda_check_jfieldid_get_static(s, p1, p2, 'D', "GetStaticDoubleField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStaticDoubleField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStaticDoubleField(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for SetStaticObjectField*/
static void JNICALL bda_c2j_proxy_SetStaticObjectField(JNIEnv * env, jclass p1, jfieldID p2, jobject p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.l = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticObjectField")
    && bda_check_no_exeception(s, "SetStaticObjectField")
    && bda_check_no_critical(s, "SetStaticObjectField")
    && bda_check_non_null(s, p1,  1, "SetStaticObjectField")
    && bda_check_non_null(s, p2,  2, "SetStaticObjectField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticObjectField")
    && bda_check_jclass(s, p1, 1, "SetStaticObjectField")
    && bda_check_ref_dangling(s, p3, 3, "SetStaticObjectField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'O', "SetStaticObjectField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticObjectField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticObjectField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticObjectField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetStaticBooleanField*/
static void JNICALL bda_c2j_proxy_SetStaticBooleanField(JNIEnv * env, jclass p1, jfieldID p2, jboolean p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.z = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticBooleanField")
    && bda_check_no_exeception(s, "SetStaticBooleanField")
    && bda_check_no_critical(s, "SetStaticBooleanField")
    && bda_check_non_null(s, p1,  1, "SetStaticBooleanField")
    && bda_check_non_null(s, p2,  2, "SetStaticBooleanField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticBooleanField")
    && bda_check_jclass(s, p1, 1, "SetStaticBooleanField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'Z', "SetStaticBooleanField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticBooleanField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticBooleanField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticBooleanField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetStaticByteField*/
static void JNICALL bda_c2j_proxy_SetStaticByteField(JNIEnv * env, jclass p1, jfieldID p2, jbyte p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.b = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticByteField")
    && bda_check_no_exeception(s, "SetStaticByteField")
    && bda_check_no_critical(s, "SetStaticByteField")
    && bda_check_non_null(s, p1,  1, "SetStaticByteField")
    && bda_check_non_null(s, p2,  2, "SetStaticByteField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticByteField")
    && bda_check_jclass(s, p1, 1, "SetStaticByteField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'B', "SetStaticByteField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticByteField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticByteField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticByteField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetStaticCharField*/
static void JNICALL bda_c2j_proxy_SetStaticCharField(JNIEnv * env, jclass p1, jfieldID p2, jchar p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.c = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticCharField")
    && bda_check_no_exeception(s, "SetStaticCharField")
    && bda_check_no_critical(s, "SetStaticCharField")
    && bda_check_non_null(s, p1,  1, "SetStaticCharField")
    && bda_check_non_null(s, p2,  2, "SetStaticCharField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticCharField")
    && bda_check_jclass(s, p1, 1, "SetStaticCharField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'C', "SetStaticCharField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticCharField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticCharField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticCharField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetStaticShortField*/
static void JNICALL bda_c2j_proxy_SetStaticShortField(JNIEnv * env, jclass p1, jfieldID p2, jshort p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.s = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticShortField")
    && bda_check_no_exeception(s, "SetStaticShortField")
    && bda_check_no_critical(s, "SetStaticShortField")
    && bda_check_non_null(s, p1,  1, "SetStaticShortField")
    && bda_check_non_null(s, p2,  2, "SetStaticShortField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticShortField")
    && bda_check_jclass(s, p1, 1, "SetStaticShortField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'S', "SetStaticShortField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticShortField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticShortField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticShortField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetStaticIntField*/
static void JNICALL bda_c2j_proxy_SetStaticIntField(JNIEnv * env, jclass p1, jfieldID p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.i = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticIntField")
    && bda_check_no_exeception(s, "SetStaticIntField")
    && bda_check_no_critical(s, "SetStaticIntField")
    && bda_check_non_null(s, p1,  1, "SetStaticIntField")
    && bda_check_non_null(s, p2,  2, "SetStaticIntField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticIntField")
    && bda_check_jclass(s, p1, 1, "SetStaticIntField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'I', "SetStaticIntField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticIntField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticIntField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticIntField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetStaticLongField*/
static void JNICALL bda_c2j_proxy_SetStaticLongField(JNIEnv * env, jclass p1, jfieldID p2, jlong p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.j = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticLongField")
    && bda_check_no_exeception(s, "SetStaticLongField")
    && bda_check_no_critical(s, "SetStaticLongField")
    && bda_check_non_null(s, p1,  1, "SetStaticLongField")
    && bda_check_non_null(s, p2,  2, "SetStaticLongField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticLongField")
    && bda_check_jclass(s, p1, 1, "SetStaticLongField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'J', "SetStaticLongField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticLongField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticLongField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticLongField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetStaticFloatField*/
static void JNICALL bda_c2j_proxy_SetStaticFloatField(JNIEnv * env, jclass p1, jfieldID p2, jfloat p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.f = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticFloatField")
    && bda_check_no_exeception(s, "SetStaticFloatField")
    && bda_check_no_critical(s, "SetStaticFloatField")
    && bda_check_non_null(s, p1,  1, "SetStaticFloatField")
    && bda_check_non_null(s, p2,  2, "SetStaticFloatField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticFloatField")
    && bda_check_jclass(s, p1, 1, "SetStaticFloatField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'F', "SetStaticFloatField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticFloatField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticFloatField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticFloatField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetStaticDoubleField*/
static void JNICALL bda_c2j_proxy_SetStaticDoubleField(JNIEnv * env, jclass p1, jfieldID p2, jdouble p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;         jvalue v;
         v.d = p3;

    success = 1 
    && bda_check_env_match(s, env, "SetStaticDoubleField")
    && bda_check_no_exeception(s, "SetStaticDoubleField")
    && bda_check_no_critical(s, "SetStaticDoubleField")
    && bda_check_non_null(s, p1,  1, "SetStaticDoubleField")
    && bda_check_non_null(s, p2,  2, "SetStaticDoubleField")
    && bda_check_ref_dangling(s, p1, 1, "SetStaticDoubleField")
    && bda_check_jclass(s, p1, 1, "SetStaticDoubleField")
    && bda_check_jfieldid_set_static(s, p1, p2, v, 'D', "SetStaticDoubleField")
    && bda_check_access_set_static_field(s, p1, p2, 2, "SetStaticDoubleField")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetStaticDoubleField;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetStaticDoubleField(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for NewString*/
static jstring JNICALL bda_c2j_proxy_NewString(JNIEnv * env, const jchar * p1, jsize p2)
{
  /* local variables */
  jstring result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewString")
    && bda_check_no_exeception(s, "NewString")
    && bda_check_no_critical(s, "NewString")
    && bda_check_non_null(s, p1,  1, "NewString")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewString;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewString(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewString")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetStringLength*/
static jsize JNICALL bda_c2j_proxy_GetStringLength(JNIEnv * env, jstring p1)
{
  /* local variables */
  jsize result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringLength")
    && bda_check_no_exeception(s, "GetStringLength")
    && bda_check_no_critical(s, "GetStringLength")
    && bda_check_non_null(s, p1,  1, "GetStringLength")
    && bda_check_ref_dangling(s, p1, 1, "GetStringLength")
    && bda_check_jstring(s, p1, 1, "GetStringLength")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringLength;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStringLength(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetStringChars*/
static const jchar * JNICALL bda_c2j_proxy_GetStringChars(JNIEnv * env, jstring p1, jboolean * p2)
{
  /* local variables */
  const jchar * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringChars")
    && bda_check_no_exeception(s, "GetStringChars")
    && bda_check_no_critical(s, "GetStringChars")
    && bda_check_non_null(s, p1,  1, "GetStringChars")
    && bda_check_ref_dangling(s, p1, 1, "GetStringChars")
    && bda_check_jstring(s, p1, 1, "GetStringChars")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringChars;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStringChars(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetStringChars");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for ReleaseStringChars*/
static void JNICALL bda_c2j_proxy_ReleaseStringChars(JNIEnv * env, jstring p1, const jchar * p2)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseStringChars")
    && bda_check_no_critical(s, "ReleaseStringChars")
    && bda_check_non_null(s, p1,  1, "ReleaseStringChars")
    && bda_check_non_null(s, p2,  2, "ReleaseStringChars")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseStringChars"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jstring(s, p1, 1, "ReleaseStringChars"))
    && bda_check_resource_free(s, p2, "ReleaseStringChars")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseStringChars;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseStringChars(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    bda_resource_release(s, p2, "ReleaseStringChars");
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for NewStringUTF*/
static jstring JNICALL bda_c2j_proxy_NewStringUTF(JNIEnv * env, const char * p1)
{
  /* local variables */
  jstring result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewStringUTF")
    && bda_check_no_exeception(s, "NewStringUTF")
    && bda_check_no_critical(s, "NewStringUTF")
    && bda_check_non_null(s, p1,  1, "NewStringUTF")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewStringUTF;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewStringUTF(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewStringUTF")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetStringUTFLength*/
static jsize JNICALL bda_c2j_proxy_GetStringUTFLength(JNIEnv * env, jstring p1)
{
  /* local variables */
  jsize result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringUTFLength")
    && bda_check_no_exeception(s, "GetStringUTFLength")
    && bda_check_no_critical(s, "GetStringUTFLength")
    && bda_check_non_null(s, p1,  1, "GetStringUTFLength")
    && bda_check_ref_dangling(s, p1, 1, "GetStringUTFLength")
    && bda_check_jstring(s, p1, 1, "GetStringUTFLength")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringUTFLength;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStringUTFLength(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetStringUTFChars*/
static const char * JNICALL bda_c2j_proxy_GetStringUTFChars(JNIEnv * env, jstring p1, jboolean * p2)
{
  /* local variables */
  const char * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringUTFChars")
    && bda_check_no_exeception(s, "GetStringUTFChars")
    && bda_check_no_critical(s, "GetStringUTFChars")
    && bda_check_non_null(s, p1,  1, "GetStringUTFChars")
    && bda_check_ref_dangling(s, p1, 1, "GetStringUTFChars")
    && bda_check_jstring(s, p1, 1, "GetStringUTFChars")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringUTFChars;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStringUTFChars(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetStringUTFChars");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for ReleaseStringUTFChars*/
static void JNICALL bda_c2j_proxy_ReleaseStringUTFChars(JNIEnv * env, jstring p1, const char * p2)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseStringUTFChars")
    && bda_check_no_critical(s, "ReleaseStringUTFChars")
    && bda_check_non_null(s, p1,  1, "ReleaseStringUTFChars")
    && bda_check_non_null(s, p2,  2, "ReleaseStringUTFChars")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseStringUTFChars"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jstring(s, p1, 1, "ReleaseStringUTFChars"))
    && bda_check_resource_free(s, p2, "ReleaseStringUTFChars")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseStringUTFChars;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseStringUTFChars(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    bda_resource_release(s, p2, "ReleaseStringUTFChars");
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for GetArrayLength*/
static jsize JNICALL bda_c2j_proxy_GetArrayLength(JNIEnv * env, jarray p1)
{
  /* local variables */
  jsize result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetArrayLength")
    && bda_check_no_exeception(s, "GetArrayLength")
    && bda_check_no_critical(s, "GetArrayLength")
    && bda_check_non_null(s, p1,  1, "GetArrayLength")
    && bda_check_ref_dangling(s, p1, 1, "GetArrayLength")
    && bda_check_jarray(s, p1, 1, "GetArrayLength")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetArrayLength;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetArrayLength(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for NewObjectArray*/
static jobjectArray JNICALL bda_c2j_proxy_NewObjectArray(JNIEnv * env, jsize p1, jclass p2, jobject p3)
{
  /* local variables */
  jobjectArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewObjectArray")
    && bda_check_no_exeception(s, "NewObjectArray")
    && bda_check_no_critical(s, "NewObjectArray")
    && bda_check_non_null(s, p2,  2, "NewObjectArray")
    && bda_check_ref_dangling(s, p2, 2, "NewObjectArray")
    && bda_check_jclass(s, p2, 2, "NewObjectArray")
    && bda_check_ref_dangling(s, p3, 3, "NewObjectArray")
    && bda_check_assignable_jclass_jobject(s, p2, p3, 2, "NewObjectArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewObjectArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewObjectArray(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewObjectArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetObjectArrayElement*/
static jobject JNICALL bda_c2j_proxy_GetObjectArrayElement(JNIEnv * env, jobjectArray p1, jsize p2)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetObjectArrayElement")
    && bda_check_no_exeception(s, "GetObjectArrayElement")
    && bda_check_no_critical(s, "GetObjectArrayElement")
    && bda_check_non_null(s, p1,  1, "GetObjectArrayElement")
    && bda_check_ref_dangling(s, p1, 1, "GetObjectArrayElement")
    && bda_check_jobjectArray(s, p1, 1, "GetObjectArrayElement")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetObjectArrayElement;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetObjectArrayElement(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "GetObjectArrayElement")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for SetObjectArrayElement*/
static void JNICALL bda_c2j_proxy_SetObjectArrayElement(JNIEnv * env, jobjectArray p1, jsize p2, jobject p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetObjectArrayElement")
    && bda_check_no_exeception(s, "SetObjectArrayElement")
    && bda_check_no_critical(s, "SetObjectArrayElement")
    && bda_check_non_null(s, p1,  1, "SetObjectArrayElement")
    && bda_check_non_null(s, p3,  3, "SetObjectArrayElement")
    && bda_check_ref_dangling(s, p1, 1, "SetObjectArrayElement")
    && bda_check_jobjectArray(s, p1, 1, "SetObjectArrayElement")
    && bda_check_ref_dangling(s, p3, 3, "SetObjectArrayElement")
    && bda_check_assignable_jobjectArray_jobject(s, p1, p3, 3,  "SetObjectArrayElement")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetObjectArrayElement;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetObjectArrayElement(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for NewBooleanArray*/
static jbooleanArray JNICALL bda_c2j_proxy_NewBooleanArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jbooleanArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewBooleanArray")
    && bda_check_no_exeception(s, "NewBooleanArray")
    && bda_check_no_critical(s, "NewBooleanArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewBooleanArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewBooleanArray(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewBooleanArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for NewByteArray*/
static jbyteArray JNICALL bda_c2j_proxy_NewByteArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jbyteArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewByteArray")
    && bda_check_no_exeception(s, "NewByteArray")
    && bda_check_no_critical(s, "NewByteArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewByteArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewByteArray(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewByteArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for NewCharArray*/
static jcharArray JNICALL bda_c2j_proxy_NewCharArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jcharArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewCharArray")
    && bda_check_no_exeception(s, "NewCharArray")
    && bda_check_no_critical(s, "NewCharArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewCharArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewCharArray(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewCharArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for NewShortArray*/
static jshortArray JNICALL bda_c2j_proxy_NewShortArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jshortArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewShortArray")
    && bda_check_no_exeception(s, "NewShortArray")
    && bda_check_no_critical(s, "NewShortArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewShortArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewShortArray(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewShortArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for NewIntArray*/
static jintArray JNICALL bda_c2j_proxy_NewIntArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jintArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewIntArray")
    && bda_check_no_exeception(s, "NewIntArray")
    && bda_check_no_critical(s, "NewIntArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewIntArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewIntArray(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewIntArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for NewLongArray*/
static jlongArray JNICALL bda_c2j_proxy_NewLongArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jlongArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewLongArray")
    && bda_check_no_exeception(s, "NewLongArray")
    && bda_check_no_critical(s, "NewLongArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewLongArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewLongArray(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewLongArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for NewFloatArray*/
static jfloatArray JNICALL bda_c2j_proxy_NewFloatArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jfloatArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewFloatArray")
    && bda_check_no_exeception(s, "NewFloatArray")
    && bda_check_no_critical(s, "NewFloatArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewFloatArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewFloatArray(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewFloatArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for NewDoubleArray*/
static jdoubleArray JNICALL bda_c2j_proxy_NewDoubleArray(JNIEnv * env, jsize p1)
{
  /* local variables */
  jdoubleArray result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewDoubleArray")
    && bda_check_no_exeception(s, "NewDoubleArray")
    && bda_check_no_critical(s, "NewDoubleArray")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewDoubleArray;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewDoubleArray(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewDoubleArray")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetBooleanArrayElements*/
static jboolean * JNICALL bda_c2j_proxy_GetBooleanArrayElements(JNIEnv * env, jbooleanArray p1, jboolean * p2)
{
  /* local variables */
  jboolean * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetBooleanArrayElements")
    && bda_check_no_exeception(s, "GetBooleanArrayElements")
    && bda_check_no_critical(s, "GetBooleanArrayElements")
    && bda_check_non_null(s, p1,  1, "GetBooleanArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetBooleanArrayElements")
    && bda_check_jbooleanArray(s, p1, 1, "GetBooleanArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetBooleanArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetBooleanArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetBooleanArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetByteArrayElements*/
static jbyte * JNICALL bda_c2j_proxy_GetByteArrayElements(JNIEnv * env, jbyteArray p1, jboolean * p2)
{
  /* local variables */
  jbyte * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetByteArrayElements")
    && bda_check_no_exeception(s, "GetByteArrayElements")
    && bda_check_no_critical(s, "GetByteArrayElements")
    && bda_check_non_null(s, p1,  1, "GetByteArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetByteArrayElements")
    && bda_check_jbyteArray(s, p1, 1, "GetByteArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetByteArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetByteArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetByteArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetCharArrayElements*/
static jchar * JNICALL bda_c2j_proxy_GetCharArrayElements(JNIEnv * env, jcharArray p1, jboolean * p2)
{
  /* local variables */
  jchar * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetCharArrayElements")
    && bda_check_no_exeception(s, "GetCharArrayElements")
    && bda_check_no_critical(s, "GetCharArrayElements")
    && bda_check_non_null(s, p1,  1, "GetCharArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetCharArrayElements")
    && bda_check_jcharArray(s, p1, 1, "GetCharArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetCharArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetCharArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetCharArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetShortArrayElements*/
static jshort * JNICALL bda_c2j_proxy_GetShortArrayElements(JNIEnv * env, jshortArray p1, jboolean * p2)
{
  /* local variables */
  jshort * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetShortArrayElements")
    && bda_check_no_exeception(s, "GetShortArrayElements")
    && bda_check_no_critical(s, "GetShortArrayElements")
    && bda_check_non_null(s, p1,  1, "GetShortArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetShortArrayElements")
    && bda_check_jshortArray(s, p1, 1, "GetShortArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetShortArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetShortArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetShortArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetIntArrayElements*/
static jint * JNICALL bda_c2j_proxy_GetIntArrayElements(JNIEnv * env, jintArray p1, jboolean * p2)
{
  /* local variables */
  jint * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetIntArrayElements")
    && bda_check_no_exeception(s, "GetIntArrayElements")
    && bda_check_no_critical(s, "GetIntArrayElements")
    && bda_check_non_null(s, p1,  1, "GetIntArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetIntArrayElements")
    && bda_check_jintArray(s, p1, 1, "GetIntArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetIntArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetIntArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetIntArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetLongArrayElements*/
static jlong * JNICALL bda_c2j_proxy_GetLongArrayElements(JNIEnv * env, jlongArray p1, jboolean * p2)
{
  /* local variables */
  jlong * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetLongArrayElements")
    && bda_check_no_exeception(s, "GetLongArrayElements")
    && bda_check_no_critical(s, "GetLongArrayElements")
    && bda_check_non_null(s, p1,  1, "GetLongArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetLongArrayElements")
    && bda_check_jlongArray(s, p1, 1, "GetLongArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetLongArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetLongArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetLongArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetFloatArrayElements*/
static jfloat * JNICALL bda_c2j_proxy_GetFloatArrayElements(JNIEnv * env, jfloatArray p1, jboolean * p2)
{
  /* local variables */
  jfloat * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetFloatArrayElements")
    && bda_check_no_exeception(s, "GetFloatArrayElements")
    && bda_check_no_critical(s, "GetFloatArrayElements")
    && bda_check_non_null(s, p1,  1, "GetFloatArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetFloatArrayElements")
    && bda_check_jfloatArray(s, p1, 1, "GetFloatArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetFloatArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetFloatArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetFloatArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetDoubleArrayElements*/
static jdouble * JNICALL bda_c2j_proxy_GetDoubleArrayElements(JNIEnv * env, jdoubleArray p1, jboolean * p2)
{
  /* local variables */
  jdouble * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetDoubleArrayElements")
    && bda_check_no_exeception(s, "GetDoubleArrayElements")
    && bda_check_no_critical(s, "GetDoubleArrayElements")
    && bda_check_non_null(s, p1,  1, "GetDoubleArrayElements")
    && bda_check_ref_dangling(s, p1, 1, "GetDoubleArrayElements")
    && bda_check_jdoubleArray(s, p1, 1, "GetDoubleArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetDoubleArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetDoubleArrayElements(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if (result != NULL) {bda_resource_acquire(s, result, "GetDoubleArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for ReleaseBooleanArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseBooleanArrayElements(JNIEnv * env, jbooleanArray p1, jboolean * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseBooleanArrayElements")
    && bda_check_no_critical(s, "ReleaseBooleanArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseBooleanArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseBooleanArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseBooleanArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jbooleanArray(s, p1, 1, "ReleaseBooleanArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseBooleanArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseBooleanArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseBooleanArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseBooleanArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for ReleaseByteArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseByteArrayElements(JNIEnv * env, jbyteArray p1, jbyte * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseByteArrayElements")
    && bda_check_no_critical(s, "ReleaseByteArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseByteArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseByteArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseByteArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jbyteArray(s, p1, 1, "ReleaseByteArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseByteArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseByteArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseByteArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseByteArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for ReleaseCharArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseCharArrayElements(JNIEnv * env, jcharArray p1, jchar * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseCharArrayElements")
    && bda_check_no_critical(s, "ReleaseCharArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseCharArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseCharArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseCharArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jcharArray(s, p1, 1, "ReleaseCharArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseCharArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseCharArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseCharArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseCharArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for ReleaseShortArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseShortArrayElements(JNIEnv * env, jshortArray p1, jshort * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseShortArrayElements")
    && bda_check_no_critical(s, "ReleaseShortArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseShortArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseShortArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseShortArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jshortArray(s, p1, 1, "ReleaseShortArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseShortArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseShortArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseShortArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseShortArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for ReleaseIntArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseIntArrayElements(JNIEnv * env, jintArray p1, jint * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseIntArrayElements")
    && bda_check_no_critical(s, "ReleaseIntArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseIntArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseIntArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseIntArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jintArray(s, p1, 1, "ReleaseIntArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseIntArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseIntArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseIntArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseIntArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for ReleaseLongArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseLongArrayElements(JNIEnv * env, jlongArray p1, jlong * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseLongArrayElements")
    && bda_check_no_critical(s, "ReleaseLongArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseLongArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseLongArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseLongArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jlongArray(s, p1, 1, "ReleaseLongArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseLongArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseLongArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseLongArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseLongArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for ReleaseFloatArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseFloatArrayElements(JNIEnv * env, jfloatArray p1, jfloat * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseFloatArrayElements")
    && bda_check_no_critical(s, "ReleaseFloatArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseFloatArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseFloatArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseFloatArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jfloatArray(s, p1, 1, "ReleaseFloatArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseFloatArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseFloatArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseFloatArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseFloatArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for ReleaseDoubleArrayElements*/
static void JNICALL bda_c2j_proxy_ReleaseDoubleArrayElements(JNIEnv * env, jdoubleArray p1, jdouble * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseDoubleArrayElements")
    && bda_check_no_critical(s, "ReleaseDoubleArrayElements")
    && bda_check_non_null(s, p1,  1, "ReleaseDoubleArrayElements")
    && bda_check_non_null(s, p2,  2, "ReleaseDoubleArrayElements")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseDoubleArrayElements"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jdoubleArray(s, p1, 1, "ReleaseDoubleArrayElements"))
    && bda_check_resource_free(s, p2, "ReleaseDoubleArrayElements")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseDoubleArrayElements;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseDoubleArrayElements(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    if ( p3 != JNI_COMMIT) {bda_resource_release(s, p2, "ReleaseDoubleArrayElements");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for GetBooleanArrayRegion*/
static void JNICALL bda_c2j_proxy_GetBooleanArrayRegion(JNIEnv * env, jbooleanArray p1, jsize p2, jsize p3, jboolean * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetBooleanArrayRegion")
    && bda_check_no_exeception(s, "GetBooleanArrayRegion")
    && bda_check_no_critical(s, "GetBooleanArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetBooleanArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetBooleanArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetBooleanArrayRegion")
    && bda_check_jbooleanArray(s, p1, 1, "GetBooleanArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetBooleanArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetBooleanArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for GetByteArrayRegion*/
static void JNICALL bda_c2j_proxy_GetByteArrayRegion(JNIEnv * env, jbyteArray p1, jsize p2, jsize p3, jbyte * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetByteArrayRegion")
    && bda_check_no_exeception(s, "GetByteArrayRegion")
    && bda_check_no_critical(s, "GetByteArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetByteArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetByteArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetByteArrayRegion")
    && bda_check_jbyteArray(s, p1, 1, "GetByteArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetByteArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetByteArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for GetCharArrayRegion*/
static void JNICALL bda_c2j_proxy_GetCharArrayRegion(JNIEnv * env, jcharArray p1, jsize p2, jsize p3, jchar * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetCharArrayRegion")
    && bda_check_no_exeception(s, "GetCharArrayRegion")
    && bda_check_no_critical(s, "GetCharArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetCharArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetCharArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetCharArrayRegion")
    && bda_check_jcharArray(s, p1, 1, "GetCharArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetCharArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetCharArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for GetShortArrayRegion*/
static void JNICALL bda_c2j_proxy_GetShortArrayRegion(JNIEnv * env, jshortArray p1, jsize p2, jsize p3, jshort * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetShortArrayRegion")
    && bda_check_no_exeception(s, "GetShortArrayRegion")
    && bda_check_no_critical(s, "GetShortArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetShortArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetShortArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetShortArrayRegion")
    && bda_check_jshortArray(s, p1, 1, "GetShortArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetShortArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetShortArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for GetIntArrayRegion*/
static void JNICALL bda_c2j_proxy_GetIntArrayRegion(JNIEnv * env, jintArray p1, jsize p2, jsize p3, jint * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetIntArrayRegion")
    && bda_check_no_exeception(s, "GetIntArrayRegion")
    && bda_check_no_critical(s, "GetIntArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetIntArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetIntArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetIntArrayRegion")
    && bda_check_jintArray(s, p1, 1, "GetIntArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetIntArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetIntArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for GetLongArrayRegion*/
static void JNICALL bda_c2j_proxy_GetLongArrayRegion(JNIEnv * env, jlongArray p1, jsize p2, jsize p3, jlong * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetLongArrayRegion")
    && bda_check_no_exeception(s, "GetLongArrayRegion")
    && bda_check_no_critical(s, "GetLongArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetLongArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetLongArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetLongArrayRegion")
    && bda_check_jlongArray(s, p1, 1, "GetLongArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetLongArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetLongArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for GetFloatArrayRegion*/
static void JNICALL bda_c2j_proxy_GetFloatArrayRegion(JNIEnv * env, jfloatArray p1, jsize p2, jsize p3, jfloat * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetFloatArrayRegion")
    && bda_check_no_exeception(s, "GetFloatArrayRegion")
    && bda_check_no_critical(s, "GetFloatArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetFloatArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetFloatArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetFloatArrayRegion")
    && bda_check_jfloatArray(s, p1, 1, "GetFloatArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetFloatArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetFloatArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for GetDoubleArrayRegion*/
static void JNICALL bda_c2j_proxy_GetDoubleArrayRegion(JNIEnv * env, jdoubleArray p1, jsize p2, jsize p3, jdouble * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetDoubleArrayRegion")
    && bda_check_no_exeception(s, "GetDoubleArrayRegion")
    && bda_check_no_critical(s, "GetDoubleArrayRegion")
    && bda_check_non_null(s, p1,  1, "GetDoubleArrayRegion")
    && bda_check_non_null(s, p4,  4, "GetDoubleArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetDoubleArrayRegion")
    && bda_check_jdoubleArray(s, p1, 1, "GetDoubleArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetDoubleArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetDoubleArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetBooleanArrayRegion*/
static void JNICALL bda_c2j_proxy_SetBooleanArrayRegion(JNIEnv * env, jbooleanArray p1, jsize p2, jsize p3, const jboolean * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetBooleanArrayRegion")
    && bda_check_no_exeception(s, "SetBooleanArrayRegion")
    && bda_check_no_critical(s, "SetBooleanArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetBooleanArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetBooleanArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetBooleanArrayRegion")
    && bda_check_jbooleanArray(s, p1, 1, "SetBooleanArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetBooleanArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetBooleanArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetByteArrayRegion*/
static void JNICALL bda_c2j_proxy_SetByteArrayRegion(JNIEnv * env, jbyteArray p1, jsize p2, jsize p3, const jbyte * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetByteArrayRegion")
    && bda_check_no_exeception(s, "SetByteArrayRegion")
    && bda_check_no_critical(s, "SetByteArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetByteArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetByteArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetByteArrayRegion")
    && bda_check_jbyteArray(s, p1, 1, "SetByteArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetByteArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetByteArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetCharArrayRegion*/
static void JNICALL bda_c2j_proxy_SetCharArrayRegion(JNIEnv * env, jcharArray p1, jsize p2, jsize p3, const jchar * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetCharArrayRegion")
    && bda_check_no_exeception(s, "SetCharArrayRegion")
    && bda_check_no_critical(s, "SetCharArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetCharArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetCharArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetCharArrayRegion")
    && bda_check_jcharArray(s, p1, 1, "SetCharArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetCharArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetCharArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetShortArrayRegion*/
static void JNICALL bda_c2j_proxy_SetShortArrayRegion(JNIEnv * env, jshortArray p1, jsize p2, jsize p3, const jshort * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetShortArrayRegion")
    && bda_check_no_exeception(s, "SetShortArrayRegion")
    && bda_check_no_critical(s, "SetShortArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetShortArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetShortArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetShortArrayRegion")
    && bda_check_jshortArray(s, p1, 1, "SetShortArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetShortArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetShortArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetIntArrayRegion*/
static void JNICALL bda_c2j_proxy_SetIntArrayRegion(JNIEnv * env, jintArray p1, jsize p2, jsize p3, const jint * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetIntArrayRegion")
    && bda_check_no_exeception(s, "SetIntArrayRegion")
    && bda_check_no_critical(s, "SetIntArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetIntArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetIntArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetIntArrayRegion")
    && bda_check_jintArray(s, p1, 1, "SetIntArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetIntArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetIntArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetLongArrayRegion*/
static void JNICALL bda_c2j_proxy_SetLongArrayRegion(JNIEnv * env, jlongArray p1, jsize p2, jsize p3, const jlong * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetLongArrayRegion")
    && bda_check_no_exeception(s, "SetLongArrayRegion")
    && bda_check_no_critical(s, "SetLongArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetLongArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetLongArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetLongArrayRegion")
    && bda_check_jlongArray(s, p1, 1, "SetLongArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetLongArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetLongArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetFloatArrayRegion*/
static void JNICALL bda_c2j_proxy_SetFloatArrayRegion(JNIEnv * env, jfloatArray p1, jsize p2, jsize p3, const jfloat * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetFloatArrayRegion")
    && bda_check_no_exeception(s, "SetFloatArrayRegion")
    && bda_check_no_critical(s, "SetFloatArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetFloatArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetFloatArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetFloatArrayRegion")
    && bda_check_jfloatArray(s, p1, 1, "SetFloatArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetFloatArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetFloatArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for SetDoubleArrayRegion*/
static void JNICALL bda_c2j_proxy_SetDoubleArrayRegion(JNIEnv * env, jdoubleArray p1, jsize p2, jsize p3, const jdouble * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "SetDoubleArrayRegion")
    && bda_check_no_exeception(s, "SetDoubleArrayRegion")
    && bda_check_no_critical(s, "SetDoubleArrayRegion")
    && bda_check_non_null(s, p1,  1, "SetDoubleArrayRegion")
    && bda_check_non_null(s, p4,  4, "SetDoubleArrayRegion")
    && bda_check_ref_dangling(s, p1, 1, "SetDoubleArrayRegion")
    && bda_check_jdoubleArray(s, p1, 1, "SetDoubleArrayRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_SetDoubleArrayRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->SetDoubleArrayRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for RegisterNatives*/
static jint JNICALL bda_c2j_proxy_RegisterNatives(JNIEnv * env, jclass p1, const JNINativeMethod * p2, jint p3)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "RegisterNatives")
    && bda_check_no_exeception(s, "RegisterNatives")
    && bda_check_no_critical(s, "RegisterNatives")
    && bda_check_non_null(s, p1,  1, "RegisterNatives")
    && bda_check_non_null(s, p2,  2, "RegisterNatives")
    && bda_check_ref_dangling(s, p1, 1, "RegisterNatives")
    && bda_check_jclass(s, p1, 1, "RegisterNatives")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_RegisterNatives;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->RegisterNatives(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for UnregisterNatives*/
static jint JNICALL bda_c2j_proxy_UnregisterNatives(JNIEnv * env, jclass p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "UnregisterNatives")
    && bda_check_no_exeception(s, "UnregisterNatives")
    && bda_check_no_critical(s, "UnregisterNatives")
    && bda_check_non_null(s, p1,  1, "UnregisterNatives")
    && bda_check_ref_dangling(s, p1, 1, "UnregisterNatives")
    && bda_check_jclass(s, p1, 1, "UnregisterNatives")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_UnregisterNatives;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->UnregisterNatives(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for MonitorEnter*/
static jint JNICALL bda_c2j_proxy_MonitorEnter(JNIEnv * env, jobject p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "MonitorEnter")
    && bda_check_no_exeception(s, "MonitorEnter")
    && bda_check_no_critical(s, "MonitorEnter")
    && bda_check_non_null(s, p1,  1, "MonitorEnter")
    && bda_check_ref_dangling(s, p1, 1, "MonitorEnter")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_MonitorEnter;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->MonitorEnter(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result == 0) {
     bda_monitor_enter(s, p1);
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for MonitorExit*/
static jint JNICALL bda_c2j_proxy_MonitorExit(JNIEnv * env, jobject p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "MonitorExit")
    && bda_check_no_critical(s, "MonitorExit")
    && bda_check_non_null(s, p1,  1, "MonitorExit")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "MonitorExit"))
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_MonitorExit;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->MonitorExit(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result == 0) {
     bda_monitor_exit(s, p1);
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetJavaVM*/
static jint JNICALL bda_c2j_proxy_GetJavaVM(JNIEnv * env, JavaVM ** p1)
{
  /* local variables */
  jint result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetJavaVM")
    && bda_check_no_exeception(s, "GetJavaVM")
    && bda_check_no_critical(s, "GetJavaVM")
    && bda_check_non_null(s, p1,  1, "GetJavaVM")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetJavaVM;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetJavaVM(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetStringRegion*/
static void JNICALL bda_c2j_proxy_GetStringRegion(JNIEnv * env, jstring p1, jsize p2, jsize p3, jchar * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringRegion")
    && bda_check_no_exeception(s, "GetStringRegion")
    && bda_check_no_critical(s, "GetStringRegion")
    && bda_check_non_null(s, p1,  1, "GetStringRegion")
    && bda_check_non_null(s, p4,  4, "GetStringRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetStringRegion")
    && bda_check_jstring(s, p1, 1, "GetStringRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetStringRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for GetStringUTFRegion*/
static void JNICALL bda_c2j_proxy_GetStringUTFRegion(JNIEnv * env, jstring p1, jsize p2, jsize p3, char * p4)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringUTFRegion")
    && bda_check_no_exeception(s, "GetStringUTFRegion")
    && bda_check_no_critical(s, "GetStringUTFRegion")
    && bda_check_non_null(s, p1,  1, "GetStringUTFRegion")
    && bda_check_non_null(s, p4,  4, "GetStringUTFRegion")
    && bda_check_ref_dangling(s, p1, 1, "GetStringUTFRegion")
    && bda_check_jstring(s, p1, 1, "GetStringUTFRegion")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringUTFRegion;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->GetStringUTFRegion(env, p1, p2, p3, p4);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for GetPrimitiveArrayCritical*/
static void * JNICALL bda_c2j_proxy_GetPrimitiveArrayCritical(JNIEnv * env, jarray p1, jboolean * p2)
{
  /* local variables */
  void * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetPrimitiveArrayCritical")
    && bda_check_no_exeception(s, "GetPrimitiveArrayCritical")
    && bda_check_non_null(s, p1,  1, "GetPrimitiveArrayCritical")
    && bda_check_ref_dangling(s, p1, 1, "GetPrimitiveArrayCritical")
    && bda_check_jarray(s, p1, 1, "GetPrimitiveArrayCritical")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetPrimitiveArrayCritical;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetPrimitiveArrayCritical(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    bda_enter_critical(s, (void*)result);
    if (result != NULL) {bda_resource_acquire(s, result, "GetPrimitiveArrayCritical");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for ReleasePrimitiveArrayCritical*/
static void JNICALL bda_c2j_proxy_ReleasePrimitiveArrayCritical(JNIEnv * env, jarray p1, void * p2, jint p3)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleasePrimitiveArrayCritical")
    && bda_check_non_null(s, p1,  1, "ReleasePrimitiveArrayCritical")
    && bda_check_non_null(s, p2,  2, "ReleasePrimitiveArrayCritical")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleasePrimitiveArrayCritical"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jarray(s, p1, 1, "ReleasePrimitiveArrayCritical"))
    && bda_check_resource_free(s, p2, "ReleasePrimitiveArrayCritical")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleasePrimitiveArrayCritical;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleasePrimitiveArrayCritical(env, p1, p2, p3);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    bda_leave_critical(s, (void*)p2);
    bda_resource_release(s, p2, "ReleasePrimitiveArrayCritical");
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for GetStringCritical*/
static const jchar * JNICALL bda_c2j_proxy_GetStringCritical(JNIEnv * env, jstring p1, jboolean * p2)
{
  /* local variables */
  const jchar * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetStringCritical")
    && bda_check_no_exeception(s, "GetStringCritical")
    && bda_check_non_null(s, p1,  1, "GetStringCritical")
    && bda_check_ref_dangling(s, p1, 1, "GetStringCritical")
    && bda_check_jstring(s, p1, 1, "GetStringCritical")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetStringCritical;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetStringCritical(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    bda_enter_critical(s, (void*)result);
    if (result != NULL) {bda_resource_acquire(s, result, "GetStringCritical");}
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for ReleaseStringCritical*/
static void JNICALL bda_c2j_proxy_ReleaseStringCritical(JNIEnv * env, jstring p1, const jchar * p2)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ReleaseStringCritical")
    && bda_check_non_null(s, p1,  1, "ReleaseStringCritical")
    && bda_check_non_null(s, p2,  2, "ReleaseStringCritical")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "ReleaseStringCritical"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jstring(s, p1, 1, "ReleaseStringCritical"))
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ReleaseStringCritical;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->ReleaseStringCritical(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
    bda_leave_critical(s, (void*)p2);
    bda_resource_release(s, p2, "ReleaseStringCritical");
  }

  if ((s != NULL) && agent_options.jinn) {
  }

}


/* proxy for NewWeakGlobalRef*/
static jweak JNICALL bda_c2j_proxy_NewWeakGlobalRef(JNIEnv * env, jobject p1)
{
  /* local variables */
  jweak result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewWeakGlobalRef")
    && bda_check_no_exeception(s, "NewWeakGlobalRef")
    && bda_check_no_critical(s, "NewWeakGlobalRef")
    && bda_check_non_null(s, p1,  1, "NewWeakGlobalRef")
    && bda_check_ref_dangling(s, p1, 1, "NewWeakGlobalRef")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewWeakGlobalRef;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewWeakGlobalRef(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
    if (result != NULL) {
      bda_global_ref_add(result, 1);
    }
  }

  return result;
}


/* proxy for DeleteWeakGlobalRef*/
static void JNICALL bda_c2j_proxy_DeleteWeakGlobalRef(JNIEnv * env, jweak p1)
{
  /* local variables */
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "DeleteWeakGlobalRef")
    && bda_check_no_critical(s, "DeleteWeakGlobalRef")
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_ref_dangling(s, p1, 1, "DeleteWeakGlobalRef"))
    && (bda_orig_jni_funcs->ExceptionCheck(env) || bda_check_jweak(s, p1, 1, "DeleteWeakGlobalRef"))
    && bda_check_jobject_ref_type(s, p1, JNIWeakGlobalRefType , 1, "DeleteWeakGlobalRef")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_DeleteWeakGlobalRef;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
   bda_orig_jni_funcs->DeleteWeakGlobalRef(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
   bda_global_ref_delete(p1, 1);
  }

}


/* proxy for ExceptionCheck*/
static jboolean JNICALL bda_c2j_proxy_ExceptionCheck(JNIEnv * env)
{
  /* local variables */
  jboolean result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "ExceptionCheck")
    && bda_check_no_critical(s, "ExceptionCheck")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn)&& !success){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_ExceptionCheck;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->ExceptionCheck(env);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for NewDirectByteBuffer*/
static jobject JNICALL bda_c2j_proxy_NewDirectByteBuffer(JNIEnv * env, void * p1, jlong p2)
{
  /* local variables */
  jobject result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "NewDirectByteBuffer")
    && bda_check_no_exeception(s, "NewDirectByteBuffer")
    && bda_check_no_critical(s, "NewDirectByteBuffer")
    && bda_check_non_null(s, p1,  1, "NewDirectByteBuffer")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_NewDirectByteBuffer;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->NewDirectByteBuffer(env, p1, p2);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
   if (result != NULL) {
      if (!bda_check_local_frame_overflow(s, "NewDirectByteBuffer")) {
         bda_orig_jni_funcs->DeleteLocalRef(env, result);
         result = NULL;
      } else {
         bda_local_ref_add(s, result);
      }
   }
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetDirectBufferAddress*/
static void * JNICALL bda_c2j_proxy_GetDirectBufferAddress(JNIEnv * env, jobject p1)
{
  /* local variables */
  void * result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetDirectBufferAddress")
    && bda_check_no_exeception(s, "GetDirectBufferAddress")
    && bda_check_no_critical(s, "GetDirectBufferAddress")
    && bda_check_non_null(s, p1,  1, "GetDirectBufferAddress")
    && bda_check_ref_dangling(s, p1, 1, "GetDirectBufferAddress")
    && bda_check_assignable_jobject_jclass(s, p1, bda_clazz_nio_buffer, 1, "GetDirectBufferAddress")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetDirectBufferAddress;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetDirectBufferAddress(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetDirectBufferCapacity*/
static jlong JNICALL bda_c2j_proxy_GetDirectBufferCapacity(JNIEnv * env, jobject p1)
{
  /* local variables */
  jlong result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetDirectBufferCapacity")
    && bda_check_no_exeception(s, "GetDirectBufferCapacity")
    && bda_check_no_critical(s, "GetDirectBufferCapacity")
    && bda_check_non_null(s, p1,  1, "GetDirectBufferCapacity")
    && bda_check_ref_dangling(s, p1, 1, "GetDirectBufferCapacity")
    && bda_check_assignable_jobject_jclass(s, p1, bda_clazz_nio_buffer, 1, "GetDirectBufferCapacity")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetDirectBufferCapacity;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetDirectBufferCapacity(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}


/* proxy for GetObjectRefType*/
static jobjectRefType JNICALL bda_c2j_proxy_GetObjectRefType(JNIEnv * env, jobject p1)
{
  /* local variables */
  jobjectRefType result;
  void *fp, *ret_addr, *ret_addr_from_original;
  struct bda_jni_function_frame c2j;
  struct bda_state_info *s;
  enum bda_mode saved_mode;

  /* Prologue */
  GET_FRAME_POINTER(fp)
  GET_RETURN_ADDRESS(ret_addr);

  /* Obtain a state variable for the current thraed. */
  s = bda_get_state_info(env);
  /* Update call counts. */
  if (s != NULL){
    saved_mode = s->mode;
  }

  /* Check the JNI Function call. */
  if (bda_jvmti && agent_options.jinn && (s != NULL) && (s->mode != JVM) && !bda_is_in_jdwp_region(ret_addr)) {
    int success;
    success = 1 
    && bda_check_env_match(s, env, "GetObjectRefType")
    && bda_check_no_exeception(s, "GetObjectRefType")
    && bda_check_no_critical(s, "GetObjectRefType")
    && bda_check_non_null(s, p1,  1, "GetObjectRefType")
    && bda_check_ref_dangling(s, p1, 1, "GetObjectRefType")
    ;
    // Just return if an exception is pending here.
    if ((agent_options.jinn )&& bda_orig_jni_funcs->ExceptionCheck(s->env) == JNI_TRUE){
      s->mode = saved_mode;
      return 0;
    }
  }

  /* Push the jni_function_frame structure. */
  if (s != NULL) {
#if defined(__GNUC__)
    ret_addr_from_original = &&L_RETURN;
#else
    ret_addr_from_original = bda_c2j_proxy_GetObjectRefType;
#endif
    c2j.return_addr = ret_addr_from_original;
    c2j.caller_fp = fp;
    c2j.jdwp_context =  bda_is_in_jdwp_region(ret_addr);
    c2j.call_type = JNI_CALL_NOT_CLASSIFIED;
    c2j.object = NULL;
    c2j.class = NULL;
    c2j.mid = NULL;
    bda_state_c2j_call(s, &c2j);
  }

  /* Call the target JNI function. */
  result = bda_orig_jni_funcs->GetObjectRefType(env, p1);
  L_RETURN:

  /* Pop the jni_function_frame structure. */
  if (s != NULL) {
    bda_state_c2j_return(s, &c2j);
    s->mode = saved_mode;
  }

  /* Check the JNI function return. */
  if ((s != NULL) && agent_options.jinn && (s->mode != JVM)) {
  }

  if ((s != NULL) && agent_options.jinn) {
  }

  return result;
}

void bda_c2j_proxy_install(jvmtiEnv *jvmti)
{
  jvmtiError err;
  err = (*jvmti)->GetJNIFunctionTable(jvmti, &proxy_jni_funcs);
  assert(err == JVMTI_ERROR_NONE);
  proxy_jni_funcs->GetVersion = bda_c2j_proxy_GetVersion;
  proxy_jni_funcs->DefineClass = bda_c2j_proxy_DefineClass;
  proxy_jni_funcs->FindClass = bda_c2j_proxy_FindClass;
  proxy_jni_funcs->FromReflectedMethod = bda_c2j_proxy_FromReflectedMethod;
  proxy_jni_funcs->FromReflectedField = bda_c2j_proxy_FromReflectedField;
  proxy_jni_funcs->ToReflectedMethod = bda_c2j_proxy_ToReflectedMethod;
  proxy_jni_funcs->GetSuperclass = bda_c2j_proxy_GetSuperclass;
  proxy_jni_funcs->IsAssignableFrom = bda_c2j_proxy_IsAssignableFrom;
  proxy_jni_funcs->ToReflectedField = bda_c2j_proxy_ToReflectedField;
  proxy_jni_funcs->Throw = bda_c2j_proxy_Throw;
  proxy_jni_funcs->ThrowNew = bda_c2j_proxy_ThrowNew;
  proxy_jni_funcs->ExceptionOccurred = bda_c2j_proxy_ExceptionOccurred;
  proxy_jni_funcs->ExceptionDescribe = bda_c2j_proxy_ExceptionDescribe;
  proxy_jni_funcs->ExceptionClear = bda_c2j_proxy_ExceptionClear;
  proxy_jni_funcs->FatalError = bda_c2j_proxy_FatalError;
  proxy_jni_funcs->PushLocalFrame = bda_c2j_proxy_PushLocalFrame;
  proxy_jni_funcs->PopLocalFrame = bda_c2j_proxy_PopLocalFrame;
  proxy_jni_funcs->NewGlobalRef = bda_c2j_proxy_NewGlobalRef;
  proxy_jni_funcs->DeleteGlobalRef = bda_c2j_proxy_DeleteGlobalRef;
  proxy_jni_funcs->DeleteLocalRef = bda_c2j_proxy_DeleteLocalRef;
  proxy_jni_funcs->IsSameObject = bda_c2j_proxy_IsSameObject;
  proxy_jni_funcs->NewLocalRef = bda_c2j_proxy_NewLocalRef;
  proxy_jni_funcs->EnsureLocalCapacity = bda_c2j_proxy_EnsureLocalCapacity;
  proxy_jni_funcs->AllocObject = bda_c2j_proxy_AllocObject;
  proxy_jni_funcs->NewObject = bda_c2j_proxy_NewObject;
  proxy_jni_funcs->NewObjectV = bda_c2j_proxy_NewObjectV;
  proxy_jni_funcs->NewObjectA = bda_c2j_proxy_NewObjectA;
  proxy_jni_funcs->GetObjectClass = bda_c2j_proxy_GetObjectClass;
  proxy_jni_funcs->IsInstanceOf = bda_c2j_proxy_IsInstanceOf;
  proxy_jni_funcs->GetMethodID = bda_c2j_proxy_GetMethodID;
  proxy_jni_funcs->CallObjectMethod = bda_c2j_proxy_CallObjectMethod;
  proxy_jni_funcs->CallObjectMethodV = bda_c2j_proxy_CallObjectMethodV;
  proxy_jni_funcs->CallObjectMethodA = bda_c2j_proxy_CallObjectMethodA;
  proxy_jni_funcs->CallBooleanMethod = bda_c2j_proxy_CallBooleanMethod;
  proxy_jni_funcs->CallBooleanMethodV = bda_c2j_proxy_CallBooleanMethodV;
  proxy_jni_funcs->CallBooleanMethodA = bda_c2j_proxy_CallBooleanMethodA;
  proxy_jni_funcs->CallByteMethod = bda_c2j_proxy_CallByteMethod;
  proxy_jni_funcs->CallByteMethodV = bda_c2j_proxy_CallByteMethodV;
  proxy_jni_funcs->CallByteMethodA = bda_c2j_proxy_CallByteMethodA;
  proxy_jni_funcs->CallCharMethod = bda_c2j_proxy_CallCharMethod;
  proxy_jni_funcs->CallCharMethodV = bda_c2j_proxy_CallCharMethodV;
  proxy_jni_funcs->CallCharMethodA = bda_c2j_proxy_CallCharMethodA;
  proxy_jni_funcs->CallShortMethod = bda_c2j_proxy_CallShortMethod;
  proxy_jni_funcs->CallShortMethodV = bda_c2j_proxy_CallShortMethodV;
  proxy_jni_funcs->CallShortMethodA = bda_c2j_proxy_CallShortMethodA;
  proxy_jni_funcs->CallIntMethod = bda_c2j_proxy_CallIntMethod;
  proxy_jni_funcs->CallIntMethodV = bda_c2j_proxy_CallIntMethodV;
  proxy_jni_funcs->CallIntMethodA = bda_c2j_proxy_CallIntMethodA;
  proxy_jni_funcs->CallLongMethod = bda_c2j_proxy_CallLongMethod;
  proxy_jni_funcs->CallLongMethodV = bda_c2j_proxy_CallLongMethodV;
  proxy_jni_funcs->CallLongMethodA = bda_c2j_proxy_CallLongMethodA;
  proxy_jni_funcs->CallFloatMethod = bda_c2j_proxy_CallFloatMethod;
  proxy_jni_funcs->CallFloatMethodV = bda_c2j_proxy_CallFloatMethodV;
  proxy_jni_funcs->CallFloatMethodA = bda_c2j_proxy_CallFloatMethodA;
  proxy_jni_funcs->CallDoubleMethod = bda_c2j_proxy_CallDoubleMethod;
  proxy_jni_funcs->CallDoubleMethodV = bda_c2j_proxy_CallDoubleMethodV;
  proxy_jni_funcs->CallDoubleMethodA = bda_c2j_proxy_CallDoubleMethodA;
  proxy_jni_funcs->CallVoidMethod = bda_c2j_proxy_CallVoidMethod;
  proxy_jni_funcs->CallVoidMethodV = bda_c2j_proxy_CallVoidMethodV;
  proxy_jni_funcs->CallVoidMethodA = bda_c2j_proxy_CallVoidMethodA;
  proxy_jni_funcs->CallNonvirtualObjectMethod = bda_c2j_proxy_CallNonvirtualObjectMethod;
  proxy_jni_funcs->CallNonvirtualObjectMethodV = bda_c2j_proxy_CallNonvirtualObjectMethodV;
  proxy_jni_funcs->CallNonvirtualObjectMethodA = bda_c2j_proxy_CallNonvirtualObjectMethodA;
  proxy_jni_funcs->CallNonvirtualBooleanMethod = bda_c2j_proxy_CallNonvirtualBooleanMethod;
  proxy_jni_funcs->CallNonvirtualBooleanMethodV = bda_c2j_proxy_CallNonvirtualBooleanMethodV;
  proxy_jni_funcs->CallNonvirtualBooleanMethodA = bda_c2j_proxy_CallNonvirtualBooleanMethodA;
  proxy_jni_funcs->CallNonvirtualByteMethod = bda_c2j_proxy_CallNonvirtualByteMethod;
  proxy_jni_funcs->CallNonvirtualByteMethodV = bda_c2j_proxy_CallNonvirtualByteMethodV;
  proxy_jni_funcs->CallNonvirtualByteMethodA = bda_c2j_proxy_CallNonvirtualByteMethodA;
  proxy_jni_funcs->CallNonvirtualCharMethod = bda_c2j_proxy_CallNonvirtualCharMethod;
  proxy_jni_funcs->CallNonvirtualCharMethodV = bda_c2j_proxy_CallNonvirtualCharMethodV;
  proxy_jni_funcs->CallNonvirtualCharMethodA = bda_c2j_proxy_CallNonvirtualCharMethodA;
  proxy_jni_funcs->CallNonvirtualShortMethod = bda_c2j_proxy_CallNonvirtualShortMethod;
  proxy_jni_funcs->CallNonvirtualShortMethodV = bda_c2j_proxy_CallNonvirtualShortMethodV;
  proxy_jni_funcs->CallNonvirtualShortMethodA = bda_c2j_proxy_CallNonvirtualShortMethodA;
  proxy_jni_funcs->CallNonvirtualIntMethod = bda_c2j_proxy_CallNonvirtualIntMethod;
  proxy_jni_funcs->CallNonvirtualIntMethodV = bda_c2j_proxy_CallNonvirtualIntMethodV;
  proxy_jni_funcs->CallNonvirtualIntMethodA = bda_c2j_proxy_CallNonvirtualIntMethodA;
  proxy_jni_funcs->CallNonvirtualLongMethod = bda_c2j_proxy_CallNonvirtualLongMethod;
  proxy_jni_funcs->CallNonvirtualLongMethodV = bda_c2j_proxy_CallNonvirtualLongMethodV;
  proxy_jni_funcs->CallNonvirtualLongMethodA = bda_c2j_proxy_CallNonvirtualLongMethodA;
  proxy_jni_funcs->CallNonvirtualFloatMethod = bda_c2j_proxy_CallNonvirtualFloatMethod;
  proxy_jni_funcs->CallNonvirtualFloatMethodV = bda_c2j_proxy_CallNonvirtualFloatMethodV;
  proxy_jni_funcs->CallNonvirtualFloatMethodA = bda_c2j_proxy_CallNonvirtualFloatMethodA;
  proxy_jni_funcs->CallNonvirtualDoubleMethod = bda_c2j_proxy_CallNonvirtualDoubleMethod;
  proxy_jni_funcs->CallNonvirtualDoubleMethodV = bda_c2j_proxy_CallNonvirtualDoubleMethodV;
  proxy_jni_funcs->CallNonvirtualDoubleMethodA = bda_c2j_proxy_CallNonvirtualDoubleMethodA;
  proxy_jni_funcs->CallNonvirtualVoidMethod = bda_c2j_proxy_CallNonvirtualVoidMethod;
  proxy_jni_funcs->CallNonvirtualVoidMethodV = bda_c2j_proxy_CallNonvirtualVoidMethodV;
  proxy_jni_funcs->CallNonvirtualVoidMethodA = bda_c2j_proxy_CallNonvirtualVoidMethodA;
  proxy_jni_funcs->GetFieldID = bda_c2j_proxy_GetFieldID;
  proxy_jni_funcs->GetObjectField = bda_c2j_proxy_GetObjectField;
  proxy_jni_funcs->GetBooleanField = bda_c2j_proxy_GetBooleanField;
  proxy_jni_funcs->GetByteField = bda_c2j_proxy_GetByteField;
  proxy_jni_funcs->GetCharField = bda_c2j_proxy_GetCharField;
  proxy_jni_funcs->GetShortField = bda_c2j_proxy_GetShortField;
  proxy_jni_funcs->GetIntField = bda_c2j_proxy_GetIntField;
  proxy_jni_funcs->GetLongField = bda_c2j_proxy_GetLongField;
  proxy_jni_funcs->GetFloatField = bda_c2j_proxy_GetFloatField;
  proxy_jni_funcs->GetDoubleField = bda_c2j_proxy_GetDoubleField;
  proxy_jni_funcs->SetObjectField = bda_c2j_proxy_SetObjectField;
  proxy_jni_funcs->SetBooleanField = bda_c2j_proxy_SetBooleanField;
  proxy_jni_funcs->SetByteField = bda_c2j_proxy_SetByteField;
  proxy_jni_funcs->SetCharField = bda_c2j_proxy_SetCharField;
  proxy_jni_funcs->SetShortField = bda_c2j_proxy_SetShortField;
  proxy_jni_funcs->SetIntField = bda_c2j_proxy_SetIntField;
  proxy_jni_funcs->SetLongField = bda_c2j_proxy_SetLongField;
  proxy_jni_funcs->SetFloatField = bda_c2j_proxy_SetFloatField;
  proxy_jni_funcs->SetDoubleField = bda_c2j_proxy_SetDoubleField;
  proxy_jni_funcs->GetStaticMethodID = bda_c2j_proxy_GetStaticMethodID;
  proxy_jni_funcs->CallStaticObjectMethod = bda_c2j_proxy_CallStaticObjectMethod;
  proxy_jni_funcs->CallStaticObjectMethodV = bda_c2j_proxy_CallStaticObjectMethodV;
  proxy_jni_funcs->CallStaticObjectMethodA = bda_c2j_proxy_CallStaticObjectMethodA;
  proxy_jni_funcs->CallStaticBooleanMethod = bda_c2j_proxy_CallStaticBooleanMethod;
  proxy_jni_funcs->CallStaticBooleanMethodV = bda_c2j_proxy_CallStaticBooleanMethodV;
  proxy_jni_funcs->CallStaticBooleanMethodA = bda_c2j_proxy_CallStaticBooleanMethodA;
  proxy_jni_funcs->CallStaticByteMethod = bda_c2j_proxy_CallStaticByteMethod;
  proxy_jni_funcs->CallStaticByteMethodV = bda_c2j_proxy_CallStaticByteMethodV;
  proxy_jni_funcs->CallStaticByteMethodA = bda_c2j_proxy_CallStaticByteMethodA;
  proxy_jni_funcs->CallStaticCharMethod = bda_c2j_proxy_CallStaticCharMethod;
  proxy_jni_funcs->CallStaticCharMethodV = bda_c2j_proxy_CallStaticCharMethodV;
  proxy_jni_funcs->CallStaticCharMethodA = bda_c2j_proxy_CallStaticCharMethodA;
  proxy_jni_funcs->CallStaticShortMethod = bda_c2j_proxy_CallStaticShortMethod;
  proxy_jni_funcs->CallStaticShortMethodV = bda_c2j_proxy_CallStaticShortMethodV;
  proxy_jni_funcs->CallStaticShortMethodA = bda_c2j_proxy_CallStaticShortMethodA;
  proxy_jni_funcs->CallStaticIntMethod = bda_c2j_proxy_CallStaticIntMethod;
  proxy_jni_funcs->CallStaticIntMethodV = bda_c2j_proxy_CallStaticIntMethodV;
  proxy_jni_funcs->CallStaticIntMethodA = bda_c2j_proxy_CallStaticIntMethodA;
  proxy_jni_funcs->CallStaticLongMethod = bda_c2j_proxy_CallStaticLongMethod;
  proxy_jni_funcs->CallStaticLongMethodV = bda_c2j_proxy_CallStaticLongMethodV;
  proxy_jni_funcs->CallStaticLongMethodA = bda_c2j_proxy_CallStaticLongMethodA;
  proxy_jni_funcs->CallStaticFloatMethod = bda_c2j_proxy_CallStaticFloatMethod;
  proxy_jni_funcs->CallStaticFloatMethodV = bda_c2j_proxy_CallStaticFloatMethodV;
  proxy_jni_funcs->CallStaticFloatMethodA = bda_c2j_proxy_CallStaticFloatMethodA;
  proxy_jni_funcs->CallStaticDoubleMethod = bda_c2j_proxy_CallStaticDoubleMethod;
  proxy_jni_funcs->CallStaticDoubleMethodV = bda_c2j_proxy_CallStaticDoubleMethodV;
  proxy_jni_funcs->CallStaticDoubleMethodA = bda_c2j_proxy_CallStaticDoubleMethodA;
  proxy_jni_funcs->CallStaticVoidMethod = bda_c2j_proxy_CallStaticVoidMethod;
  proxy_jni_funcs->CallStaticVoidMethodV = bda_c2j_proxy_CallStaticVoidMethodV;
  proxy_jni_funcs->CallStaticVoidMethodA = bda_c2j_proxy_CallStaticVoidMethodA;
  proxy_jni_funcs->GetStaticFieldID = bda_c2j_proxy_GetStaticFieldID;
  proxy_jni_funcs->GetStaticObjectField = bda_c2j_proxy_GetStaticObjectField;
  proxy_jni_funcs->GetStaticBooleanField = bda_c2j_proxy_GetStaticBooleanField;
  proxy_jni_funcs->GetStaticByteField = bda_c2j_proxy_GetStaticByteField;
  proxy_jni_funcs->GetStaticCharField = bda_c2j_proxy_GetStaticCharField;
  proxy_jni_funcs->GetStaticShortField = bda_c2j_proxy_GetStaticShortField;
  proxy_jni_funcs->GetStaticIntField = bda_c2j_proxy_GetStaticIntField;
  proxy_jni_funcs->GetStaticLongField = bda_c2j_proxy_GetStaticLongField;
  proxy_jni_funcs->GetStaticFloatField = bda_c2j_proxy_GetStaticFloatField;
  proxy_jni_funcs->GetStaticDoubleField = bda_c2j_proxy_GetStaticDoubleField;
  proxy_jni_funcs->SetStaticObjectField = bda_c2j_proxy_SetStaticObjectField;
  proxy_jni_funcs->SetStaticBooleanField = bda_c2j_proxy_SetStaticBooleanField;
  proxy_jni_funcs->SetStaticByteField = bda_c2j_proxy_SetStaticByteField;
  proxy_jni_funcs->SetStaticCharField = bda_c2j_proxy_SetStaticCharField;
  proxy_jni_funcs->SetStaticShortField = bda_c2j_proxy_SetStaticShortField;
  proxy_jni_funcs->SetStaticIntField = bda_c2j_proxy_SetStaticIntField;
  proxy_jni_funcs->SetStaticLongField = bda_c2j_proxy_SetStaticLongField;
  proxy_jni_funcs->SetStaticFloatField = bda_c2j_proxy_SetStaticFloatField;
  proxy_jni_funcs->SetStaticDoubleField = bda_c2j_proxy_SetStaticDoubleField;
  proxy_jni_funcs->NewString = bda_c2j_proxy_NewString;
  proxy_jni_funcs->GetStringLength = bda_c2j_proxy_GetStringLength;
  proxy_jni_funcs->GetStringChars = bda_c2j_proxy_GetStringChars;
  proxy_jni_funcs->ReleaseStringChars = bda_c2j_proxy_ReleaseStringChars;
  proxy_jni_funcs->NewStringUTF = bda_c2j_proxy_NewStringUTF;
  proxy_jni_funcs->GetStringUTFLength = bda_c2j_proxy_GetStringUTFLength;
  proxy_jni_funcs->GetStringUTFChars = bda_c2j_proxy_GetStringUTFChars;
  proxy_jni_funcs->ReleaseStringUTFChars = bda_c2j_proxy_ReleaseStringUTFChars;
  proxy_jni_funcs->GetArrayLength = bda_c2j_proxy_GetArrayLength;
  proxy_jni_funcs->NewObjectArray = bda_c2j_proxy_NewObjectArray;
  proxy_jni_funcs->GetObjectArrayElement = bda_c2j_proxy_GetObjectArrayElement;
  proxy_jni_funcs->SetObjectArrayElement = bda_c2j_proxy_SetObjectArrayElement;
  proxy_jni_funcs->NewBooleanArray = bda_c2j_proxy_NewBooleanArray;
  proxy_jni_funcs->NewByteArray = bda_c2j_proxy_NewByteArray;
  proxy_jni_funcs->NewCharArray = bda_c2j_proxy_NewCharArray;
  proxy_jni_funcs->NewShortArray = bda_c2j_proxy_NewShortArray;
  proxy_jni_funcs->NewIntArray = bda_c2j_proxy_NewIntArray;
  proxy_jni_funcs->NewLongArray = bda_c2j_proxy_NewLongArray;
  proxy_jni_funcs->NewFloatArray = bda_c2j_proxy_NewFloatArray;
  proxy_jni_funcs->NewDoubleArray = bda_c2j_proxy_NewDoubleArray;
  proxy_jni_funcs->GetBooleanArrayElements = bda_c2j_proxy_GetBooleanArrayElements;
  proxy_jni_funcs->GetByteArrayElements = bda_c2j_proxy_GetByteArrayElements;
  proxy_jni_funcs->GetCharArrayElements = bda_c2j_proxy_GetCharArrayElements;
  proxy_jni_funcs->GetShortArrayElements = bda_c2j_proxy_GetShortArrayElements;
  proxy_jni_funcs->GetIntArrayElements = bda_c2j_proxy_GetIntArrayElements;
  proxy_jni_funcs->GetLongArrayElements = bda_c2j_proxy_GetLongArrayElements;
  proxy_jni_funcs->GetFloatArrayElements = bda_c2j_proxy_GetFloatArrayElements;
  proxy_jni_funcs->GetDoubleArrayElements = bda_c2j_proxy_GetDoubleArrayElements;
  proxy_jni_funcs->ReleaseBooleanArrayElements = bda_c2j_proxy_ReleaseBooleanArrayElements;
  proxy_jni_funcs->ReleaseByteArrayElements = bda_c2j_proxy_ReleaseByteArrayElements;
  proxy_jni_funcs->ReleaseCharArrayElements = bda_c2j_proxy_ReleaseCharArrayElements;
  proxy_jni_funcs->ReleaseShortArrayElements = bda_c2j_proxy_ReleaseShortArrayElements;
  proxy_jni_funcs->ReleaseIntArrayElements = bda_c2j_proxy_ReleaseIntArrayElements;
  proxy_jni_funcs->ReleaseLongArrayElements = bda_c2j_proxy_ReleaseLongArrayElements;
  proxy_jni_funcs->ReleaseFloatArrayElements = bda_c2j_proxy_ReleaseFloatArrayElements;
  proxy_jni_funcs->ReleaseDoubleArrayElements = bda_c2j_proxy_ReleaseDoubleArrayElements;
  proxy_jni_funcs->GetBooleanArrayRegion = bda_c2j_proxy_GetBooleanArrayRegion;
  proxy_jni_funcs->GetByteArrayRegion = bda_c2j_proxy_GetByteArrayRegion;
  proxy_jni_funcs->GetCharArrayRegion = bda_c2j_proxy_GetCharArrayRegion;
  proxy_jni_funcs->GetShortArrayRegion = bda_c2j_proxy_GetShortArrayRegion;
  proxy_jni_funcs->GetIntArrayRegion = bda_c2j_proxy_GetIntArrayRegion;
  proxy_jni_funcs->GetLongArrayRegion = bda_c2j_proxy_GetLongArrayRegion;
  proxy_jni_funcs->GetFloatArrayRegion = bda_c2j_proxy_GetFloatArrayRegion;
  proxy_jni_funcs->GetDoubleArrayRegion = bda_c2j_proxy_GetDoubleArrayRegion;
  proxy_jni_funcs->SetBooleanArrayRegion = bda_c2j_proxy_SetBooleanArrayRegion;
  proxy_jni_funcs->SetByteArrayRegion = bda_c2j_proxy_SetByteArrayRegion;
  proxy_jni_funcs->SetCharArrayRegion = bda_c2j_proxy_SetCharArrayRegion;
  proxy_jni_funcs->SetShortArrayRegion = bda_c2j_proxy_SetShortArrayRegion;
  proxy_jni_funcs->SetIntArrayRegion = bda_c2j_proxy_SetIntArrayRegion;
  proxy_jni_funcs->SetLongArrayRegion = bda_c2j_proxy_SetLongArrayRegion;
  proxy_jni_funcs->SetFloatArrayRegion = bda_c2j_proxy_SetFloatArrayRegion;
  proxy_jni_funcs->SetDoubleArrayRegion = bda_c2j_proxy_SetDoubleArrayRegion;
  proxy_jni_funcs->RegisterNatives = bda_c2j_proxy_RegisterNatives;
  proxy_jni_funcs->UnregisterNatives = bda_c2j_proxy_UnregisterNatives;
  proxy_jni_funcs->MonitorEnter = bda_c2j_proxy_MonitorEnter;
  proxy_jni_funcs->MonitorExit = bda_c2j_proxy_MonitorExit;
  proxy_jni_funcs->GetJavaVM = bda_c2j_proxy_GetJavaVM;
  proxy_jni_funcs->GetStringRegion = bda_c2j_proxy_GetStringRegion;
  proxy_jni_funcs->GetStringUTFRegion = bda_c2j_proxy_GetStringUTFRegion;
  proxy_jni_funcs->GetPrimitiveArrayCritical = bda_c2j_proxy_GetPrimitiveArrayCritical;
  proxy_jni_funcs->ReleasePrimitiveArrayCritical = bda_c2j_proxy_ReleasePrimitiveArrayCritical;
  proxy_jni_funcs->GetStringCritical = bda_c2j_proxy_GetStringCritical;
  proxy_jni_funcs->ReleaseStringCritical = bda_c2j_proxy_ReleaseStringCritical;
  proxy_jni_funcs->NewWeakGlobalRef = bda_c2j_proxy_NewWeakGlobalRef;
  proxy_jni_funcs->DeleteWeakGlobalRef = bda_c2j_proxy_DeleteWeakGlobalRef;
  proxy_jni_funcs->ExceptionCheck = bda_c2j_proxy_ExceptionCheck;
  proxy_jni_funcs->NewDirectByteBuffer = bda_c2j_proxy_NewDirectByteBuffer;
  proxy_jni_funcs->GetDirectBufferAddress = bda_c2j_proxy_GetDirectBufferAddress;
  proxy_jni_funcs->GetDirectBufferCapacity = bda_c2j_proxy_GetDirectBufferCapacity;
  proxy_jni_funcs->GetObjectRefType = bda_c2j_proxy_GetObjectRefType;
  err = (*jvmti)->SetJNIFunctionTable(jvmti, proxy_jni_funcs);
  assert(err == JVMTI_ERROR_NONE);
}
