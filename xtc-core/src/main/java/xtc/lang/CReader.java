// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 2.1.0,
// (C) 2004-2011 Robert Grimm,
// on Monday, July 25, 2011 at 2:20:15 PM.
// Edit at your own risk.
// ===========================================================================

package xtc.lang;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Action;
import xtc.util.Pair;

import xtc.tree.Node;
import xtc.tree.GNode;
import xtc.tree.Token;
import xtc.tree.TextToken;
import xtc.tree.Formatting;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

/**
 * Packrat parser for grammar <code>xtc.lang.C</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 2.1.0, (C) 2004-2011 Robert Grimm.
 */
public final class CReader extends ParserBase {

  /** The GCC flag. */
  public static final boolean GCC = true;

  /** The C_KEYWORDS set. */
  public static final Set<String> C_KEYWORDS = new HashSet<String>();

  /** The RELOCATE flag. */
  public static final boolean RELOCATE = true;

  /** The C99 flag. */
  public static final boolean C99 = true;

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fDeclarationSpecifiers;
    Result fSpecifierQualifierList;
    Result fAttributedDeclarator;
    Result fDeclarator;
    Result fPointer;
    Result fVariableLength;
    Result fParameterTypeList;
    Result fAbstractDeclarator;
    Result fTypeName;
    Result fAttributeSpecifierList;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fAttributeSpecifier;
    Result fStatement;
    Result fCompoundStatement;
    Result fCommaExpression;
    Result fAssignmentExpression;
    Result fConditionalExpression;
    Result fLogicalOrExpression;
    Result fCastExpression;
    Result fUnaryExpression;
    Result fExpressionList;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fExpressionList$$Star1;
    Result fSimpleAssemblyExpression;
    Result fAssemblyOperands;
    Result fAssemblyOperands$$Star1;
    Result fAssemblyOperand;
    Result fAsmKeyword;
    Result fExponent;
    Result f$$Shared2;
    Result fBinaryExponent;
    Result fCharacterLiteral;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fStringConstant;
    Result fStringConstant$$Plus1;
    Result fStringLiteral;
    Result fIdentifier;
    Result fKeyword;
    Result fWord;
    Result fSymbol;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class CReaderColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
  }

  // =========================================================================

  /** The global state object. */
  protected final xtc.lang.CParserState yyState;

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public CReader(final Reader reader, final String file) {
    super(reader, file);
    yyState = new xtc.lang.CParserState();
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public CReader(final Reader reader, final String file, final int size) {
    super(reader, file, size);
    yyState = new xtc.lang.CParserState();
  }

  // =========================================================================

  protected Column newColumn() {
    return new CReaderColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.TranslationUnit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pTranslationUnit(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Unit>.

    yyResult = pPrelude(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$pt$1 = yyResult.semanticValue();

      yyResult = pTranslationUnit$$Split1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        yyValue = Formatting.before1(v$pt$1, v$pt$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.TranslationUnit$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTranslationUnit$$Split1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Unit>.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pExternalDeclaration(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyResult = pAnnotations(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pEndOfFile(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = GNode.create("TranslationUnit", v$g$1.size() + 1).
            addAll(v$g$1).add(v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.Prelude.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pPrelude(final int yyStart) throws IOException {
    Result     yyResult;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Reset the global state object.
    yyState.reset(column(yyStart).file);

    // Alternative 1.

    yyResult = pDirective(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new TextToken(difference(yyStart, yyResult.index));
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.ExternalDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExternalDeclaration(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative <Declaration>.

    yyState.mark();

    yyResult = pDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node d = yyResult.semanticValue();

      yyValue = yyState.annotate(d);

      // Commit the state modification.
      yyState.commit();

      setLocation(yyValue, yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Function>.

    yyResult = pFunctionDefinition(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node fd = yyResult.semanticValue();

      yyValue = yyState.annotate(fd);

      // Commit the state modification.
      yyState.commit();

      setLocation(yyValue, yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Assembly>.

    yyResult = pAssemblyDefinition(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node a = yyResult.semanticValue();

      yyValue = yyState.annotate(a);

      // Commit the state modification.
      yyState.commit();

      setLocation(yyValue, yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Empty>.

    yyResult = pEmptyDefinition(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node e = yyResult.semanticValue();

      yyValue = yyState.annotate(e);

      // Commit the state modification.
      yyState.commit();

      setLocation(yyValue, yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.FunctionDefinition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunctionDefinition(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Definition>.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pKeyword(yyBase);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__extension__")) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    } else {
      yyError = yyError.select("'__extension__' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyOpValue1 = null;

      yyResult = pDeclarationSpecifiers(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyResult = pDeclarator(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyResult = pFunctionDeclaratorContext(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pDeclarationList(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
            { // Start scope for v$g$4.
              final Node v$g$4 = yyOpValue1;

              yyResult = pCompoundStatement(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$5 = yyResult.semanticValue();

                yyValue = GNode.create("FunctionDefinition", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            } // End scope for v$g$4.
          }
        }
      } // End scope for v$g$2.
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.DeclarationList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarationList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <List>.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pDeclarationListEntry(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("DeclarationList", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.DeclarationListEntry.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarationListEntry(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative <Entry>.

    yyResult = pDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      // Commit the state modification.
      yyState.commit();

      return yyResult.createValue(yyValue, yyError);
    }

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.EmptyDefinition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEmptyDefinition(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("EmptyDefinition", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("empty definition expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.Annotations.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAnnotations(final int yyStart) throws IOException {
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative 1.

    yyState.mark();
    yyValue = yyState.annotate(null);

    // Commit the state modification.
    yyState.commit();

    setLocation(yyValue, yyStart);
    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.Declaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclaration(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pKeyword(yyBase);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__extension__")) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    } else {
      yyError = yyError.select("'__extension__' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pDeclarationSpecifiers(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pInitializedDeclaratorList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for l.
          final Node l = yyOpValue1;

          if (yyState.isValid(l)) {

            yyBase   = yyOption1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue() &&
                ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
              final Node v$pt$1 = yyResult.semanticValue();
              final Node v$g$3 = Formatting.after1(l, v$pt$1);

              yyValue = GNode.create("Declaration", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("';' expected", yyBase);
            }
          }
        } // End scope for l.
      }
    } // End scope for v$g$1.

    // Done.
    yyError = yyError.select("declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.DeclarationSpecifiers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarationSpecifiers(final int yyStart) 
    throws IOException {

    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fDeclarationSpecifiers) 
      yyColumn.chunk1.fDeclarationSpecifiers = pDeclarationSpecifiers$1(yyStart);
    return yyColumn.chunk1.fDeclarationSpecifiers;
  }

  /** Actually parse xtc.lang.C.DeclarationSpecifiers. */
  private Result pDeclarationSpecifiers$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDeclarationSpecifierPlus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("DeclarationSpecifiers", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.DeclarationSpecifierPlus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarationSpecifierPlus(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pDeclarationSpecifier(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.DeclarationSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarationSpecifier(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <StorageClass>.

    yyResult = pStorageClassSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <TypeSpecifier>.

    yyResult = pTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pTypeSpecContext(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <TypeQualifier>.

    yyResult = pTypeQualifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("inline")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("FunctionSpecifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__inline")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("FunctionSpecifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__inline__")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("FunctionSpecifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Attribute>.

    yyResult = pAttributeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("declaration specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.InitializedDeclaratorList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInitializedDeclaratorList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <List>.

    yyResult = pInitializedDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyResult = pInitializedDeclarator(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("InitializedDeclaratorList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.InitializedDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInitializedDeclarator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pAttributeSpecifierList(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pDeclarator(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pSimpleAssemblyExpression(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyOpValue1 = null;

          yyResult = pAttributeSpecifierList(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
          { // Start scope for v$g$4.
            final Node v$g$4 = yyOpValue1;

            yyOpValue1 = null;

            yyBase   = yyOption1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue() &&
                ((Node)yyResult.semanticValue()).getTokenText().equals("=")) {
              final Node v$pt$1 = yyResult.semanticValue();

              yyResult = pInitializer(yyResult.index);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                final Node v$pt$2 = yyResult.semanticValue();
                final Node v$el$4 = Formatting.before1(v$pt$1, v$pt$2);

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$4;
              }
            } else {
              yyError = yyError.select("'=' expected", yyBase);
            }
            { // Start scope for v$g$5.
              final Node v$g$5 = yyOpValue1;

              yyValue = GNode.create("InitializedDeclarator", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$g$5.
          } // End scope for v$g$4.
        } // End scope for v$g$3.
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.StorageClassSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStorageClassSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("auto")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("AutoSpecifier", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("extern")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("ExternSpecifier", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("register")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("RegisterSpecifier", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("static")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("StaticSpecifier", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__thread")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("ThreadSpecifier", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("typedef")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pTypedefContext(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = GNode.create("TypedefSpecifier", false);
        yyValue.setLocation(location(yyStart));
        yyValue = Formatting.after1(yyValue, v$pt$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("storage class specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.TypeQualifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeQualifier(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("volatile")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("VolatileQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__volatile")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("VolatileQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__volatile__")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("VolatileQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("const")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("ConstantQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__const")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("ConstantQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__const__")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("ConstantQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("restrict")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("RestrictQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__restrict")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("RestrictQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__restrict__")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("RestrictQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("type qualifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.TypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeSpecifier(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Enumeration>.

    yyResult = pEnumerationTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Structure>.

    yyResult = pStructureTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Union>.

    yyResult = pUnionTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Floating>.

    yyResult = pFloatingPointTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Integer>.

    yyResult = pIntegerTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node id = yyResult.semanticValue();

      if (yyState.isType(toText(id))) {

        yyValue = GNode.create("TypedefName", id);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 7.

    yyResult = pTypeofKeyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
        final Node v$pt$2 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pTypeName(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$1 = Formatting.variable().
              add(v$pt$1).add(v$pt$2).addNode(v$pt$4).add(v$pt$3);

            yyValue = GNode.create("TypeofSpecifier", v$g$1);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }

        // Nested alternative 2.

        yyResult = pCommaExpression(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$6 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
            final Node v$pt$5 = yyResult.semanticValue();
            final Node v$g$2 = Formatting.variable().
              add(v$pt$1).add(v$pt$2).addNode(v$pt$6).add(v$pt$5);

            yyValue = GNode.create("TypeofSpecifier", v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 8.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("void")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("VoidTypeSpecifier", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__builtin_va_list")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("VarArgListSpecifier", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.EnumerationTypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnumerationTypeSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("enum")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pAttributeSpecifierList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$pt$2.
        final Node v$pt$2 = yyOpValue1;
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        final int yyChoice1 = yyOption1;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pIdentifier(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$pt$4.
          final Node v$pt$4 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$2 = Formatting.after1(v$pt$4, v$pt$3);

            yyResult = pEnumeratorList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$pt$7 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue() &&
                  ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
                final Node v$el$3 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$3;
              } else {
                yyError = yyError.select("',' expected", yyBase);
              }
              { // Start scope for v$pt$5.
                final Node v$pt$5 = yyOpValue1;

                yyBase   = yyOption1;
                yyResult = pSymbol(yyBase);
                if (yyResult.hasValue() &&
                    ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
                  final Node v$pt$6 = yyResult.semanticValue();
                  final Node v$g$3 = Formatting.variable().
                    addNode(v$pt$7).add(v$pt$5).add(v$pt$6);

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pAttributeSpecifierList(yyOption1);
                  yyError  = yyResult.select(yyError, yyOption1);
                  if (yyResult.hasValue()) {
                    final Node v$el$4 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$4;
                  }
                  { // Start scope for v$g$4.
                    final Node v$g$4 = yyOpValue1;

                    yyValue = GNode.create("EnumerationTypeDefinition", v$g$1, v$g$2, v$g$3, v$g$4);
                    yyValue.setLocation(location(yyStart));

                    return new SemanticValue(yyValue, yyOption1, yyError);
                  } // End scope for v$g$4.
                } else {
                  yyError = yyError.select("'}' expected", yyBase);
                }
              } // End scope for v$pt$5.
            }
          } else {
            yyError = yyError.select("'{' expected", yyBase);
          }
        } // End scope for v$pt$4.

        // Nested alternative 2.

        yyResult = pIdentifier(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("EnumerationTypeReference", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$pt$2.
    }

    // Done.
    yyError = yyError.select("enumeration type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.EnumeratorList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnumeratorList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <List>.

    yyResult = pEnumerator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyResult = pEnumerator(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("EnumeratorList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.Enumerator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnumerator(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Enumerator>.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node id = yyResult.semanticValue();

      yyState.bind(toText(id), false);

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("=")) {
        final Node v$pt$1 = yyResult.semanticValue();

        yyResult = pConditionalExpression(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
      { // Start scope for v$g$1.
        final Node v$g$1 = yyOpValue1;

        yyValue = GNode.create("Enumerator", id, v$g$1);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.StructureTypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStructureTypeSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("struct")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pAttributeSpecifierList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$pt$2.
        final Node v$pt$2 = yyOpValue1;
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        final int yyChoice1 = yyOption1;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pIdentifier(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$pt$4.
          final Node v$pt$4 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
            final Node v$pt$3 = yyResult.semanticValue();

            yyResult = pPushScope(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pEnterStructure(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$2 = Formatting.after1(v$pt$4, v$pt$3);

                yyResult = pStructureDeclarationList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$pt$6 = yyResult.semanticValue();

                  yyBase   = yyResult.index;
                  yyResult = pSymbol(yyBase);
                  if (yyResult.hasValue() &&
                      ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
                    final Node v$pt$5 = yyResult.semanticValue();

                    yyResult = pExitStructure(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pPopScope(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        final Node v$g$3 = Formatting.after1(v$pt$6, v$pt$5);

                        yyOption1  = yyResult.index;
                        yyOpValue1 = null;

                        yyResult = pAttributeSpecifierList(yyOption1);
                        yyError  = yyResult.select(yyError, yyOption1);
                        if (yyResult.hasValue()) {
                          final Node v$el$3 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$3;
                        }
                        { // Start scope for v$g$4.
                          final Node v$g$4 = yyOpValue1;

                          yyValue = GNode.create("StructureTypeDefinition", v$g$1, v$g$2, v$g$3, v$g$4);
                          yyValue.setLocation(location(yyStart));

                          return new SemanticValue(yyValue, yyOption1, yyError);
                        } // End scope for v$g$4.
                      }
                    }
                  } else {
                    yyError = yyError.select("'}' expected", yyBase);
                  }
                }
              }
            }
          } else {
            yyError = yyError.select("'{' expected", yyBase);
          }
        } // End scope for v$pt$4.

        // Nested alternative 2.

        yyResult = pIdentifier(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("StructureTypeReference", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$pt$2.
    }

    // Done.
    yyError = yyError.select("structure type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.UnionTypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnionTypeSpecifier(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("union")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pAttributeSpecifierList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$pt$2.
        final Node v$pt$2 = yyOpValue1;
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        final int yyChoice1 = yyOption1;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pIdentifier(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$pt$4.
          final Node v$pt$4 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
            final Node v$pt$3 = yyResult.semanticValue();

            yyResult = pPushScope(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyResult = pEnterStructure(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$2 = Formatting.after1(v$pt$4, v$pt$3);

                yyResult = pStructureDeclarationList(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$pt$6 = yyResult.semanticValue();

                  yyBase   = yyResult.index;
                  yyResult = pSymbol(yyBase);
                  if (yyResult.hasValue() &&
                      ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
                    final Node v$pt$5 = yyResult.semanticValue();

                    yyResult = pExitStructure(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyResult = pPopScope(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {
                        final Node v$g$3 = Formatting.after1(v$pt$6, v$pt$5);

                        yyOption1  = yyResult.index;
                        yyOpValue1 = null;

                        yyResult = pAttributeSpecifierList(yyOption1);
                        yyError  = yyResult.select(yyError, yyOption1);
                        if (yyResult.hasValue()) {
                          final Node v$el$3 = yyResult.semanticValue();

                          yyOption1  = yyResult.index;
                          yyOpValue1 = v$el$3;
                        }
                        { // Start scope for v$g$4.
                          final Node v$g$4 = yyOpValue1;

                          yyValue = GNode.create("UnionTypeDefinition", v$g$1, v$g$2, v$g$3, v$g$4);
                          yyValue.setLocation(location(yyStart));

                          return new SemanticValue(yyValue, yyOption1, yyError);
                        } // End scope for v$g$4.
                      }
                    }
                  } else {
                    yyError = yyError.select("'}' expected", yyBase);
                  }
                }
              }
            }
          } else {
            yyError = yyError.select("'{' expected", yyBase);
          }
        } // End scope for v$pt$4.

        // Nested alternative 2.

        yyResult = pIdentifier(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("UnionTypeReference", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$pt$2.
    }

    // Done.
    yyError = yyError.select("union type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.StructureDeclarationList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStructureDeclarationList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Regular>.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pAnnotatedStructureDeclaration(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyResult = pAnnotations(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("StructureDeclarationList", v$g$1.size() + 1).
          addAll(v$g$1).add(v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Empty>.

    if (GCC) {

      yyResult = pAnnotations(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("StructureDeclarationList", v$g$3);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("structure declaration list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AnnotatedStructureDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAnnotatedStructureDeclaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative 1.

    yyState.mark();

    yyResult = pStructureDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node d = yyResult.semanticValue();

      yyValue = yyState.annotate(d);

      // Commit the state modification.
      yyState.commit();

      setLocation(yyValue, yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.StructureDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStructureDeclaration(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declaration>.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pKeyword(yyBase);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__extension__")) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    } else {
      yyError = yyError.select("'__extension__' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pSpecifierQualifierList(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pOptionalStructureDeclaratorList(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
            final Node v$pt$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            if (GCC) {

              yyRepetition1 = yyOption1;
              yyRepeated1   = false;
              yyRepValue1   = Pair.empty();
              while (true) {

                yyBase   = yyRepetition1;
                yyResult = pSymbol(yyBase);
                if (yyResult.hasValue() &&
                    ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
                  final Node v$el$3 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepeated1   = true;
                  yyRepValue1   = new Pair<Node>(v$el$3, yyRepValue1);
                  continue;
                } else {
                  yyError = yyError.select("';' expected", yyBase);
                }
                break;
              }

              if (yyRepeated1) {
                final Pair<Node> v$pt$1 = yyRepValue1.reverse();
                final Node v$el$2 = Formatting.before1(v$pt$1, null);

                yyOption1  = yyRepetition1;
                yyOpValue1 = v$el$2;
              }
            }
            { // Start scope for v$pt$3.
              final Node v$pt$3 = yyOpValue1;
              final Node v$g$3 = Formatting.variable().
                addNode(v$pt$4).add(v$pt$2).add(v$pt$3);

              yyValue = GNode.create("StructureDeclaration", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$pt$3.
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      }
    } // End scope for v$g$1.

    // Done.
    yyError = yyError.select("structure declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.SpecifierQualifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpecifierQualifierList(final int yyStart) 
    throws IOException {

    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSpecifierQualifierList) 
      yyColumn.chunk1.fSpecifierQualifierList = pSpecifierQualifierList$1(yyStart);
    return yyColumn.chunk1.fSpecifierQualifierList;
  }

  /** Actually parse xtc.lang.C.SpecifierQualifierList. */
  private Result pSpecifierQualifierList$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpecifierQualifierPlus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("SpecifierQualifierList", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.SpecifierQualifierPlus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpecifierQualifierPlus(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pSpecifierQualifier(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.SpecifierQualifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpecifierQualifier(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <TypeSpecifier>.

    yyResult = pTypeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pTypeSpecContext(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <TypeQualifier>.

    yyResult = pTypeQualifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Attribute>.

    yyResult = pAttributeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.OptionalStructureDeclaratorList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOptionalStructureDeclaratorList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <List>.

    yyResult = pStructureDeclaratorList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Null>.

    if (GCC) {
      { // Start scope for yyValue.
        yyValue = null;

        return new SemanticValue(yyValue, yyStart, yyError);
      } // End scope for yyValue.
    }

    // Done.
    yyError = yyError.select("optional structure declarator list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.StructureDeclaratorList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStructureDeclaratorList(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <List>.

    yyResult = pStructureDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyResult = pStructureDeclarator(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("StructureDeclaratorList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.StructureDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStructureDeclarator(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pAttributeSpecifierList(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyOpValue1 = null;

      yyResult = pDeclarator(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for v$pt$2.
        final Node v$pt$2 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
          final Node v$pt$1 = yyResult.semanticValue();
          final Node v$g$2 = Formatting.after1(v$pt$2, v$pt$1);

          yyResult = pConditionalExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pAttributeSpecifierList(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$3 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$3;
            }
            { // Start scope for v$g$4.
              final Node v$g$4 = yyOpValue1;

              yyValue = GNode.create("BitField", v$g$1, v$g$2, v$g$3, v$g$4);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$g$4.
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      } // End scope for v$pt$2.
    } // End scope for v$g$1.

    // Alternative <Simple>.

    yyResult = pAttributedDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AttributedDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAttributedDeclarator(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAttributedDeclarator) 
      yyColumn.chunk1.fAttributedDeclarator = pAttributedDeclarator$1(yyStart);
    return yyColumn.chunk1.fAttributedDeclarator;
  }

  /** Actually parse xtc.lang.C.AttributedDeclarator. */
  private Result pAttributedDeclarator$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pAttributeSpecifierList(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pDeclarator(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pAttributeSpecifierList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyValue = GNode.create("AttributedDeclarator", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$3.
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.Declarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarator(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fDeclarator) 
      yyColumn.chunk1.fDeclarator = pDeclarator$1(yyStart);
    return yyColumn.chunk1.fDeclarator;
  }

  /** Actually parse xtc.lang.C.Declarator. */
  private Result pDeclarator$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Pointer>.

    yyResult = pPointerDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Direct>.

    yyResult = pDirectDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.PointerDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPointerDeclarator(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pPointer(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pDirectDeclarator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("PointerDeclarator", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.Pointer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPointer(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fPointer) 
      yyColumn.chunk1.fPointer = pPointer$1(yyStart);
    return yyColumn.chunk1.fPointer;
  }

  /** Actually parse xtc.lang.C.Pointer. */
  private Result pPointer$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("*")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pTypeQualifierList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pPointer(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$2.
          final Node v$g$2 = yyOpValue1;

          yyValue = GNode.create("Pointer", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("pointer expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.TypeQualifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeQualifierList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pTypeQualifierList$$Choice1(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("TypeQualifierList", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.TypeQualifierList$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeQualifierList$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypeQualifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pAttributeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.DirectDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDirectDeclarator(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyBase;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <FullBase>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$pt$12 = yyResult.semanticValue();

      yyResult = pAttributedDeclarator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$14 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
          final Node v$pt$13 = yyResult.semanticValue();
          final Node v$g$7 = Formatting.round1(v$pt$12, v$pt$14, v$pt$13);

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pDirectDeclarator$$Tail1(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Action<Node> v$8 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Action<Node>>(v$8, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for v$9.
            final Pair<Action<Node>> v$9 = yyRepValue1.reverse();

            yyValue = apply(v$9, v$g$7, yyStart);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for v$9.
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative <SimpleBase>.

    yyResult = pSimpleDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$10 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pDirectDeclarator$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$11 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$11, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$12.
        final Pair<Action<Node>> v$12 = yyRepValue1.reverse();

        yyValue = apply(v$12, v$g$10, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$12.
    }

    // Done.
    yyError = yyError.select("direct declarator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.DirectDeclarator$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDirectDeclarator$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyOption1;
    Node         yyOpValue1;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pPushScope(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pParameterTypeList(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$3 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
            final Node v$pt$2 = yyResult.semanticValue();

            yyResult = pParameterContext(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

              yyValue = new Action<Node>() {
                public Node run(Node v$1) {
                  return GNode.create("FunctionDeclarator", v$1, v$g$2);
                }};

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }

        // Nested alternative 2.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pIdentifierList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$pt$5.
          final Node v$pt$5 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
            final Node v$pt$4 = yyResult.semanticValue();

            yyResult = pParameterContext(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = Formatting.round1(v$pt$1, v$pt$5, v$pt$4);

              yyValue = new Action<Node>() {
                public Node run(Node v$1) {
                  return GNode.create("FunctionDeclarator", v$1, v$g$3);
                }};

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$pt$5.
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("[")) {
      final Node v$pt$6 = yyResult.semanticValue();

      yyResult = pArrayQualifierList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$7 = yyResult.semanticValue();
        final Node v$g$4 = Formatting.before1(v$pt$6, v$pt$7);

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pAssignmentExpression(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$pt$9.
          final Node v$pt$9 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals("]")) {
            final Node v$pt$8 = yyResult.semanticValue();
            final Node v$g$5 = Formatting.after1(v$pt$9, v$pt$8);

            yyValue = new Action<Node>() {
              public Node run(Node v$1) {
                return GNode.create("ArrayDeclarator", v$1, v$g$4, v$g$5);
              }};

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("']' expected", yyBase);
          }
        } // End scope for v$pt$9.

        // Nested alternative 2.

        yyResult = pVariableLength(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$11 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals("]")) {
            final Node v$pt$10 = yyResult.semanticValue();
            final Node v$g$6 = Formatting.after1(v$pt$11, v$pt$10);

            yyValue = new Action<Node>() {
              public Node run(Node v$1) {
                return GNode.create("ArrayDeclarator", v$1, v$g$4, v$g$6);
              }};

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("']' expected", yyBase);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("direct declarator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.VariableLength.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariableLength(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fVariableLength) 
      yyColumn.chunk1.fVariableLength = pVariableLength$1(yyStart);
    return yyColumn.chunk1.fVariableLength;
  }

  /** Actually parse xtc.lang.C.VariableLength. */
  private Result pVariableLength$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("*")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("VariableLength", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("variable length expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.SimpleDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleDeclarator(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declarator>.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node id = yyResult.semanticValue();

      yyState.bind(toText(id));

      yyValue = GNode.create("SimpleDeclarator", id);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.ParameterTypeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameterTypeList(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fParameterTypeList) 
      yyColumn.chunk1.fParameterTypeList = pParameterTypeList$1(yyStart);
    return yyColumn.chunk1.fParameterTypeList;
  }

  /** Actually parse xtc.lang.C.ParameterTypeList. */
  private Result pParameterTypeList$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParameterList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
        final Node v$pt$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("...")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        } else {
          yyError = yyError.select("'...' expected", yyBase);
        }
      } else {
        yyError = yyError.select("',' expected", yyBase);
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("ParameterTypeList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.ParameterList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameterList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pParameterDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyResult = pParameterDeclaration(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("ParameterList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.ParameterDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameterDeclaration(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative 1.

    yyResult = pDeclarationSpecifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pDeclarator(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pAttributeSpecifierList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyValue = GNode.create("ParameterDeclaration", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          // Commit the state modification.
          yyState.commit();

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$3.
      }

      // Nested alternative 2.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pAbstractDeclarator(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for v$g$4.
        final Node v$g$4 = yyOpValue1;

        yyOpValue1 = null;

        yyResult = pAttributeSpecifierList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        }
        { // Start scope for v$g$5.
          final Node v$g$5 = yyOpValue1;

          yyValue = GNode.create("ParameterDeclaration", v$g$1, v$g$4, v$g$5);
          yyValue.setLocation(location(yyStart));

          // Commit the state modification.
          yyState.commit();

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$5.
      } // End scope for v$g$4.
    }

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AttributedAbstractDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAttributedAbstractDeclarator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pAttributeSpecifierList(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pAbstractDeclarator(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("AttributedAbstractDeclarator", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AbstractDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAbstractDeclarator(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAbstractDeclarator) 
      yyColumn.chunk1.fAbstractDeclarator = pAbstractDeclarator$1(yyStart);
    return yyColumn.chunk1.fAbstractDeclarator;
  }

  /** Actually parse xtc.lang.C.AbstractDeclarator. */
  private Result pAbstractDeclarator$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pPointer(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for p.
      final Node p = yyOpValue1;

      yyResult = pDirectAbstractDeclarator(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node d = yyResult.semanticValue();

        if ((null != p) || (null != d)) {

          yyValue = GNode.create("AbstractDeclarator", p, d);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } // End scope for p.

    // Done.
    yyError = yyError.select("abstract declarator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.DirectAbstractDeclarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDirectAbstractDeclarator(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyBase;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Parenthesized>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$pt$7 = yyResult.semanticValue();

      yyResult = pAttributedAbstractDeclarator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$9 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
          final Node v$pt$8 = yyResult.semanticValue();
          final Node v$g$7 = Formatting.round1(v$pt$7, v$pt$9, v$pt$8);

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pDirectAbstractDeclarator$$Tail1(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Action<Node> v$8 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Action<Node>>(v$8, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for v$9.
            final Pair<Action<Node>> v$9 = yyRepValue1.reverse();

            yyValue = apply(v$9, v$g$7, yyStart);

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for v$9.
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative <Empty>.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pDirectAbstractDeclarator$$Tail1(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Action<Node> v$11 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Action<Node>>(v$11, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$12.
      final Pair<Action<Node>> v$12 = yyRepValue1.reverse();

      yyValue = apply(v$12, null, yyStart);

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$12.
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.DirectAbstractDeclarator$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDirectAbstractDeclarator$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyOption1;
    Node         yyOpValue1;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("[")) {
      final Node v$g$2 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pAssignmentExpression(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$pt$2.
        final Node v$pt$2 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("]")) {
          final Node v$pt$1 = yyResult.semanticValue();
          final Node v$g$3 = Formatting.after1(v$pt$2, v$pt$1);

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("DirectAbstractDeclarator", v$1, v$g$2, v$g$3);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      } // End scope for v$pt$2.

      // Nested alternative 2.

      yyResult = pVariableLength(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$4 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("]")) {
          final Node v$pt$3 = yyResult.semanticValue();
          final Node v$g$4 = Formatting.after1(v$pt$4, v$pt$3);

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("DirectAbstractDeclarator", v$1, v$g$2, v$g$4);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$g$5 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pParameterTypeList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      }
      { // Start scope for v$pt$6.
        final Node v$pt$6 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
          final Node v$pt$5 = yyResult.semanticValue();
          final Node v$g$6 = Formatting.after1(v$pt$6, v$pt$5);

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("DirectAbstractDeclarator", v$1, v$g$5, v$g$6);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      } // End scope for v$pt$6.
    }

    // Done.
    yyError = yyError.select("direct abstract declarator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.IdentifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifierList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node id1 = yyResult.semanticValue();

      yyState.bind(toText(id1));

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyResult = pIdentifier(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node id2 = yyResult.semanticValue();

            yyState.bind(toText(id2));
            final Node v$el$1 = Formatting.before1(v$pt$1, id2);

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$1.
        final Pair<Node> v$g$1 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("IdentifierList", id1, v$g$1);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.ArrayQualifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayQualifierList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pArrayQualifierList$$Choice1(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("ArrayQualifierList", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.ArrayQualifierList$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayQualifierList$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("static")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("StaticSpecifier", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("volatile")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("VolatileQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__volatile")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("VolatileQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__volatile__")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("VolatileQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("restrict")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("RestrictQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__restrict")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("RestrictQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__restrict__")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("RestrictQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("const")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("ConstantQualifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__const")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("ConstantQualifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 10.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__const__")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("ConstantQualifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 11.

    yyResult = pAttributeSpecifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("array qualifier list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.FloatingPointTypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatingPointTypeSpecifier(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("_Complex")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Complex", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__complex__")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("Complex", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("double")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("Double", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("float")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("Float", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("floating point type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.IntegerTypeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerTypeSpecifier(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("long")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("Long", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("int")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("Int", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("short")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("Short", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("char")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("Char", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("_Bool")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("Bool", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("unsigned")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("Unsigned", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("signed")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Signed", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__signed")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("Signed", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__signed__")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("Signed", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("integer type specifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.TypeofKeyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeofKeyword(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("typeof")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("TypeofKeyword", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__typeof")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("TypeofKeyword", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__typeof__")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("TypeofKeyword", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("typeof keyword expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.Initializer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInitializer(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Complex>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pInitializerList(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$4 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
          final Node v$el$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$3;
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        { // Start scope for v$pt$2.
          final Node v$pt$2 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
            final Node v$pt$3 = yyResult.semanticValue();
            yyValue = Formatting.variable().
              add(v$pt$1).addNode(v$pt$4).add(v$pt$2).add(v$pt$3);

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("'}' expected", yyBase);
          }
        } // End scope for v$pt$2.
      }
    }

    // Alternative <Simple>.

    yyResult = pAssignmentExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("initializer expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.InitializerList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInitializerList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pInitializerListEntry(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyResult = pInitializerListEntry(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("InitializerList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Alternative 2.

    if (GCC) {

      yyValue = GNode.create("InitializerList", false);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyStart, yyError);
    }

    // Done.
    yyError = yyError.select("initializer list expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.InitializerListEntry.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInitializerListEntry(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pDesignation(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pInitializer(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("InitializerListEntry", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.Designation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDesignation(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Standard>.

    yyResult = pDesignation$$Split1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("=")) {
        final Node v$pt$2 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$1, v$pt$2);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Alternative 2.

    if (GCC) {

      final int yyChoice1 = yyStart;

      // Nested alternative 1.

      yyResult = pObsoleteArrayDesignation(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyResult = pObsoleteFieldDesignation(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        yyValue = yyResult.semanticValue();

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("designation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.Designation$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDesignation$$Split1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Standard>.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pDesignator(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("Designation", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.Designator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDesignator(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Array>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("[")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pConditionalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("]")) {
          final Node v$pt$1 = yyResult.semanticValue();
          final Node v$g$2 = Formatting.after1(v$pt$2, v$pt$1);

          yyValue = GNode.create("Designator", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative <ArrayRange>.

    if (GCC) {

      yyResult = pSymbol(yyStart);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("[")) {
        final Node v$g$3 = yyResult.semanticValue();

        yyResult = pConditionalExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals("...")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$4 = Formatting.after1(v$pt$4, v$pt$3);

            yyResult = pConditionalExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$pt$6 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue() &&
                  ((Node)yyResult.semanticValue()).getTokenText().equals("]")) {
                final Node v$pt$5 = yyResult.semanticValue();
                final Node v$g$5 = Formatting.after1(v$pt$6, v$pt$5);

                yyValue = GNode.create("Designator", v$g$3, v$g$4, v$g$5);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("']' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("'...' expected", yyBase);
          }
        }
      }
    }

    // Alternative <Structure>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(".")) {
      final Node v$g$6 = yyResult.semanticValue();

      yyResult = pPrimaryIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$7 = yyResult.semanticValue();

        yyValue = GNode.create("Designator", v$g$6, v$g$7);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("designator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.ObsoleteArrayDesignation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pObsoleteArrayDesignation(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("[")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pConditionalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyBase   = yyChoice1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("]")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyValue = GNode.create("ObsoleteArrayDesignation", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));
          yyValue = Formatting.after1(yyValue, v$pt$1);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }

        // Nested alternative 2.

        yyBase   = yyChoice1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("...")) {
          final Node v$pt$2 = yyResult.semanticValue();

          yyResult = pConditionalExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$pt$4 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue() &&
                ((Node)yyResult.semanticValue()).getTokenText().equals("]")) {
              final Node v$pt$3 = yyResult.semanticValue();
              final Node v$g$3 = Formatting.round1(v$pt$2, v$pt$4, v$pt$3);

              yyValue = GNode.create("ObsoleteArrayDesignation", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("']' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'...' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("obsolete array designation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.ObsoleteFieldDesignation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pObsoleteFieldDesignation(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyValue = GNode.create("ObsoleteFieldDesignation", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.TypeName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeName(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fTypeName) 
      yyColumn.chunk1.fTypeName = pTypeName$1(yyStart);
    return yyColumn.chunk1.fTypeName;
  }

  /** Actually parse xtc.lang.C.TypeName. */
  private Result pTypeName$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative 1.

    yyResult = pSpecifierQualifierList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pAbstractDeclarator(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("TypeName", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        // Commit the state modification.
        yyState.commit();

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AttributeSpecifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAttributeSpecifierList(final int yyStart) 
    throws IOException {

    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fAttributeSpecifierList) 
      yyColumn.chunk1.fAttributeSpecifierList = pAttributeSpecifierList$1(yyStart);
    return yyColumn.chunk1.fAttributeSpecifierList;
  }

  /** Actually parse xtc.lang.C.AttributeSpecifierList. */
  private Result pAttributeSpecifierList$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAttributeSpecifierPlus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("AttributeSpecifierList", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AttributeSpecifierPlus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAttributeSpecifierPlus(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pAttributeSpecifier(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AttributeSpecifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAttributeSpecifier(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAttributeSpecifier) 
      yyColumn.chunk2.fAttributeSpecifier = pAttributeSpecifier$1(yyStart);
    return yyColumn.chunk2.fAttributeSpecifier;
  }

  /** Actually parse xtc.lang.C.AttributeSpecifier. */
  private Result pAttributeSpecifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAttributeKeyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
          final Node v$pt$3 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pAttributeList(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$pt$6.
            final Node v$pt$6 = yyOpValue1;

            yyBase   = yyOption1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue() &&
                ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
              final Node v$pt$4 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue() &&
                  ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
                final Node v$pt$5 = yyResult.semanticValue();
                final Node v$g$1 = Formatting.variable().
                  add(v$pt$1).add(v$pt$2).add(v$pt$3).addNode(v$pt$6).add(v$pt$4).add(v$pt$5);

                yyValue = GNode.create("AttributeSpecifier", v$g$1);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          } // End scope for v$pt$6.
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AttributeKeyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAttributeKeyword(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__attribute")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("AttributeKeyword", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__attribute__")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("AttributeKeyword", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("attribute keyword expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AttributeList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAttributeList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAttributeListEntry(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyResult = pAttributeListEntry(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("AttributeList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AttributeListEntry.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAttributeListEntry(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    int        yyOption2;
    Node       yyOpValue2;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
        final Node v$pt$1 = yyResult.semanticValue();

        yyOption2  = yyResult.index;
        yyOpValue2 = null;

        yyResult = pExpressionList(yyOption2);
        yyError  = yyResult.select(yyError, yyOption2);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption2  = yyResult.index;
          yyOpValue2 = v$el$2;
        }
        { // Start scope for v$pt$3.
          final Node v$pt$3 = yyOpValue2;

          yyBase   = yyOption2;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$el$1 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$pt$3.
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("AttributeListEntry", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStatement) 
      yyColumn.chunk2.fStatement = pStatement$1(yyStart);
    return yyColumn.chunk2.fStatement;
  }

  /** Actually parse xtc.lang.C.Statement. */
  private Result pStatement$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommaExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyValue = GNode.create("ExpressionStatement", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative <Compound>.

    yyResult = pCompoundStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("if")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyResult = pCommaExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$1 = Formatting.variable().
              add(v$pt$1).add(v$pt$2).addNode(v$pt$4).add(v$pt$3);

            final int yyChoice1 = yyResult.index;

            // Nested alternative 1.

            yyResult = pStatement(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$pt$6 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pKeyword(yyBase);
              if (yyResult.hasValue() &&
                  ((Node)yyResult.semanticValue()).getTokenText().equals("else")) {
                final Node v$pt$5 = yyResult.semanticValue();
                final Node v$g$2 = Formatting.after1(v$pt$6, v$pt$5);

                yyResult = pStatement(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$3 = yyResult.semanticValue();

                  yyValue = GNode.create("IfElseStatement", v$g$1, v$g$2, v$g$3);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                }
              } else {
                yyError = yyError.select("'else' expected", yyBase);
              }
            }

            // Nested alternative 2.

            yyResult = pStatement(yyChoice1);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyValue = GNode.create("IfStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("while")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyResult = pCommaExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$1 = Formatting.variable().
              add(v$pt$1).add(v$pt$2).addNode(v$pt$4).add(v$pt$3);

            yyResult = pStatement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyValue = GNode.create("WhileStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 5.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("do")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pStatement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$4 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pKeyword(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("while")) {
          final Node v$pt$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$1 = Formatting.variable().
              add(v$pt$1).addNode(v$pt$4).add(v$pt$2).add(v$pt$3);

            yyResult = pCommaExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$pt$7 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue() &&
                  ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
                final Node v$pt$5 = yyResult.semanticValue();

                yyBase   = yyResult.index;
                yyResult = pSymbol(yyBase);
                if (yyResult.hasValue() &&
                    ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
                  final Node v$pt$6 = yyResult.semanticValue();
                  final Node v$g$2 = Formatting.variable().
                    addNode(v$pt$7).add(v$pt$5).add(v$pt$6);

                  yyValue = GNode.create("DoStatement", v$g$1, v$g$2);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                } else {
                  yyError = yyError.select("';' expected", yyBase);
                }
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("'(' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'while' expected", yyBase);
        }
      }
    }

    // Alternative 6.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("for")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pPushScope(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
          final Node v$pt$2 = yyResult.semanticValue();

          yyResult = pInitialClause(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$1 = Formatting.variable().
              add(v$pt$1).add(v$pt$2).addNode(v$pt$3);

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pCommaExpression(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
            { // Start scope for v$pt$5.
              final Node v$pt$5 = yyOpValue1;

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue() &&
                  ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
                final Node v$pt$4 = yyResult.semanticValue();
                final Node v$g$2 = Formatting.after1(v$pt$5, v$pt$4);

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pCommaExpression(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  final Node v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
                { // Start scope for v$pt$7.
                  final Node v$pt$7 = yyOpValue1;

                  yyBase   = yyOption1;
                  yyResult = pSymbol(yyBase);
                  if (yyResult.hasValue() &&
                      ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
                    final Node v$pt$6 = yyResult.semanticValue();
                    final Node v$g$3 = Formatting.after1(v$pt$7, v$pt$6);

                    yyResult = pStatement(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      final Node v$g$4 = yyResult.semanticValue();

                      yyResult = pPopScope(yyResult.index);
                      yyError  = yyResult.select(yyError);
                      if (yyResult.hasValue()) {

                        yyValue = GNode.create("ForStatement", v$g$1, v$g$2, v$g$3, v$g$4);
                        yyValue.setLocation(location(yyStart));

                        return yyResult.createValue(yyValue, yyError);
                      }
                    }
                  } else {
                    yyError = yyError.select("')' expected", yyBase);
                  }
                } // End scope for v$pt$7.
              } else {
                yyError = yyError.select("';' expected", yyBase);
              }
            } // End scope for v$pt$5.
          }
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      }
    }

    // Alternative 7.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("switch")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyResult = pCommaExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$1 = Formatting.variable().
              add(v$pt$1).add(v$pt$2).addNode(v$pt$4).add(v$pt$3);

            yyResult = pStatement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyValue = GNode.create("SwitchStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative <Complete>.

    yyResult = pLabel(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pStatement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("LabeledStatement", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Incomplete>.

    if (GCC) {

      yyResult = pLabel(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = GNode.create("LabeledStatement", v$g$3, null);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 10.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("break")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyValue = GNode.create("BreakStatement", false);
        yyValue.setLocation(location(yyStart));
        yyValue = Formatting.variable().addNode(yyValue).
          add(v$pt$1).add(v$pt$2);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 11.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("continue")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyValue = GNode.create("ContinueStatement", false);
        yyValue.setLocation(location(yyStart));
        yyValue = Formatting.variable().addNode(yyValue).
          add(v$pt$1).add(v$pt$2);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 12.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("return")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pCommaExpression(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$pt$3.
        final Node v$pt$3 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          yyValue = GNode.create("ReturnStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      } // End scope for v$pt$3.
    }

    // Alternative <Direct>.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("goto")) {
      final Node v$pt$1 = yyResult.semanticValue();
      final Node v$g$1 = Formatting.before1(v$pt$1, null);

      yyResult = pPrimaryIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$4 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
          final Node v$pt$3 = yyResult.semanticValue();
          final Node v$g$2 = Formatting.after1(v$pt$4, v$pt$3);

          yyValue = GNode.create("GotoStatement", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Alternative <Computed>.

    if (GCC) {

      yyResult = pKeyword(yyStart);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("goto")) {
        final Node v$pt$5 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("*")) {
          final Node v$pt$6 = yyResult.semanticValue();
          final Node v$g$3 = Formatting.before1(v$pt$5, v$pt$6);

          yyResult = pCommaExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$pt$8 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue() &&
                ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
              final Node v$pt$7 = yyResult.semanticValue();
              final Node v$g$4 = Formatting.after1(v$pt$8, v$pt$7);

              yyValue = GNode.create("GotoStatement", v$g$3, v$g$4);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("';' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'*' expected", yyBase);
        }
      }
    }

    // Alternative 15.

    yyResult = pAsmKeyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pTypeQualifier(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$pt$3.
        final Node v$pt$3 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          yyResult = pAssemblyArgument(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$pt$5 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue() &&
                ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
              final Node v$pt$4 = yyResult.semanticValue();
              final Node v$g$2 = Formatting.after1(v$pt$5, v$pt$4);

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue() &&
                  ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
                final Node v$g$3 = yyResult.semanticValue();

                yyValue = GNode.create("AssemblyStatement", v$g$1, v$g$2, v$g$3);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("';' expected", yyBase);
              }
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      } // End scope for v$pt$3.
    }

    // Alternative 16.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("EmptyStatement", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.Label.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLabel(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Label>.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pAttributeSpecifierList(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$g$2.
          final Node v$g$2 = yyOpValue1;

          yyValue = GNode.create("NamedLabel", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$2.
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Alternative <Range>.

    if (GCC) {

      yyResult = pKeyword(yyStart);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("case")) {
        final Node v$pt$1 = yyResult.semanticValue();

        yyResult = pConditionalExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$3 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals("...")) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$g$1 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

            yyResult = pConditionalExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$pt$5 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue() &&
                  ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
                final Node v$pt$4 = yyResult.semanticValue();
                final Node v$g$2 = Formatting.after1(v$pt$5, v$pt$4);

                yyValue = GNode.create("CaseLabel", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("':' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("'...' expected", yyBase);
          }
        }
      }
    }

    // Alternative <Simple>.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("case")) {
      final Node v$pt$6 = yyResult.semanticValue();

      yyResult = pConditionalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$8 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
          final Node v$pt$7 = yyResult.semanticValue();
          final Node v$g$3 = Formatting.round1(v$pt$6, v$pt$8, v$pt$7);

          yyValue = GNode.create("CaseLabel", v$g$3);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("default")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyValue = GNode.create("DefaultLabel", false);
        yyValue.setLocation(location(yyStart));
        yyValue = Formatting.variable().addNode(yyValue).
          add(v$pt$1).add(v$pt$2);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("label expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.CompoundStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCompoundStatement(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fCompoundStatement) 
      yyColumn.chunk2.fCompoundStatement = pCompoundStatement$1(yyStart);
    return yyColumn.chunk2.fCompoundStatement;
  }

  /** Actually parse xtc.lang.C.CompoundStatement. */
  private Result pCompoundStatement$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Compound>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pPushScope(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyResult = pCompoundStatement$$Split1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$2 = yyResult.semanticValue();
          yyValue = Formatting.before1(v$pt$1, v$pt$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("compound statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.CompoundStatement$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCompoundStatement$$Split1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Compound>.

    yyResult = pLocalLabelDeclarationStar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyResult = pDeclarationOrStatementStar(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyResult = pAnnotations(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
            final Node v$pt$1 = yyResult.semanticValue();

            yyResult = pPopScope(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = Formatting.after1(v$pt$2, v$pt$1);

              yyValue = GNode.create("CompoundStatement", v$g$1.size() + v$g$2.size() + 1).
                addAll(v$g$1).addAll(v$g$2).add(v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("'}' expected", yyBase);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.LocalLabelDeclarationStar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalLabelDeclarationStar(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pLocalLabelDeclaration(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for yyValue.
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for yyValue.
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.LocalLabelDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalLabelDeclaration(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLocalLabelDeclaration$$Split1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
        final Node v$pt$2 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$1, v$pt$2);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.LocalLabelDeclaration$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLocalLabelDeclaration$$Split1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__label__")) {
      final Node v$pt$3 = yyResult.semanticValue();

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$4 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$3, v$pt$4);

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
            final Node v$pt$1 = yyResult.semanticValue();

            yyResult = pIdentifier(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$pt$2 = yyResult.semanticValue();
              final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("LocalLabelDeclaration", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("local label declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.DeclarationOrStatementStar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarationOrStatementStar(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pDeclarationOrStatement(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for yyValue.
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for yyValue.
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.DeclarationOrStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarationOrStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative <Declaration>.

    yyState.mark();

    yyResult = pDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node d = yyResult.semanticValue();

      yyValue = yyState.annotate(d);

      // Commit the state modification.
      yyState.commit();

      setLocation(yyValue, yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Statement>.

    yyResult = pStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node s = yyResult.semanticValue();

      yyValue = yyState.annotate(s);

      // Commit the state modification.
      yyState.commit();

      setLocation(yyValue, yyStart);
      return yyResult.createValue(yyValue, yyError);
    }

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.InitialClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInitialClause(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Start a state modification.
    yyState.start();

    // Alternative <Declaration>.

    yyResult = pDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      // Commit the state modification.
      yyState.commit();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Expression>.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pCommaExpression(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$3 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$3;
    }
    { // Start scope for v$pt$2.
      final Node v$pt$2 = yyOpValue1;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
        final Node v$pt$1 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$2, v$pt$1);

        // Commit the state modification.
        yyState.commit();

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    } // End scope for v$pt$2.

    // Abort the state modification.
    yyState.abort();

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.CommaExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommaExpression(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fCommaExpression) 
      yyColumn.chunk2.fCommaExpression = pCommaExpression$1(yyStart);
    return yyColumn.chunk2.fCommaExpression;
  }

  /** Actually parse xtc.lang.C.CommaExpression. */
  private Result pCommaExpression$1(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pAssignmentExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pCommaExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.CommaExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCommaExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Comma>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pAssignmentExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$2 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("CommaExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("comma expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AssignmentExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignmentExpression(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAssignmentExpression) 
      yyColumn.chunk2.fAssignmentExpression = pAssignmentExpression$1(yyStart);
    return yyColumn.chunk2.fAssignmentExpression;
  }

  /** Actually parse xtc.lang.C.AssignmentExpression. */
  private Result pAssignmentExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Assignment>.

    yyResult = pUnaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pAssignmentOperator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pAssignmentExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("AssignmentExpression", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pConditionalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AssignmentOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignmentOperator(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Equal>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <PlusEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("+=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <MinusEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("-=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <TimesEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("*=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <OverEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("/=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <ModuloEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("%=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <LeftEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("<<=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <RightEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(">>=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <AndEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("&=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <XorEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("^=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <OrEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("|=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("assignment operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.ConditionalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConditionalExpression(final int yyStart) 
    throws IOException {

    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fConditionalExpression) 
      yyColumn.chunk2.fConditionalExpression = pConditionalExpression$1(yyStart);
    return yyColumn.chunk2.fConditionalExpression;
  }

  /** Actually parse xtc.lang.C.ConditionalExpression. */
  private Result pConditionalExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Conditional>.

    yyResult = pLogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("?")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyResult = pCommaExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$2 = Formatting.after1(v$pt$4, v$pt$3);

            yyResult = pConditionalExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("ConditionalExpression", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'?' expected", yyBase);
      }
    }

    // Alternative <IncompleteConditional>.

    if (GCC) {

      yyResult = pLogicalOrExpression(yyStart);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$6 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("?")) {
          final Node v$pt$5 = yyResult.semanticValue();
          final Node v$g$4 = Formatting.after1(v$pt$6, v$pt$5);

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
            final Node v$pt$7 = yyResult.semanticValue();
            final Node v$g$5 = Formatting.after1(null, v$pt$7);

            yyResult = pConditionalExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$6 = yyResult.semanticValue();

              yyValue = GNode.create("ConditionalExpression", v$g$4, v$g$5, v$g$6);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'?' expected", yyBase);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pLogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("conditional expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.LogicalOrExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalOrExpression(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fLogicalOrExpression) 
      yyColumn.chunk2.fLogicalOrExpression = pLogicalOrExpression$1(yyStart);
    return yyColumn.chunk2.fLogicalOrExpression;
  }

  /** Actually parse xtc.lang.C.LogicalOrExpression. */
  private Result pLogicalOrExpression$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pLogicalAndExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pLogicalOrExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.LogicalOrExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalOrExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Or>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("||")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pLogicalAndExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$2 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalOrExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical or expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.LogicalAndExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalAndExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pBitwiseOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pLogicalAndExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.LogicalAndExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalAndExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <And>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("&&")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pBitwiseOrExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$2 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalAndExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical and expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.BitwiseOrExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseOrExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pBitwiseXorExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBitwiseOrExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.BitwiseOrExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseOrExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Or>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("|")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pBitwiseXorExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$2 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseOrExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise or expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.BitwiseXorExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseXorExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pBitwiseAndExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBitwiseXorExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.BitwiseXorExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseXorExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Xor>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("^")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pBitwiseAndExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$2 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseXorExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise xor expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.BitwiseAndExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseAndExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pEqualityExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBitwiseAndExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.BitwiseAndExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseAndExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <And>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("&")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pEqualityExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$2 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseAndExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise and expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.EqualityExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pRelationalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pEqualityExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.EqualityExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pEqualityOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$2 = yyResult.semanticValue();

      yyResult = pRelationalExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("EqualityExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.EqualityOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityOperator(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Equal>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("==")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <NotEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("!=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("equality operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.RelationalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pShiftExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pRelationalExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.RelationalExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pRelationalOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$2 = yyResult.semanticValue();

      yyResult = pShiftExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("RelationalExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.RelationalOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalOperator(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <LessEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("<=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Less>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("<")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <GreaterEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(">=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Greater>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(">")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("relational operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.ShiftExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pAdditiveExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pShiftExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.ShiftExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pShiftOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$2 = yyResult.semanticValue();

      yyResult = pAdditiveExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("ShiftExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.ShiftOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftOperator(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Left>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("<<")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Right>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(">>")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("shift operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AdditiveExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pMultiplicativeExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pAdditiveExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.AdditiveExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pAdditiveOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$2 = yyResult.semanticValue();

      yyResult = pMultiplicativeExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("AdditiveExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AdditiveOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveOperator(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Plus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("+")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Minus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("-")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("additive operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.MultiplicativeExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pCastExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pMultiplicativeExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.MultiplicativeExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pMultiplicativeOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$2 = yyResult.semanticValue();

      yyResult = pCastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("MultiplicativeExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.MultiplicativeOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeOperator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Times>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("*")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Over>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("/")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Modulo>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("%")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("multiplicative operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.CastExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCastExpression(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fCastExpression) 
      yyColumn.chunk2.fCastExpression = pCastExpression$1(yyStart);
    return yyColumn.chunk2.fCastExpression;
  }

  /** Actually parse xtc.lang.C.CastExpression. */
  private Result pCastExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Cast>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pTypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$3 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          yyResult = pCastExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("CastExpression", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pUnaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("cast expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.UnaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnaryExpression(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fUnaryExpression) 
      yyColumn.chunk2.fUnaryExpression = pUnaryExpression$1(yyStart);
    return yyColumn.chunk2.fUnaryExpression;
  }

  /** Actually parse xtc.lang.C.UnaryExpression. */
  private Result pUnaryExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("sizeof")) {
      final Node v$pt$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyResult = pTypeName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
            final Node v$pt$3 = yyResult.semanticValue();

            yyPredMatched = false;

            yyPredResult = pSymbol(yyResult.index);
            if (yyPredResult.hasValue() &&
                ((Node)yyPredResult.semanticValue()).getTokenText().equals("{")) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {
              final Node v$g$1 = Formatting.variable().
                add(v$pt$1).add(v$pt$2).addNode(v$pt$4).add(v$pt$3);

              yyValue = GNode.create("SizeofExpression", v$g$1);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("unary expression expected", yyStart);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }

      // Nested alternative 2.

      yyResult = pUnaryExpression(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$5 = yyResult.semanticValue();
        final Node v$g$2 = Formatting.before1(v$pt$1, v$pt$5);

        yyValue = GNode.create("SizeofExpression", v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pAlignofKeyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyResult = pTypeName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
            final Node v$pt$3 = yyResult.semanticValue();

            yyPredMatched = false;

            yyPredResult = pSymbol(yyResult.index);
            if (yyPredResult.hasValue() &&
                ((Node)yyPredResult.semanticValue()).getTokenText().equals("{")) {

              yyPredMatched = true;
            }

            if (! yyPredMatched) {
              final Node v$g$1 = Formatting.variable().
                add(v$pt$1).add(v$pt$2).addNode(v$pt$4).add(v$pt$3);

              yyValue = GNode.create("AlignofExpression", v$g$1);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("unary expression expected", yyStart);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }

      // Nested alternative 2.

      yyResult = pUnaryExpression(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$5 = yyResult.semanticValue();
        final Node v$g$2 = Formatting.before1(v$pt$1, v$pt$5);

        yyValue = GNode.create("AlignofExpression", v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__builtin_offsetof")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyResult = pTypeName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$1 = Formatting.variable().
              add(v$pt$1).add(v$pt$2).addNode(v$pt$4).add(v$pt$3);

            yyResult = pPostfixExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$pt$6 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue() &&
                  ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
                final Node v$pt$5 = yyResult.semanticValue();
                final Node v$g$2 = Formatting.after1(v$pt$6, v$pt$5);

                yyValue = GNode.create("OffsetofExpression", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__builtin_types_compatible_p")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyResult = pTypeName(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$1 = Formatting.variable().
              add(v$pt$1).add(v$pt$2).addNode(v$pt$4).add(v$pt$3);

            yyResult = pTypeName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$pt$6 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue() &&
                  ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
                final Node v$pt$5 = yyResult.semanticValue();
                final Node v$g$2 = Formatting.after1(v$pt$6, v$pt$5);

                yyValue = GNode.create("TypeCompatibilityExpression", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 5.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("-")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pCastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = GNode.create("UnaryMinusExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 6.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("+")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pCastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = GNode.create("UnaryPlusExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 7.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("!")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pCastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = GNode.create("LogicalNegationExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 8.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("~")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pCastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = GNode.create("BitwiseNegationExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 9.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("&")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pCastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = GNode.create("AddressExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <LabelAddress>.

    if (GCC) {

      yyResult = pSymbol(yyStart);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("&&")) {
        final Node v$pt$1 = yyResult.semanticValue();

        yyResult = pIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

          yyValue = GNode.create("LabelAddressExpression", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 11.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("*")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pCastExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = GNode.create("IndirectionExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 12.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("++")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pUnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = GNode.create("PreincrementExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 13.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("--")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pUnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = GNode.create("PredecrementExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Extension>.

    if (GCC) {

      yyResult = pKeyword(yyStart);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("__extension__")) {
        final Node v$pt$1 = yyResult.semanticValue();

        yyResult = pCastExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

          yyValue = GNode.create("ExtensionExpression", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pPostfixExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("unary expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AlignofKeyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAlignofKeyword(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__alignof__")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("AlignofKeyword", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__alignof")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("AlignofKeyword", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("alignof keyword expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.PostfixExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostfixExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Compound>.

    yyResult = pCompoundLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$6 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pPostfixExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$7 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$7, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$8.
        final Pair<Action<Node>> v$8 = yyRepValue1.reverse();

        yyValue = apply(v$8, v$g$6, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$8.
    }

    // Alternative <Primary>.

    yyResult = pPrimaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$9 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pPostfixExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$10 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$10, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$11.
        final Pair<Action<Node>> v$11 = yyRepValue1.reverse();

        yyValue = apply(v$11, v$g$9, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$11.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.PostfixExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostfixExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyOption1;
    Node         yyOpValue1;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("[")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pCommaExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$3 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("]")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$2 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("SubscriptExpression", v$1, v$g$2);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(".")) {
      final Node v$pt$4 = yyResult.semanticValue();

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$5 = yyResult.semanticValue();
        final Node v$g$3 = Formatting.before1(v$pt$4, v$pt$5);

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("DirectComponentSelection", v$1, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("->")) {
      final Node v$pt$6 = yyResult.semanticValue();

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$7 = yyResult.semanticValue();
        final Node v$g$4 = Formatting.before1(v$pt$6, v$pt$7);

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("IndirectComponentSelection", v$1, v$g$4);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$pt$8 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pExpressionList(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$pt$10.
        final Node v$pt$10 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
          final Node v$pt$9 = yyResult.semanticValue();
          final Node v$g$5 = Formatting.round1(v$pt$8, v$pt$10, v$pt$9);

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("FunctionCall", v$1, v$g$5);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      } // End scope for v$pt$10.
    }

    // Alternative 5.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("++")) {
      final Node v$pt$11 = yyResult.semanticValue();

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          Node yyValue = GNode.create("PostincrementExpression", v$1);
          yyValue = Formatting.after1(yyValue, v$pt$11);
          return yyValue;
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("--")) {
      final Node v$pt$12 = yyResult.semanticValue();

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          Node yyValue = GNode.create("PostdecrementExpression", v$1);
          yyValue = Formatting.after1(yyValue, v$pt$12);
          return yyValue;
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("postfix expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.ExpressionList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpressionList(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fExpressionList) 
      yyColumn.chunk2.fExpressionList = pExpressionList$1(yyStart);
    return yyColumn.chunk2.fExpressionList;
  }

  /** Actually parse xtc.lang.C.ExpressionList. */
  private Result pExpressionList$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Expressions>.

    yyResult = pAssignmentExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pExpressionList$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("ExpressionList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.ExpressionList$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpressionList$$Star1(final int yyStart) 
    throws IOException {

    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExpressionList$$Star1) 
      yyColumn.chunk3.fExpressionList$$Star1 = pExpressionList$$Star1$1(yyStart);
    return yyColumn.chunk3.fExpressionList$$Star1;
  }

  /** Actually parse xtc.lang.C.ExpressionList$$Star1. */
  private Result pExpressionList$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pAssignmentExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyResult = pExpressionList$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.CompoundLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCompoundLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pTypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$4 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
          final Node v$pt$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$1 = Formatting.variable().
              add(v$pt$1).addNode(v$pt$4).add(v$pt$2).add(v$pt$3);

            yyResult = pInitializerList(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$pt$7 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue() &&
                  ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
                final Node v$el$1 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$1;
              } else {
                yyError = yyError.select("',' expected", yyBase);
              }
              { // Start scope for v$pt$5.
                final Node v$pt$5 = yyOpValue1;

                yyBase   = yyOption1;
                yyResult = pSymbol(yyBase);
                if (yyResult.hasValue() &&
                    ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
                  final Node v$pt$6 = yyResult.semanticValue();
                  final Node v$g$2 = Formatting.variable().
                    addNode(v$pt$7).add(v$pt$5).add(v$pt$6);

                  yyValue = GNode.create("CompoundLiteral", v$g$1, v$g$2);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                } else {
                  yyError = yyError.select("'}' expected", yyBase);
                }
              } // End scope for v$pt$5.
            }
          } else {
            yyError = yyError.select("'{' expected", yyBase);
          }
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("compound literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.PrimaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimaryExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Constant>.

    yyResult = pConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("PrimaryIdentifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    if (GCC) {

      yyResult = pSymbol(yyStart);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
        final Node v$pt$1 = yyResult.semanticValue();

        yyResult = pCompoundStatement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$3 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$g$1 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

            yyValue = GNode.create("StatementAsExpression", v$g$1);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      }
    }

    // Alternative 4.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__builtin_va_arg")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyResult = pAssignmentExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$1 = Formatting.variable().
              add(v$pt$1).add(v$pt$2).addNode(v$pt$4).add(v$pt$3);

            yyResult = pTypeName(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$pt$6 = yyResult.semanticValue();

              yyBase   = yyResult.index;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue() &&
                  ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
                final Node v$pt$5 = yyResult.semanticValue();
                final Node v$g$2 = Formatting.after1(v$pt$6, v$pt$5);

                yyValue = GNode.create("VariableArgumentAccess", v$g$1, v$g$2);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative <ParenthesizedExpression>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pCommaExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$3 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
          final Node v$pt$2 = yyResult.semanticValue();
          yyValue = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("primary expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.PrimaryIdentifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimaryIdentifier(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("PrimaryIdentifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AssemblyDefinition.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssemblyDefinition(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSimpleAssemblyExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyValue = GNode.create("AssemblyDefinition", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.SimpleAssemblyExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSimpleAssemblyExpression(final int yyStart) 
    throws IOException {

    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fSimpleAssemblyExpression) 
      yyColumn.chunk3.fSimpleAssemblyExpression = pSimpleAssemblyExpression$1(yyStart);
    return yyColumn.chunk3.fSimpleAssemblyExpression;
  }

  /** Actually parse xtc.lang.C.SimpleAssemblyExpression. */
  private Result pSimpleAssemblyExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAsmKeyword(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyResult = pStringConstant(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$1 = Formatting.variable().
              add(v$pt$1).add(v$pt$2).addNode(v$pt$4).add(v$pt$3);

            yyValue = GNode.create("SimpleAssemblyExpression", v$g$1);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AssemblyArgument.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssemblyArgument(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
        final Node v$pt$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pAssemblyOperands(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$pt$2.
          final Node v$pt$2 = yyOpValue1;
          final Node v$g$2 = Formatting.before1(v$pt$1, v$pt$2);

          final int yyChoice2 = yyOption1;

          // Nested alternative 1.

          yyBase   = yyChoice2;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
            final Node v$pt$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pAssemblyOperands(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$pt$4.
              final Node v$pt$4 = yyOpValue1;
              final Node v$g$3 = Formatting.before1(v$pt$3, v$pt$4);

              final int yyChoice3 = yyOption1;

              // Nested alternative 1.

              yyBase   = yyChoice3;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue() &&
                  ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
                final Node v$pt$5 = yyResult.semanticValue();

                yyResult = pAssemblyClobbers(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$pt$6 = yyResult.semanticValue();
                  final Node v$g$4 = Formatting.before1(v$pt$5, v$pt$6);

                  yyValue = GNode.create("AssemblyArgument", v$g$1, v$g$2, v$g$3, v$g$4);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                }
              } else {
                yyError = yyError.select("':' expected", yyBase);
              }

              // Nested alternative 2.

              yyValue = GNode.create("AssemblyArgument", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyChoice3, yyError);
            } // End scope for v$pt$4.
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }

          // Nested alternative 2.

          yyValue = GNode.create("AssemblyArgument", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice2, yyError);
        } // End scope for v$pt$2.
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }

      // Nested alternative 2.

      yyValue = GNode.create("AssemblyArgument", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AssemblyOperands.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssemblyOperands(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fAssemblyOperands) 
      yyColumn.chunk3.fAssemblyOperands = pAssemblyOperands$1(yyStart);
    return yyColumn.chunk3.fAssemblyOperands;
  }

  /** Actually parse xtc.lang.C.AssemblyOperands. */
  private Result pAssemblyOperands$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAssemblyOperand(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pAssemblyOperands$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("AssemblyOperands", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.AssemblyOperands$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssemblyOperands$$Star1(final int yyStart) 
    throws IOException {

    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fAssemblyOperands$$Star1) 
      yyColumn.chunk3.fAssemblyOperands$$Star1 = pAssemblyOperands$$Star1$1(yyStart);
    return yyColumn.chunk3.fAssemblyOperands$$Star1;
  }

  /** Actually parse xtc.lang.C.AssemblyOperands$$Star1. */
  private Result pAssemblyOperands$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pAssemblyOperand(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyResult = pAssemblyOperands$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AssemblyOperand.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssemblyOperand(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fAssemblyOperand) 
      yyColumn.chunk3.fAssemblyOperand = pAssemblyOperand$1(yyStart);
    return yyColumn.chunk3.fAssemblyOperand;
  }

  /** Actually parse xtc.lang.C.AssemblyOperand. */
  private Result pAssemblyOperand$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pSymbol(yyBase);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("[")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pWord(yyResult.index);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$pt$3 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("]")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$el$1 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    } else {
      yyError = yyError.select("'[' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pStringConstant(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$5 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
          final Node v$pt$4 = yyResult.semanticValue();
          final Node v$g$2 = Formatting.after1(v$pt$5, v$pt$4);

          yyResult = pCommaExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$pt$7 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue() &&
                ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
              final Node v$pt$6 = yyResult.semanticValue();
              final Node v$g$3 = Formatting.after1(v$pt$7, v$pt$6);

              yyValue = GNode.create("AssemblyOperand", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AssemblyClobbers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssemblyClobbers(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyResult = pStringConstant(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("AssemblyClobbers", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.C.AsmKeyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAsmKeyword(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fAsmKeyword) 
      yyColumn.chunk3.fAsmKeyword = pAsmKeyword$1(yyStart);
    return yyColumn.chunk3.fAsmKeyword;
  }

  /** Actually parse xtc.lang.C.AsmKeyword. */
  private Result pAsmKeyword$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("asm")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("AsmKeyword", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__asm")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("AsmKeyword", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pKeyword(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("__asm__")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("AsmKeyword", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("asm keyword expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.Constant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConstant(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFloatingConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$1 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$2, v$pt$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pIntegerConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$4 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$3 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$4, v$pt$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pCharacterConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pStringConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.IntegerConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerConstant(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Hex>.

    yyResult = pHexConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("IntegerConstant", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Octal>.

    yyResult = pOctalConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("IntegerConstant", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Decimal>.

    yyResult = pDecimalConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("IntegerConstant", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.DecimalConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalConstant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    int        yyOption1;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
                {
                  yyRepetition1 = yyIndex;
                  continue;
                }

              default:
                /* No match. */
              }
            }
            break;
          }

          yyOption1  = yyRepetition1;

          yyResult = pIntegerSuffix(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          yyValue = new TextToken(difference(yyStart, yyOption1));
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("decimal constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.HexConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexConstant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pHexPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
          case 'A':
          case 'B':
          case 'C':
          case 'D':
          case 'E':
          case 'F':
          case 'a':
          case 'b':
          case 'c':
          case 'd':
          case 'e':
          case 'f':
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyOption1  = yyRepetition1;

        yyResult = pIntegerSuffix(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }

        yyValue = new TextToken(difference(yyStart, yyOption1));
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("hex constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.HexPrefix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexPrefix(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (-1 != yyC) {
        yyIndex = yyIndex + 1;

        switch (yyC) {
        case 'X':
        case 'x':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        default:
          /* No match. */
        }
      }
    }

    // Done.
    yyError = yyError.select("hex prefix expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.OctalConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOctalConstant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    int        yyOption1;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
            {
              yyRepetition1 = yyIndex;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      yyOption1  = yyRepetition1;

      yyResult = pIntegerSuffix(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }

      yyValue = new TextToken(difference(yyStart, yyOption1));
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("octal constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.IntegerSuffix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerSuffix(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLongLongSuffix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case 'U':
        case 'u':
          {
            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyValue = null;

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'L':
      case 'l':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case 'U':
            case 'u':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case 'U':
      case 'u':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case 'l':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('l' == yyC) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            case 'L':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;
                  if ('L' == yyC) {

                    yyValue = null;

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case 'L':
            case 'l':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 3.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("integer suffix expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.LongLongSuffix.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLongLongSuffix(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'l':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('l' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case 'L':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('L' == yyC) {

              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("long long suffix expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.FloatingConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatingConstant(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Decimal>.

    yyResult = pDecimalFloatingConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("FloatingConstant", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Hex>.

    yyResult = pHexFloatingConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("FloatingConstant", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.DecimalFloatingConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalFloatingConstant(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyC = character(yyRepetition1);
      if ('.' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
              {
                yyRepetition1 = yyIndex;
                continue;
              }

            default:
              /* No match. */
            }
          }
          break;
        }

        yyOption1  = yyRepetition1;

        yyResult = pExponent(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }


        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'F':
          case 'L':
          case 'f':
          case 'l':
            {
              yyOption1  = yyIndex;
            }
            break;

          default:
            /* No match. */
          }
        }

        yyValue = new TextToken(difference(yyStart, yyOption1));
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyOption1  = yyRepetition1;

        yyResult = pExponent(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }


        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'F':
          case 'L':
          case 'f':
          case 'l':
            {
              yyOption1  = yyIndex;
            }
            break;

          default:
            /* No match. */
          }
        }

        yyValue = new TextToken(difference(yyStart, yyOption1));
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Alternative 3.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyResult = pExponent(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;

        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'F':
          case 'L':
          case 'f':
          case 'l':
            {
              yyOption1  = yyIndex;
            }
            break;

          default:
            /* No match. */
          }
        }

        yyValue = new TextToken(difference(yyStart, yyOption1));
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("decimal floating constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.HexFloatingConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexFloatingConstant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pHexPrefix(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
          case 'A':
          case 'B':
          case 'C':
          case 'D':
          case 'E':
          case 'F':
          case 'a':
          case 'b':
          case 'c':
          case 'd':
          case 'e':
          case 'f':
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyC = character(yyRepetition1);
        if ('.' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyRepetition1 = yyIndex;
          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
              case 'A':
              case 'B':
              case 'C':
              case 'D':
              case 'E':
              case 'F':
              case 'a':
              case 'b':
              case 'c':
              case 'd':
              case 'e':
              case 'f':
                {
                  yyRepetition1 = yyIndex;
                  continue;
                }

              default:
                /* No match. */
              }
            }
            break;
          }

          yyResult = pBinaryExponent(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;

            yyC = character(yyOption1);
            if (-1 != yyC) {
              yyIndex = yyOption1 + 1;

              switch (yyC) {
              case 'F':
              case 'L':
              case 'f':
              case 'l':
                {
                  yyOption1  = yyIndex;
                }
                break;

              default:
                /* No match. */
              }
            }

            yyValue = new TextToken(difference(yyStart, yyOption1));
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyOption1, yyError);
          }
        }
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if ('.' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyRepetition1 = yyIndex;
        yyRepeated1   = false;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
              {
                yyRepetition1 = yyIndex;
                yyRepeated1   = true;
                continue;
              }

            default:
              /* No match. */
            }
          }
          break;
        }

        if (yyRepeated1) {

          yyResult = pBinaryExponent(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;

            yyC = character(yyOption1);
            if (-1 != yyC) {
              yyIndex = yyOption1 + 1;

              switch (yyC) {
              case 'F':
              case 'L':
              case 'f':
              case 'l':
                {
                  yyOption1  = yyIndex;
                }
                break;

              default:
                /* No match. */
              }
            }

            yyValue = new TextToken(difference(yyStart, yyOption1));
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyOption1, yyError);
          }
        }
      }

      // Nested alternative 3.

      yyRepetition1 = yyChoice1;
      yyRepeated1   = false;
      while (true) {

        yyC = character(yyRepetition1);
        if (-1 != yyC) {
          yyIndex = yyRepetition1 + 1;

          switch (yyC) {
          case '0':
          case '1':
          case '2':
          case '3':
          case '4':
          case '5':
          case '6':
          case '7':
          case '8':
          case '9':
          case 'A':
          case 'B':
          case 'C':
          case 'D':
          case 'E':
          case 'F':
          case 'a':
          case 'b':
          case 'c':
          case 'd':
          case 'e':
          case 'f':
            {
              yyRepetition1 = yyIndex;
              yyRepeated1   = true;
              continue;
            }

          default:
            /* No match. */
          }
        }
        break;
      }

      if (yyRepeated1) {

        yyResult = pBinaryExponent(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;

          yyC = character(yyOption1);
          if (-1 != yyC) {
            yyIndex = yyOption1 + 1;

            switch (yyC) {
            case 'F':
            case 'L':
            case 'f':
            case 'l':
              {
                yyOption1  = yyIndex;
              }
              break;

            default:
              /* No match. */
            }
          }

          yyValue = new TextToken(difference(yyStart, yyOption1));
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("hex floating constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.Exponent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponent(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExponent) 
      yyColumn.chunk3.fExponent = pExponent$1(yyStart);
    return yyColumn.chunk3.fExponent;
  }

  /** Actually parse xtc.lang.CConstant.Exponent. */
  private Result pExponent$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'E':
      case 'e':
        {
          yyOption1  = yyIndex;

          yyC = character(yyOption1);
          if (-1 != yyC) {
            yyIndex = yyOption1 + 1;

            switch (yyC) {
            case '+':
            case '-':
              {
                yyOption1  = yyIndex;
              }
              break;

            default:
              /* No match. */
            }
          }

          yyResult = p$$Shared2(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("exponent expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.$$Shared2.
   * This nonterminal represents the duplicate productions 
   * xtc.lang.C.Exponent$$Plus1 and xtc.lang.C.BinaryExponent$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result p$$Shared2(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.f$$Shared2) 
      yyColumn.chunk3.f$$Shared2 = p$$Shared2$1(yyStart);
    return yyColumn.chunk3.f$$Shared2;
  }

  /** Actually parse xtc.lang.C.$$Shared2. */
  private Result p$$Shared2$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyResult = p$$Shared2(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select(" expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.BinaryExponent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBinaryExponent(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fBinaryExponent) 
      yyColumn.chunk3.fBinaryExponent = pBinaryExponent$1(yyStart);
    return yyColumn.chunk3.fBinaryExponent;
  }

  /** Actually parse xtc.lang.CConstant.BinaryExponent. */
  private Result pBinaryExponent$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'P':
      case 'p':
        {
          yyOption1  = yyIndex;

          yyC = character(yyOption1);
          if (-1 != yyC) {
            yyIndex = yyOption1 + 1;

            switch (yyC) {
            case '+':
            case '-':
              {
                yyOption1  = yyIndex;
              }
              break;

            default:
              /* No match. */
            }
          }

          yyResult = p$$Shared2(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("binary exponent expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.CharacterConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterConstant(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWideCharacterLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$pt$2 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyValue = GNode.create("CharacterConstant", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pCharacterLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$pt$4 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$3 = yyResult.semanticValue();
        final Node v$g$2 = Formatting.after1(v$pt$4, v$pt$3);

        yyValue = GNode.create("CharacterConstant", v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.WideCharacterLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWideCharacterLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('L' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pCharacterLiteral(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new TextToken(difference(yyStart, yyResult.index));
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("wide character literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.CharacterLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterLiteral(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fCharacterLiteral) 
      yyColumn.chunk3.fCharacterLiteral = pCharacterLiteral$1(yyStart);
    return yyColumn.chunk3.fCharacterLiteral;
  }

  /** Actually parse xtc.lang.CConstant.CharacterLiteral. */
  private Result pCharacterLiteral$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\'' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pCharacterContents(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyC = character(yyResult.index);
        if ('\'' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = new TextToken(difference(yyStart, yyIndex));
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("character literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.CharacterContents.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterContents(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '\\':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyResult = pEscapeCode(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              yyRepeated1   = true;
              continue;
            }

            // Nested alternative 2.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;

              switch (yyC) {
              case 'u':
                {
                  yyResult = pHexQuad(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyRepetition1 = yyResult.index;
                    yyRepeated1   = true;
                    continue;
                  }
                }
                break;

              case 'U':
                {
                  yyResult = pHexQuad(yyIndex);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {

                    yyResult = pHexQuad(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {

                      yyRepetition1 = yyResult.index;
                      yyRepeated1   = true;
                      continue;
                    }
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '\n':
        case '\r':
        case '\'':
        case '\\':
          /* No match. */
          break;

        default:
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("character contents expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.StringConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringConstant(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fStringConstant) 
      yyColumn.chunk4.fStringConstant = pStringConstant$1(yyStart);
    return yyColumn.chunk4.fStringConstant;
  }

  /** Actually parse xtc.lang.CConstant.StringConstant. */
  private Result pStringConstant$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringConstant$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("StringConstant", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.StringConstant$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringConstant$$Choice1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWideStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$pt$2 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$1 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$2, v$pt$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$pt$4 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$3 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$4, v$pt$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.C.StringConstant$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringConstant$$Plus1(final int yyStart) 
    throws IOException {

    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fStringConstant$$Plus1) 
      yyColumn.chunk4.fStringConstant$$Plus1 = pStringConstant$$Plus1$1(yyStart);
    return yyColumn.chunk4.fStringConstant$$Plus1;
  }

  /** Actually parse xtc.lang.C.StringConstant$$Plus1. */
  private Result pStringConstant$$Plus1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringConstant$$Choice1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pStringConstant$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$4 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$4);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Node>(v$el$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.WideStringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWideStringLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('L' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pStringLiteral(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = new TextToken(difference(yyStart, yyResult.index));
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("wide string literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.StringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteral(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fStringLiteral) 
      yyColumn.chunk4.fStringLiteral = pStringLiteral$1(yyStart);
    return yyColumn.chunk4.fStringLiteral;
  }

  /** Actually parse xtc.lang.CConstant.StringLiteral. */
  private Result pStringLiteral$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pStringContents(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyC = character(yyResult.index);
        if ('\"' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = new TextToken(difference(yyStart, yyIndex));
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("string literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.StringContents.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringContents(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '\\':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyResult = pEscapeCode(yyChoice2);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              continue;
            }

            // Nested alternative 2.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;

              switch (yyC) {
              case 'u':
                {
                  yyResult = pHexQuad(yyIndex);
                  yyError  = yyResult.select(yyError, yyRepetition1);
                  if (yyResult.hasValue()) {

                    yyRepetition1 = yyResult.index;
                    continue;
                  }
                }
                break;

              case 'U':
                {
                  yyResult = pHexQuad(yyIndex);
                  yyError  = yyResult.select(yyError, yyRepetition1);
                  if (yyResult.hasValue()) {

                    yyResult = pHexQuad(yyResult.index);
                    yyError  = yyResult.select(yyError, yyRepetition1);
                    if (yyResult.hasValue()) {

                      yyRepetition1 = yyResult.index;
                      continue;
                    }
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '\n':
        case '\r':
        case '\"':
        case '\\':
          /* No match. */
          break;

        default:
          {
            yyRepetition1 = yyIndex;
            continue;
          }
        }
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.EscapeCode.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEscapeCode(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\"':
      case '\'':
      case '?':
      case '\\':
      case 'a':
      case 'b':
      case 'f':
      case 'n':
      case 'r':
      case 't':
      case 'v':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
              {
                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                    {
                      yyValue = null;

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyValue = null;

                return new SemanticValue(yyValue, yyChoice2, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case 'x':
        {
          yyRepetition1 = yyIndex;
          yyRepeated1   = false;
          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
              case 'A':
              case 'B':
              case 'C':
              case 'D':
              case 'E':
              case 'F':
              case 'a':
              case 'b':
              case 'c':
              case 'd':
              case 'e':
              case 'f':
                {
                  yyRepetition1 = yyIndex;
                  yyRepeated1   = true;
                  continue;
                }

              default:
                /* No match. */
              }
            }
            break;
          }

          if (yyRepeated1) {

            yyValue = null;

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("escape code expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CConstant.HexQuad.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexQuad(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
      case 'A':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'a':
      case 'b':
      case 'c':
      case 'd':
      case 'e':
      case 'f':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
            case 'A':
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'a':
            case 'b':
            case 'c':
            case 'd':
            case 'e':
            case 'f':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case 'A':
                        case 'B':
                        case 'C':
                        case 'D':
                        case 'E':
                        case 'F':
                        case 'a':
                        case 'b':
                        case 'c':
                        case 'd':
                        case 'e':
                        case 'f':
                          {
                            yyValue = null;

                            return new SemanticValue(yyValue, yyIndex, yyError);
                          }

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("hex quad expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CIdentifier.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fIdentifier) 
      yyColumn.chunk4.fIdentifier = pIdentifier$1(yyStart);
    return yyColumn.chunk4.fIdentifier;
  }

  /** Actually parse xtc.lang.CIdentifier.Identifier. */
  private Result pIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (! contains(C_KEYWORDS, toText(yyValue))) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("identifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CIdentifier.Keyword.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pKeyword(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fKeyword) 
      yyColumn.chunk4.fKeyword = pKeyword$1(yyStart);
    return yyColumn.chunk4.fKeyword;
  }

  /** Actually parse xtc.lang.CIdentifier.Keyword. */
  private Result pKeyword$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (contains(C_KEYWORDS, toText(yyValue))) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("keyword expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CIdentifier.Word.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWord(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fWord) 
      yyColumn.chunk4.fWord = pWord$1(yyStart);
    return yyColumn.chunk4.fWord;
  }

  /** Actually parse xtc.lang.CIdentifier.Word. */
  private Result pWord$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWordCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$pt$2 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$1 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$2, v$pt$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CIdentifier.WordCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWordCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      if ((('A' <= yyC) && (yyC <= 'Z')) ||
          ('_' == yyC) ||
          (('a' <= yyC) && (yyC <= 'z'))) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            if ((('0' <= yyC) && (yyC <= '9')) ||
                (('A' <= yyC) && (yyC <= 'Z')) ||
                ('_' == yyC) ||
                (('a' <= yyC) && (yyC <= 'z'))) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = new TextToken(difference(yyStart, yyRepetition1));
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("word characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSymbol.Symbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol(final int yyStart) throws IOException {
    CReaderColumn yyColumn = (CReaderColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fSymbol) 
      yyColumn.chunk4.fSymbol = pSymbol$1(yyStart);
    return yyColumn.chunk4.fSymbol;
  }

  /** Actually parse xtc.lang.CSymbol.Symbol. */
  private Result pSymbol$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbolCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$pt$2 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$1 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$2, v$pt$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSymbol.SymbolCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbolCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '>':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '>':
              {
                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;
                  if ('=' == yyC) {

                    yyValue = new TextToken(">>=");
                    yyValue.setLocation(location(yyStart));

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }

                // Nested alternative 2.

                yyValue = new TextToken(">>");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyChoice2, yyError);
              }

            case '=':
              {
                yyValue = new TextToken(">=");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken(">");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '<':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '<':
              {
                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;
                  if ('=' == yyC) {

                    yyValue = new TextToken("<<=");
                    yyValue.setLocation(location(yyStart));

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }

                // Nested alternative 2.

                yyValue = new TextToken("<<");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyChoice2, yyError);
              }

            case '=':
              {
                yyValue = new TextToken("<=");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("<");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '.':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('.' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('.' == yyC) {

                  yyValue = new TextToken("...");
                  yyValue.setLocation(location(yyStart));

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken(".");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '+':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = new TextToken("+=");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '+':
              {
                yyValue = new TextToken("++");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("+");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '-':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = new TextToken("-=");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '-':
              {
                yyValue = new TextToken("--");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '>':
              {
                yyValue = new TextToken("->");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("-");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '*':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = new TextToken("*=");
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("*");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '/':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = new TextToken("/=");
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("/");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '%':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = new TextToken("%=");
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("%");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '&':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = new TextToken("&=");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '&':
              {
                yyValue = new TextToken("&&");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("&");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '^':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = new TextToken("^=");
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("^");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '|':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = new TextToken("|=");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '|':
              {
                yyValue = new TextToken("||");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("|");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '=':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = new TextToken("==");
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("=");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '!':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = new TextToken("!=");
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("!");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case ';':
        {
          yyValue = new TextToken(";");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ':':
        {
          yyValue = new TextToken(":");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ',':
        {
          yyValue = new TextToken(",");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '{':
        {
          yyValue = new TextToken("{");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = new TextToken("}");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '(':
        {
          yyValue = new TextToken("(");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ')':
        {
          yyValue = new TextToken(")");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = new TextToken("[");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = new TextToken("]");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '~':
        {
          yyValue = new TextToken("~");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '?':
        {
          yyValue = new TextToken("?");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("symbol characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSpacing.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    int        yyRepetition2;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '/':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;

              switch (yyC) {
              case '*':
                {
                  yyRepetition2 = yyIndex;
                  while (true) {

                    final int yyChoice2 = yyRepetition2;

                    // Nested alternative 1.

                    yyC = character(yyChoice2);
                    if (-1 != yyC) {
                      yyIndex = yyChoice2 + 1;

                      switch (yyC) {
                      case '*':
                        {
                          yyPredMatched = false;

                          yyC = character(yyIndex);
                          if ('/' == yyC) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyRepetition2 = yyIndex;
                            continue;
                          } else {
                            yyError = yyError.select("spacing expected", yyStart);
                          }
                        }
                        break;

                      default:
                        {
                          yyRepetition2 = yyIndex;
                          continue;
                        }
                      }
                    }
                    break;
                  }

                  yyBase = yyRepetition2;
                  yyC    = character(yyBase);
                  if ('*' == yyC) {
                    yyIndex = yyRepetition2 + 1;

                    yyC = character(yyIndex);
                    if ('/' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyRepetition1 = yyIndex;
                      continue;
                    } else {
                      yyError = yyError.select("'*/' expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("'*/' expected", yyBase);
                  }
                }
                break;

              case '/':
                {
                  yyRepetition2 = yyIndex;
                  while (true) {

                    yyC = character(yyRepetition2);
                    if (-1 != yyC) {
                      yyIndex = yyRepetition2 + 1;

                      switch (yyC) {
                      case '\n':
                      case '\r':
                        /* No match. */
                        break;

                      default:
                        {
                          yyRepetition2 = yyIndex;
                          continue;
                        }
                      }
                    }
                    break;
                  }

                  yyPredResult = pLineTerminator(yyRepetition2);
                  yyError      = yyPredResult.select(yyError);
                  if (yyPredResult.hasValue()) {

                    yyRepetition1 = yyRepetition2;
                    continue;
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
          break;

        case '\r':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('\n' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyResult = pDirective(yyIndex);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {

                yyRepetition1 = yyResult.index;
                continue;
              }
            }

            // Nested alternative 2.

            yyResult = pDirective(yyChoice2);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              continue;
            }
          }
          break;

        case '\n':
          {
            yyResult = pDirective(yyIndex);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {

              yyRepetition1 = yyResult.index;
              continue;
            }
          }
          break;

        default:
          /* No match. */
        }
      }
      break;
    }

    yyValue = new TextToken(difference(yyStart, yyRepetition1));
    yyValue.setLocation(location(yyStart));

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSpacing.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ' ':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\t':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSpacing.LineTerminator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineTerminator(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if ('\n' == yyC) {
            yyIndex = yyChoice1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("line terminator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSpacing.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("end of file expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSpacing.Directive.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDirective(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    int        yyOption1;
    String     yyOpValue1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('#' == yyC) {
      yyIndex = yyStart + 1;

      final int yyChoice1 = yyIndex;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (' ' == yyC) {
        yyIndex = yyChoice1 + 1;

        yyResult = pLineNumber(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final String line = yyResult.semanticValue();

          yyC = character(yyResult.index);
          if (' ' == yyC) {
            yyIndex = yyResult.index + 1;

            yyC = character(yyIndex);
            if ('\"' == yyC) {
              yyIndex = yyIndex + 1;

              yyResult = pFileName(yyIndex);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final String file = yyResult.semanticValue();

                yyC = character(yyResult.index);
                if ('\"' == yyC) {
                  yyIndex = yyResult.index + 1;

                  yyOption1  = yyIndex;
                  yyOpValue1 = null;

                  yyBase = yyOption1;
                  yyC    = character(yyBase);
                  if (' ' == yyC) {
                    yyIndex = yyOption1 + 1;

                    yyC = character(yyIndex);
                    if ('1' == yyC) {
                      yyIndex = yyIndex + 1;
                      final String v$el$1 = " 1";

                      yyOption1  = yyIndex;
                      yyOpValue1 = v$el$1;
                    } else {
                      yyError = yyError.select("' 1' expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("' 1' expected", yyBase);
                  }
                  { // Start scope for f1.
                    final String f1 = yyOpValue1;

                    yyOpValue1 = null;

                    yyBase = yyOption1;
                    yyC    = character(yyBase);
                    if (' ' == yyC) {
                      yyIndex = yyOption1 + 1;

                      yyC = character(yyIndex);
                      if ('2' == yyC) {
                        yyIndex = yyIndex + 1;
                        final String v$el$2 = " 2";

                        yyOption1  = yyIndex;
                        yyOpValue1 = v$el$2;
                      } else {
                        yyError = yyError.select("' 2' expected", yyBase);
                      }
                    } else {
                      yyError = yyError.select("' 2' expected", yyBase);
                    }
                    { // Start scope for f2.
                      final String f2 = yyOpValue1;

                      yyOpValue1 = null;

                      yyBase = yyOption1;
                      yyC    = character(yyBase);
                      if (' ' == yyC) {
                        yyIndex = yyOption1 + 1;

                        yyC = character(yyIndex);
                        if ('3' == yyC) {
                          yyIndex = yyIndex + 1;
                          final String v$el$3 = " 3";

                          yyOption1  = yyIndex;
                          yyOpValue1 = v$el$3;
                        } else {
                          yyError = yyError.select("' 3' expected", yyBase);
                        }
                      } else {
                        yyError = yyError.select("' 3' expected", yyBase);
                      }
                      { // Start scope for f3.
                        final String f3 = yyOpValue1;

                        yyOpValue1 = null;

                        yyBase = yyOption1;
                        yyC    = character(yyBase);
                        if (' ' == yyC) {
                          yyIndex = yyOption1 + 1;

                          yyC = character(yyIndex);
                          if ('4' == yyC) {
                            yyIndex = yyIndex + 1;
                            final String v$el$4 = " 4";

                            yyOption1  = yyIndex;
                            yyOpValue1 = v$el$4;
                          } else {
                            yyError = yyError.select("' 4' expected", yyBase);
                          }
                        } else {
                          yyError = yyError.select("' 4' expected", yyBase);
                        }
                        { // Start scope for f4.
                          final String f4 = yyOpValue1;

                          yyPredResult = pLineTerminator(yyOption1);
                          yyError      = yyPredResult.select(yyError);
                          if (yyPredResult.hasValue()) {

                            final int lineNo = Integer.parseInt(line);
                            if (RELOCATE) setLocation(yyStart, file, lineNo-1, FIRST_COLUMN);
                            yyState.lineMarker(file, lineNo, f1, f2, f3, f4, location(yyStart));

                            yyValue = null;

                            return new SemanticValue(yyValue, yyOption1, yyError);
                          }
                        } // End scope for f4.
                      } // End scope for f3.
                    } // End scope for f2.
                  } // End scope for f1.
                }
              }
            }
          }
        }
      }

      // Nested alternative 2.

      yyRepetition1 = yyChoice1;
      while (true) {

        yyResult = pSpace(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {

          yyRepetition1 = yyResult.index;
          continue;
        }
        break;
      }
      { // Start scope for nested choice.

        final int yyChoice2 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice2);
        if (-1 != yyC) {
          yyIndex = yyChoice2 + 1;

          switch (yyC) {
          case 'p':
            {
              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('r' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('a' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('g' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('m' == yyC) {

                              yyC = character(yyIndex);
                              if (-1 != yyC) {
                                yyIndex = yyIndex + 1;
                                if ('a' == yyC) {

                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;
                                    if (' ' == yyC) {

                                      yyResult = pPragma(yyIndex);
                                      yyError  = yyResult.select(yyError);
                                      if (yyResult.hasValue()) {
                                        final String pragma = yyResult.semanticValue();

                                        yyPredResult = 
                                          pLineTerminator(yyResult.index);
                                        yyError      = 
                                          yyPredResult.select(yyError);
                                        if (yyPredResult.hasValue()) {

                                          yyState.pragma(pragma, location(yyStart));

                                          yyValue = null;

                                          return yyResult.createValue(yyValue, yyError);
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            break;

          case 'i':
            {
              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('d' == yyC) {

                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;
                    if ('e' == yyC) {

                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;
                        if ('n' == yyC) {

                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;
                            if ('t' == yyC) {

                              yyRepetition1 = yyIndex;
                              yyRepeated1   = false;
                              while (true) {

                                yyResult = pSpace(yyRepetition1);
                                yyError  = yyResult.select(yyError);
                                if (yyResult.hasValue()) {

                                  yyRepetition1 = yyResult.index;
                                  yyRepeated1   = true;
                                  continue;
                                }
                                break;
                              }

                              if (yyRepeated1) {

                                yyC = character(yyRepetition1);
                                if ('\"' == yyC) {
                                  yyIndex = yyRepetition1 + 1;

                                  yyResult = pFileName(yyIndex);
                                  yyError  = yyResult.select(yyError);
                                  if (yyResult.hasValue()) {
                                    final String s = yyResult.semanticValue();

                                    yyC = character(yyResult.index);
                                    if ('\"' == yyC) {
                                      yyIndex = yyResult.index + 1;

                                      yyPredResult = pLineTerminator(yyIndex);
                                      yyError      = 
                                        yyPredResult.select(yyError);
                                      if (yyPredResult.hasValue()) {

                                        yyState.ident(s, location(yyStart));

                                        yyValue = null;

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            break;

          default:
            /* No match. */
          }
        }
      } // End scope for nested choice.
    }

    // Alternative 2.

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSpacing.LineNumber.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLineNumber(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyRepetition1 = yyIndex;
          while (true) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
                {
                  yyRepetition1 = yyIndex;
                  continue;
                }

              default:
                /* No match. */
              }
            }
            break;
          }

          yyValue = difference(yyStart, yyRepetition1);

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("line number expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSpacing.FileName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFileName(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '\\':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case '\"':
        case '\\':
          /* No match. */
          break;

        default:
          {
            yyRepetition1 = yyIndex;
            continue;
          }
        }
      }
      break;
    }

    yyValue = difference(yyStart, yyRepetition1);

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CSpacing.Pragma.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPragma(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '\n':
        case '\r':
          /* No match. */
          break;

        default:
          {
            yyRepetition1 = yyIndex;
            continue;
          }
        }
      }
      break;
    }

    yyValue = difference(yyStart, yyRepetition1);

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CContext.TypedefContext.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypedefContext(final int yyStart) throws IOException {
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyState.typedef();

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CContext.ParameterContext.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameterContext(final int yyStart) throws IOException {
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyState.parameters();

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CContext.FunctionDeclaratorContext.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFunctionDeclaratorContext(final int yyStart) 
    throws IOException {

    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyState.functionDeclarator();

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CContext.TypeSpecContext.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeSpecContext(final int yyStart) throws IOException {
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyState.typeSpecifier();

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CContext.PushScope.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPushScope(final int yyStart) throws IOException {
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyState.pushScope();

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CContext.PopScope.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPopScope(final int yyStart) throws IOException {
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyState.popScope();

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CContext.EnterStructure.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnterStructure(final int yyStart) throws IOException {
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyState.enterStructure();

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.CContext.ExitStructure.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExitStructure(final int yyStart) throws IOException {
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyState.exitStructure();

    yyValue = null;

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  static {
    add(C_KEYWORDS, new String[] {
      "auto",       "break",      "case",       "char",
      "const",      "continue",   "default",    "do",
      "double",     "else",       "enum",       "extern",
      "float",      "for",        "goto",       "if",
      "int",        "long",       "register",   "return",
      "short",      "signed",     "sizeof",     "static",
      "struct",     "switch",     "typedef",    "union",
      "unsigned",   "void",       "volatile",   "while"
    });
    
    if (C99) add(C_KEYWORDS, new String[] {
      "_Bool",      "_Complex",   "inline",
      "restrict"
    });
    
    if (GCC) add(C_KEYWORDS, new String[] {
      "__alignof",   "__alignof__",
      "asm",         "__asm",         "__asm__",
      "__attribute", "__attribute__",
      "__builtin_offsetof",
      "__builtin_types_compatible_p",
      "__builtin_va_arg",             "__builtin_va_list",
      "__complex__",
      "__const",     "__const__",
      "__extension__",
      "__inline",    "__inline__",
      "__label__",
      "__restrict",  "__restrict__",
      "__signed",    "__signed__",
      "__thread",
      "typeof",      "__typeof",      "__typeof__",
      "__volatile",  "__volatile__"
    });
    
  }

  // =========================================================================

  /**
   * Get the text for the specified annotated token.
   *
   * @param n The annotated token.
   * @return The corresponding text.
   */
  protected static final String toText(Node n) {
    return n.getTokenText();
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
