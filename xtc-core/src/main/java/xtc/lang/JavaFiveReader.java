// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 2.1.0,
// (C) 2004-2011 Robert Grimm,
// on Thursday, August 4, 2011 at 5:33:14 PM.
// Edit at your own risk.
// ===========================================================================

package xtc.lang;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Action;
import xtc.util.Pair;

import xtc.tree.Node;
import xtc.tree.GNode;
import xtc.tree.Token;
import xtc.tree.TextToken;
import xtc.tree.Formatting;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

/**
 * Packrat parser for grammar <code>xtc.lang.JavaFive</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 2.1.0, (C) 2004-2011 Robert Grimm.
 */
public final class JavaFiveReader extends ParserBase {

  /** The JAVA_KEYWORDS set. */
  public static final Set<String> JAVA_KEYWORDS = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fModifiers;
    Result fFormalParameters;
    Result fDeclarators;
    Result fDeclarators$$Star1;
    Result fImplementation;
    Result fImplementation$$Star1;
    Result fBlock;
    Result fParExpression;
    Result fCatchClause;
    Result fExpression;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fConditionalExpression;
    Result fLogicalOrExpression;
    Result fRelationalExpression;
    Result fVariableInitializer;
    Result fAnnotations;
    Result fAnnotations$$Plus1;
    Result fElementValuePair;
    Result fElementValue;
    Result fResultType;
    Result fType;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fTypeName;
    Result fPrimitiveType;
    Result fDimensions;
    Result fDimensions$$Plus1;
    Result fTypeParameters;
    Result fTypeParameter;
    Result fTypeArguments;
    Result fTypeArgument;
    Result fTypeInstantiation;
    Result fQualifiedIdentifier;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fQualifiedIdentifier$$Star1;
    Result fIdentifier;
    Result fWord;
    Result fSymbol;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class JavaFiveReaderColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public JavaFiveReader(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public JavaFiveReader(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new JavaFiveReaderColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.CompilationUnit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pCompilationUnit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Character  yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCompilationUnit$$Split1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyC = character(yyOption1);
      if ('\u001a' == yyC) {
        yyIndex = yyOption1 + 1;
        final char v$el$1 = (char)yyC;

        yyOption1  = yyIndex;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$pt$2.
        final Character v$pt$2 = yyOpValue1;

        yyResult = pEndOfFile(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          yyValue = Formatting.after1(v$pt$1, v$pt$2);

          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v$pt$2.
    }

    // Done.
    yyError = yyError.select("compilation unit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.CompilationUnit$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCompilationUnit$$Split1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$pt$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pPackageDeclaration(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$pt$2.
        final Node v$pt$2 = yyOpValue1;
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyRepetition1 = yyOption1;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pImportDeclaration(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pDeclaration(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$3 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$3, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for v$g$3.
            final Pair<Node> v$g$3 = yyRepValue1.reverse();

            yyValue = GNode.create("CompilationUnit", v$g$2.size() + v$g$3.size() + 1).
              add(v$g$1).addAll(v$g$2).addAll(v$g$3);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for v$g$3.
        } // End scope for v$g$2.
      } // End scope for v$pt$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.PackageDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPackageDeclaration(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declaration>.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pAnnotations(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$pt$2.
      final Node v$pt$2 = yyOpValue1;

      yyBase   = yyOption1;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("package")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyResult = pQualifiedIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$2 = Formatting.after1(v$pt$4, v$pt$3);

            yyValue = GNode.create("PackageDeclaration", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'package' expected", yyBase);
      }
    } // End scope for v$pt$2.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ImportDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImportDeclaration(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declaration>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("import")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("static")) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      } else {
        yyError = yyError.select("'static' expected", yyBase);
      }
      { // Start scope for v$pt$2.
        final Node v$pt$2 = yyOpValue1;
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyResult = pQualifiedIdentifier(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pDotStarTail(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$2 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
          { // Start scope for v$pt$4.
            final Node v$pt$4 = yyOpValue1;

            yyBase   = yyOption1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue() &&
                ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
              final Node v$pt$3 = yyResult.semanticValue();
              final Node v$g$3 = Formatting.after1(v$pt$4, v$pt$3);

              yyValue = GNode.create("ImportDeclaration", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("';' expected", yyBase);
            }
          } // End scope for v$pt$4.
        }
      } // End scope for v$pt$2.
    }

    // Done.
    yyError = yyError.select("import declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.DotStarTail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDotStarTail(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(".")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("*")) {
        final Node v$pt$2 = yyResult.semanticValue();
        yyValue = Formatting.before1(v$pt$1, v$pt$2);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'*' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("dot star tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.Modifiers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pModifiers(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fModifiers) 
      yyColumn.chunk1.fModifiers = pModifiers$1(yyStart);
    return yyColumn.chunk1.fModifiers;
  }

  /** Actually parse xtc.lang.JavaFive.Modifiers. */
  private Result pModifiers$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pModifierList(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("Modifiers", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ModifierList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pModifierList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pModifier(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for yyValue.
      yyValue = yyRepValue1.reverse();

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for yyValue.
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.Modifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pModifier(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Annotation>.

    yyResult = pAnnotation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Public>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("public")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Modifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Protected>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("protected")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("Modifier", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Private>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("private")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("Modifier", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Static>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("static")) {
      final Node v$g$4 = yyResult.semanticValue();

      yyValue = GNode.create("Modifier", v$g$4);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Abstract>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("abstract")) {
      final Node v$g$5 = yyResult.semanticValue();

      yyValue = GNode.create("Modifier", v$g$5);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Final>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("final")) {
      final Node v$g$6 = yyResult.semanticValue();

      yyValue = GNode.create("Modifier", v$g$6);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Native>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("native")) {
      final Node v$g$7 = yyResult.semanticValue();

      yyValue = GNode.create("Modifier", v$g$7);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Synchronized>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("synchronized")) {
      final Node v$g$8 = yyResult.semanticValue();

      yyValue = GNode.create("Modifier", v$g$8);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Transient>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("transient")) {
      final Node v$g$9 = yyResult.semanticValue();

      yyValue = GNode.create("Modifier", v$g$9);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Volatile>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("volatile")) {
      final Node v$g$10 = yyResult.semanticValue();

      yyValue = GNode.create("Modifier", v$g$10);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Strictfp>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("strictfp")) {
      final Node v$g$11 = yyResult.semanticValue();

      yyValue = GNode.create("Modifier", v$g$11);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("modifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.FormalParameter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFormalParameter(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Parameter>.

    yyResult = pVariableModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("...")) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        } else {
          yyError = yyError.select("'...' expected", yyBase);
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyResult = pIdentifier(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$4 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pDimensions(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$5.
              final Node v$g$5 = yyOpValue1;

              yyValue = GNode.create("FormalParameter", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$g$5.
          }
        } // End scope for v$g$3.
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.VariableModifiers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariableModifiers(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Modifiers>.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pVariableModifier(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("Modifiers", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.FinalModifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFinalModifier(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("final")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("Modifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("final modifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.FormalParameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFormalParameters(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fFormalParameters) 
      yyColumn.chunk1.fFormalParameters = pFormalParameters$1(yyStart);
    return yyColumn.chunk1.fFormalParameters;
  }

  /** Actually parse xtc.lang.JavaFive.FormalParameters. */
  private Result pFormalParameters$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFormalParameters$$Split1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
        final Node v$pt$2 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$1, v$pt$2);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("')' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$pt$3 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
        final Node v$pt$4 = yyResult.semanticValue();

        yyValue = GNode.create("FormalParameters", false);
        yyValue.setLocation(location(yyStart));
        yyValue = Formatting.variable().addNode(yyValue).
          add(v$pt$3).add(v$pt$4);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("')' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("formal parameters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.FormalParameters$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFormalParameters$$Split1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$pt$3 = yyResult.semanticValue();

      yyResult = pFormalParameter(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$4 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$3, v$pt$4);

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
            final Node v$pt$1 = yyResult.semanticValue();

            yyResult = pFormalParameter(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$pt$2 = yyResult.semanticValue();
              final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("FormalParameters", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("formal parameters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.Declarator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarator(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declarator>.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pDimensions(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyOpValue1 = null;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("=")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyResult = pVariableInitializer(yyResult.index);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$el$2 = Formatting.before1(v$pt$1, v$pt$2);

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$2;
          }
        } else {
          yyError = yyError.select("'=' expected", yyBase);
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyValue = GNode.create("Declarator", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyOption1, yyError);
        } // End scope for v$g$3.
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.Declarators.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarators(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fDeclarators) 
      yyColumn.chunk1.fDeclarators = pDeclarators$1(yyStart);
    return yyColumn.chunk1.fDeclarators;
  }

  /** Actually parse xtc.lang.JavaFive.Declarators. */
  private Result pDeclarators$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDeclarator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pDeclarators$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("Declarators", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.Declarators$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarators$$Star1(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fDeclarators$$Star1) 
      yyColumn.chunk1.fDeclarators$$Star1 = pDeclarators$$Star1$1(yyStart);
    return yyColumn.chunk1.fDeclarators$$Star1;
  }

  /** Actually parse xtc.lang.JavaFive.Declarators$$Star1. */
  private Result pDeclarators$$Star1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pDeclarator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyResult = pDeclarators$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ClassBody.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassBody(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Body>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pClassBody$$Split1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
          final Node v$pt$3 = yyResult.semanticValue();
          yyValue = Formatting.round1(v$pt$1, v$pt$2, v$pt$3);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("class body expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.ClassBody$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassBody$$Split1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Body>.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pDeclaration(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("ClassBody", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.Declaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclaration(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pType(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pDeclarators(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
            final Node v$pt$1 = yyResult.semanticValue();
            final Node v$g$3 = Formatting.after1(v$pt$2, v$pt$1);

            yyValue = GNode.create("FieldDeclaration", v$g$1, v$g$2, v$g$3);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      }

      // Nested alternative 2.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pTypeParameters(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        final int yyChoice2 = yyOption1;

        // Nested alternative 1.

        yyResult = pResultType(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyResult = pIdentifier(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$4 = yyResult.semanticValue();

            yyResult = pFormalParameters(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$5 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pDimensions(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                final Node v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
              { // Start scope for v$g$6.
                final Node v$g$6 = yyOpValue1;

                yyOpValue1 = null;

                yyResult = pThrowsClause(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  final Node v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                }
                { // Start scope for v$g$7.
                  final Node v$g$7 = yyOpValue1;

                  final int yyChoice3 = yyOption1;

                  // Nested alternative 1.

                  yyResult = pBlock(yyChoice3);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    final Node v$g$8 = yyResult.semanticValue();

                    yyValue = GNode.create("MethodDeclaration", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5, v$g$6, v$g$7, v$g$8);
                    yyValue.setLocation(location(yyStart));

                    return yyResult.createValue(yyValue, yyError);
                  }

                  // Nested alternative 2.

                  yyBase   = yyChoice3;
                  yyResult = pSymbol(yyBase);
                  if (yyResult.hasValue() &&
                      ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
                    final Node v$pt$1 = yyResult.semanticValue();
                    final Node v$g$9 = Formatting.after1(null, v$pt$1);

                    yyValue = GNode.create("MethodDeclaration", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5, v$g$6, v$g$7, v$g$9);
                    yyValue.setLocation(location(yyStart));

                    return yyResult.createValue(yyValue, yyError);
                  } else {
                    yyError = yyError.select("';' expected", yyBase);
                  }
                } // End scope for v$g$7.
              } // End scope for v$g$6.
            }
          }
        }

        // Nested alternative 2.

        yyResult = pIdentifier(yyChoice2);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyResult = pFormalParameters(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$4 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pThrowsClause(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$5.
              final Node v$g$5 = yyOpValue1;

              yyResult = pBlock(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$6 = yyResult.semanticValue();

                yyValue = GNode.create("ConstructorDeclaration", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5, v$g$6);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            } // End scope for v$g$5.
          }
        }
      } // End scope for v$g$2.
    }

    // Alternative 2.

    yyResult = pModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("class")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyResult = pIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pTypeParameters(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$3.
            final Node v$g$3 = yyOpValue1;

            yyOpValue1 = null;

            yyResult = pExtension(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$4.
              final Node v$g$4 = yyOpValue1;

              yyOpValue1 = null;

              yyResult = pImplementation(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                final Node v$el$3 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$3;
              }
              { // Start scope for v$g$5.
                final Node v$g$5 = yyOpValue1;

                yyResult = pClassBody(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$6 = yyResult.semanticValue();

                  yyValue = GNode.create("ClassDeclaration", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5, v$g$6);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                }
              } // End scope for v$g$5.
            } // End scope for v$g$4.
          } // End scope for v$g$3.
        }
      } else {
        yyError = yyError.select("'class' expected", yyBase);
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("interface")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyResult = pIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pTypeParameters(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$3.
            final Node v$g$3 = yyOpValue1;

            yyOpValue1 = null;

            yyResult = pExtension(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$4.
              final Node v$g$4 = yyOpValue1;

              yyResult = pClassBody(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$5 = yyResult.semanticValue();

                yyValue = GNode.create("InterfaceDeclaration", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            } // End scope for v$g$4.
          } // End scope for v$g$3.
        }
      } else {
        yyError = yyError.select("'interface' expected", yyBase);
      }
    }

    // Alternative <Declaration>.

    yyResult = pModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$3 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("@")) {
        final Node v$pt$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("interface")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.variable().
            addNode(v$pt$3).add(v$pt$1).add(v$pt$2);

          yyResult = pIdentifier(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyResult = pAnnotationBody(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("AnnotationDeclaration", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } else {
          yyError = yyError.select("'interface' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'@' expected", yyBase);
      }
    }

    // Alternative <Declaration>.

    yyResult = pModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("enum")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyResult = pIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pImplementation(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$pt$4.
            final Node v$pt$4 = yyOpValue1;

            yyBase   = yyOption1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue() &&
                ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
              final Node v$pt$3 = yyResult.semanticValue();
              final Node v$g$3 = Formatting.after1(v$pt$4, v$pt$3);

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pEnumConstants(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                final Node v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
              { // Start scope for v$pt$6.
                final Node v$pt$6 = yyOpValue1;

                yyOpValue1 = null;

                yyBase   = yyOption1;
                yyResult = pSymbol(yyBase);
                if (yyResult.hasValue() &&
                    ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
                  final Node v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                } else {
                  yyError = yyError.select("',' expected", yyBase);
                }
                { // Start scope for v$pt$5.
                  final Node v$pt$5 = yyOpValue1;
                  final Node v$g$4 = Formatting.after1(v$pt$6, v$pt$5);

                  yyOpValue1 = null;

                  yyResult = pEnumMembers(yyOption1);
                  yyError  = yyResult.select(yyError, yyOption1);
                  if (yyResult.hasValue()) {
                    final Node v$el$4 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$4;
                  }
                  { // Start scope for v$pt$8.
                    final Node v$pt$8 = yyOpValue1;

                    yyBase   = yyOption1;
                    yyResult = pSymbol(yyBase);
                    if (yyResult.hasValue() &&
                        ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
                      final Node v$pt$7 = yyResult.semanticValue();
                      final Node v$g$5 = Formatting.after1(v$pt$8, v$pt$7);

                      yyValue = GNode.create("EnumDeclaration", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);
                      yyValue.setLocation(location(yyStart));

                      return yyResult.createValue(yyValue, yyError);
                    } else {
                      yyError = yyError.select("'}' expected", yyBase);
                    }
                  } // End scope for v$pt$8.
                } // End scope for v$pt$5.
              } // End scope for v$pt$6.
            } else {
              yyError = yyError.select("'{' expected", yyBase);
            }
          } // End scope for v$pt$4.
        }
      } else {
        yyError = yyError.select("'enum' expected", yyBase);
      }
    }

    // Alternative 5.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyBase   = yyOption1;
    yyResult = pWord(yyBase);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("static")) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    } else {
      yyError = yyError.select("'static' expected", yyBase);
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pBlock(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("BlockDeclaration", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    } // End scope for v$g$1.

    // Alternative 6.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("EmptyDeclaration", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ThrowsClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pThrowsClause(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("throws")) {
      final Node v$pt$3 = yyResult.semanticValue();

      yyResult = pQualifiedIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$4 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$3, v$pt$4);

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
            final Node v$pt$1 = yyResult.semanticValue();

            yyResult = pQualifiedIdentifier(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$pt$2 = yyResult.semanticValue();
              final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("ThrowsClause", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("throws clause expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.Extension.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExtension(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("extends")) {
      final Node v$pt$3 = yyResult.semanticValue();

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$4 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$3, v$pt$4);

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
            final Node v$pt$1 = yyResult.semanticValue();

            yyResult = pType(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$pt$2 = yyResult.semanticValue();
              final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("Extension", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("extension expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.Implementation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImplementation(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fImplementation) 
      yyColumn.chunk1.fImplementation = pImplementation$1(yyStart);
    return yyColumn.chunk1.fImplementation;
  }

  /** Actually parse xtc.lang.JavaFive.Implementation. */
  private Result pImplementation$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("implements")) {
      final Node v$pt$3 = yyResult.semanticValue();

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$4 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$3, v$pt$4);

        yyResult = pImplementation$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$g$2 = yyResult.semanticValue();

          yyValue = GNode.createFromPair("Implementation", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("implementation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.Implementation$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pImplementation$$Star1(final int yyStart) 
    throws IOException {

    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fImplementation$$Star1) 
      yyColumn.chunk1.fImplementation$$Star1 = pImplementation$$Star1$1(yyStart);
    return yyColumn.chunk1.fImplementation$$Star1;
  }

  /** Actually parse xtc.lang.JavaFive.Implementation$$Star1. */
  private Result pImplementation$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyResult = pImplementation$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.Block.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlock(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fBlock) 
      yyColumn.chunk1.fBlock = pBlock$1(yyStart);
    return yyColumn.chunk1.fBlock;
  }

  /** Actually parse xtc.lang.JavaFive.Block. */
  private Result pBlock$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Block>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pBlock$$Split1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
          final Node v$pt$3 = yyResult.semanticValue();
          yyValue = Formatting.round1(v$pt$1, v$pt$2, v$pt$3);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("block expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.Block$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBlock$$Split1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Block>.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pDeclarationOrStatement(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("Block", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.DeclarationOrStatement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDeclarationOrStatement(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declaration>.

    yyResult = pInBlockDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Statement>.

    yyResult = pStatement(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.InBlockDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInBlockDeclaration(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Variable>.

    yyResult = pVariableDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("class")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyResult = pIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pTypeParameters(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$3.
            final Node v$g$3 = yyOpValue1;

            yyOpValue1 = null;

            yyResult = pExtension(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$4.
              final Node v$g$4 = yyOpValue1;

              yyOpValue1 = null;

              yyResult = pImplementation(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                final Node v$el$3 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$3;
              }
              { // Start scope for v$g$5.
                final Node v$g$5 = yyOpValue1;

                yyResult = pClassBody(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$6 = yyResult.semanticValue();

                  yyValue = GNode.create("ClassDeclaration", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5, v$g$6);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                }
              } // End scope for v$g$5.
            } // End scope for v$g$4.
          } // End scope for v$g$3.
        }
      } else {
        yyError = yyError.select("'class' expected", yyBase);
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("interface")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyResult = pIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pTypeParameters(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$3.
            final Node v$g$3 = yyOpValue1;

            yyOpValue1 = null;

            yyResult = pExtension(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$4.
              final Node v$g$4 = yyOpValue1;

              yyResult = pClassBody(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$5 = yyResult.semanticValue();

                yyValue = GNode.create("InterfaceDeclaration", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            } // End scope for v$g$4.
          } // End scope for v$g$3.
        }
      } else {
        yyError = yyError.select("'interface' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.VariableDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariableDeclaration(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Declaration>.

    yyResult = pVariableModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pDeclarators(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
            final Node v$pt$1 = yyResult.semanticValue();
            final Node v$g$3 = Formatting.after1(v$pt$2, v$pt$1);

            yyValue = GNode.create("FieldDeclaration", v$g$1, v$g$2, v$g$3);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.Statement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStatement(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Block>.

    yyResult = pBlock(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("if")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pParExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyResult = pStatement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyBase   = yyChoice1;
          yyResult = pWord(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals("else")) {
            final Node v$pt$3 = yyResult.semanticValue();

            yyResult = pStatement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$pt$4 = yyResult.semanticValue();
              final Node v$g$3 = Formatting.before1(v$pt$3, v$pt$4);

              yyValue = GNode.create("ConditionalStatement", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("'else' expected", yyBase);
          }

          // Nested alternative 2.

          yyValue = GNode.create("ConditionalStatement", v$g$1, v$g$2, null);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }
      }
    }

    // Alternative 3.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("for")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyResult = pForControl(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$1 = Formatting.variable().
              add(v$pt$1).add(v$pt$2).addNode(v$pt$4).add(v$pt$3);

            yyResult = pStatement(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyValue = GNode.create("ForStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 4.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("while")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pParExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyResult = pStatement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("WhileStatement", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 5.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("do")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pStatement(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$3 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("while")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          yyResult = pParExpression(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$pt$5 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue() &&
                ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
              final Node v$pt$4 = yyResult.semanticValue();
              final Node v$g$2 = Formatting.after1(v$pt$5, v$pt$4);

              yyValue = GNode.create("DoWhileStatement", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("';' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("'while' expected", yyBase);
        }
      }
    }

    // Alternative 6.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("try")) {
      final Node v$pt$1 = yyResult.semanticValue();
      final Node v$g$1 = Formatting.before1(v$pt$1, null);

      yyResult = pBlock(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyRepetition1 = yyChoice1;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pCatchClause(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v$g$3.
          final Pair<Node> v$g$3 = yyRepValue1.reverse();

          yyBase   = yyRepetition1;
          yyResult = pWord(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals("finally")) {
            final Node v$pt$3 = yyResult.semanticValue();

            yyResult = pBlock(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$pt$4 = yyResult.semanticValue();
              final Node v$g$4 = Formatting.before1(v$pt$3, v$pt$4);

              yyValue = GNode.create("TryCatchFinallyStatement", v$g$3.size() + 3).
                add(v$g$1).add(v$g$2).addAll(v$g$3).add(v$g$4);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("'finally' expected", yyBase);
          }
        } // End scope for v$g$3.

        // Nested alternative 2.

        yyRepetition1 = yyChoice1;
        yyRepeated1   = false;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyResult = pCatchClause(yyRepetition1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$el$2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepeated1   = true;
            yyRepValue1   = new Pair<Node>(v$el$2, yyRepValue1);
            continue;
          }
          break;
        }

        if (yyRepeated1) {
          final Pair<Node> v$g$5 = yyRepValue1.reverse();

          yyValue = GNode.create("TryCatchFinallyStatement", v$g$5.size() + 3).
            add(v$g$1).add(v$g$2).addAll(v$g$5).add(null);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        }
      }
    }

    // Alternative 7.

    yyResult = pSwitchStatement$$Split1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
        final Node v$pt$2 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$1, v$pt$2);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'}' expected", yyBase);
      }
    }

    // Alternative 8.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("synchronized")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pParExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyResult = pBlock(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("SynchronizedStatement", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 9.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("return")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pExpression(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$pt$3.
        final Node v$pt$3 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          yyValue = GNode.create("ReturnStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      } // End scope for v$pt$3.
    }

    // Alternative 10.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("throw")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$3 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          yyValue = GNode.create("ThrowStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }
    }

    // Alternative 11.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("break")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pIdentifier(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$pt$3.
        final Node v$pt$3 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          yyValue = GNode.create("BreakStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      } // End scope for v$pt$3.
    }

    // Alternative 12.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("continue")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pIdentifier(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$pt$3.
        final Node v$pt$3 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          yyValue = GNode.create("ContinueStatement", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      } // End scope for v$pt$3.
    }

    // Alternative 13.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyResult = pStatement(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("LabeledStatement", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Alternative 14.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyValue = GNode.create("ExpressionStatement", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    }

    // Alternative 15.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("assert")) {
      final Node v$pt$3 = yyResult.semanticValue();

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$4 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$3, v$pt$4);

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
        { // Start scope for v$pt$6.
          final Node v$pt$6 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
            final Node v$pt$5 = yyResult.semanticValue();
            final Node v$g$2 = Formatting.after1(v$pt$6, v$pt$5);

            yyValue = GNode.create("AssertStatement", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        } // End scope for v$pt$6.
      }
    }

    // Alternative 16.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("EmptyStatement", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ForControl.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pForControl(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pVariableModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pIdentifier(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
            final Node v$pt$1 = yyResult.semanticValue();
            final Node v$g$3 = Formatting.after1(v$pt$2, v$pt$1);

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$4 = yyResult.semanticValue();

              yyValue = GNode.create("EnhancedForControl", v$g$1, v$g$2, v$g$3, v$g$4);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        }

        // Nested alternative 2.

        yyResult = pDeclarators(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
            final Node v$pt$1 = yyResult.semanticValue();
            final Node v$g$3 = Formatting.after1(v$pt$2, v$pt$1);

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pExpression(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$1;
            }
            { // Start scope for v$pt$4.
              final Node v$pt$4 = yyOpValue1;

              yyBase   = yyOption1;
              yyResult = pSymbol(yyBase);
              if (yyResult.hasValue() &&
                  ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
                final Node v$pt$3 = yyResult.semanticValue();
                final Node v$g$4 = Formatting.after1(v$pt$4, v$pt$3);

                yyOption1  = yyResult.index;
                yyOpValue1 = null;

                yyResult = pExpressionList(yyOption1);
                yyError  = yyResult.select(yyError, yyOption1);
                if (yyResult.hasValue()) {
                  final Node v$el$2 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$2;
                }
                { // Start scope for v$g$5.
                  final Node v$g$5 = yyOpValue1;

                  yyValue = GNode.create("BasicForControl", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);
                  yyValue.setLocation(location(yyStart));

                  return new SemanticValue(yyValue, yyOption1, yyError);
                } // End scope for v$g$5.
              } else {
                yyError = yyError.select("';' expected", yyBase);
              }
            } // End scope for v$pt$4.
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      }
    }

    // Alternative <Initialization>.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pExpressionList(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$3 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$3;
    }
    { // Start scope for v$pt$6.
      final Node v$pt$6 = yyOpValue1;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
        final Node v$pt$5 = yyResult.semanticValue();
        final Node v$g$8 = Formatting.after1(v$pt$6, v$pt$5);

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pExpression(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$4 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$4;
        }
        { // Start scope for v$pt$8.
          final Node v$pt$8 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
            final Node v$pt$7 = yyResult.semanticValue();
            final Node v$g$9 = Formatting.after1(v$pt$8, v$pt$7);

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pExpressionList(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$5 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$5;
            }
            { // Start scope for v$g$10.
              final Node v$g$10 = yyOpValue1;

              yyValue = GNode.create("BasicForControl", null, null, v$g$8, v$g$9, v$g$10);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$g$10.
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        } // End scope for v$pt$8.
      } else {
        yyError = yyError.select("';' expected", yyBase);
      }
    } // End scope for v$pt$6.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ParExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParExpression(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fParExpression) 
      yyColumn.chunk1.fParExpression = pParExpression$1(yyStart);
    return yyColumn.chunk1.fParExpression;
  }

  /** Actually parse xtc.lang.JavaFive.ParExpression. */
  private Result pParExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$3 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
          final Node v$pt$2 = yyResult.semanticValue();
          yyValue = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("par expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.CatchClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCatchClause(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fCatchClause) 
      yyColumn.chunk1.fCatchClause = pCatchClause$1(yyStart);
    return yyColumn.chunk1.fCatchClause;
  }

  /** Actually parse xtc.lang.JavaFive.CatchClause. */
  private Result pCatchClause$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Catch>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("catch")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyResult = pFormalParameter(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$1 = Formatting.variable().
              add(v$pt$1).add(v$pt$2).addNode(v$pt$4).add(v$pt$3);

            yyResult = pBlock(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$2 = yyResult.semanticValue();

              yyValue = GNode.create("CatchClause", v$g$1, v$g$2);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("catch clause expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.SwitchStatement$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSwitchStatement$$Split1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("switch")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pParExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$3 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pSwitchClause(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for v$g$2.
            final Pair<Node> v$g$2 = yyRepValue1.reverse();

            yyValue = GNode.createFromPair("SwitchStatement", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for v$g$2.
        } else {
          yyError = yyError.select("'{' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("switch statement expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.SwitchClause.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSwitchClause(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("case")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$3 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyResult = pDeclarationOrStatement(yyRepetition1);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$el$1 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
            break;
          }
          { // Start scope for v$g$2.
            final Pair<Node> v$g$2 = yyRepValue1.reverse();

            yyValue = GNode.createFromPair("CaseClause", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for v$g$2.
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("default")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyResult = pDefaultClause$$Split1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$3 = yyResult.semanticValue();
          yyValue = Formatting.variable().
            add(v$pt$1).add(v$pt$2).addNode(v$pt$3);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("switch clause expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.DefaultClause$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDefaultClause$$Split1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pDeclarationOrStatement(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("DefaultClause", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ExpressionList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpressionList(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyResult = pExpression(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("ExpressionList", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.Expression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpression(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fExpression) 
      yyColumn.chunk1.fExpression = pExpression$1(yyStart);
    return yyColumn.chunk1.fExpression;
  }

  /** Actually parse xtc.lang.JavaFive.Expression. */
  private Result pExpression$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Assignment>.

    yyResult = pConditionalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pAssignmentOperator(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyValue = GNode.create("Expression", v$g$1, v$g$2, v$g$3);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pConditionalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.AssignmentOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAssignmentOperator(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Equal>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <PlusEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("+=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <MinusEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("-=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <StarEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("*=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <SlashEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("/=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <AmpersandEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("&=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <BarEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("|=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <CaretEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("^=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <PercentEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("%=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <DoubleLessEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("<<=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <DoubleGreaterEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(">>=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <TripleGreaterEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(">>>=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("assignment operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ConditionalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConditionalExpression(final int yyStart) 
    throws IOException {

    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fConditionalExpression) 
      yyColumn.chunk2.fConditionalExpression = pConditionalExpression$1(yyStart);
    return yyColumn.chunk2.fConditionalExpression;
  }

  /** Actually parse xtc.lang.JavaFive.ConditionalExpression. */
  private Result pConditionalExpression$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Conditional>.

    yyResult = pLogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("?")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyResult = pExpression(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$4 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(":")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$2 = Formatting.after1(v$pt$4, v$pt$3);

            yyResult = pConditionalExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("ConditionalExpression", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'?' expected", yyBase);
      }
    }

    // Alternative <Base>.

    yyResult = pLogicalOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.LogicalOrExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalOrExpression(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fLogicalOrExpression) 
      yyColumn.chunk2.fLogicalOrExpression = pLogicalOrExpression$1(yyStart);
    return yyColumn.chunk2.fLogicalOrExpression;
  }

  /** Actually parse xtc.lang.JavaFive.LogicalOrExpression. */
  private Result pLogicalOrExpression$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pLogicalAndExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pLogicalOrExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.LogicalOrExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalOrExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Or>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("||")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pLogicalAndExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$2 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalOrExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical or expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.LogicalAndExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalAndExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pBitwiseOrExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pLogicalAndExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * xtc.lang.JavaFive.LogicalAndExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLogicalAndExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <And>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("&&")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pBitwiseOrExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$2 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("LogicalAndExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("logical and expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.BitwiseOrExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseOrExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pBitwiseXorExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBitwiseOrExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.BitwiseOrExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseOrExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Or>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("|")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pBitwiseXorExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$2 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseOrExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise or expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.BitwiseXorExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseXorExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pBitwiseAndExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBitwiseXorExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * xtc.lang.JavaFive.BitwiseXorExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseXorExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Xor>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("^")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pBitwiseAndExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$2 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseXorExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise xor expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.BitwiseAndExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseAndExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pEqualityExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pBitwiseAndExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$3 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$3, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$4.
        final Pair<Action<Node>> v$4 = yyRepValue1.reverse();

        yyValue = apply(v$4, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$4.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * xtc.lang.JavaFive.BitwiseAndExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBitwiseAndExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <And>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("&")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pEqualityExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$2 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("BitwiseAndExpression", v$1, v$g$2);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("bitwise and expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.EqualityExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pInstanceOfExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pEqualityExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.EqualityExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pEqualityOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$2 = yyResult.semanticValue();

      yyResult = pInstanceOfExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("EqualityExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.EqualityOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEqualityOperator(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Equal>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("==")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <NotEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("!=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("equality operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.InstanceOfExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInstanceOfExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Instanceof>.

    yyResult = pRelationalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("instanceof")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyResult = pType(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("InstanceOfExpression", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'instanceof' expected", yyBase);
      }
    }

    // Alternative <Base>.

    yyResult = pRelationalExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.RelationalExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalExpression(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fRelationalExpression) 
      yyColumn.chunk2.fRelationalExpression = pRelationalExpression$1(yyStart);
    return yyColumn.chunk2.fRelationalExpression;
  }

  /** Actually parse xtc.lang.JavaFive.RelationalExpression. */
  private Result pRelationalExpression$1(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pShiftExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pRelationalExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * xtc.lang.JavaFive.RelationalExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pRelationalOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$2 = yyResult.semanticValue();

      yyResult = pShiftExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("RelationalExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.RelationalOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pRelationalOperator(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Less>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("<")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Greater>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(">")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <LessEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("<=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <GreaterEqual>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(">=")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("relational operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ShiftExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pAdditiveExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pShiftExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.ShiftExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pShiftOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$2 = yyResult.semanticValue();

      yyResult = pAdditiveExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("ShiftExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ShiftOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pShiftOperator(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Left>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("<<")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Right>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(">>")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <UnsignedRight>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(">>>")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("shift operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.AdditiveExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pMultiplicativeExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pAdditiveExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.AdditiveExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Recursion>.

    yyResult = pAdditiveOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$2 = yyResult.semanticValue();

      yyResult = pMultiplicativeExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("AdditiveExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.AdditiveOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAdditiveOperator(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Plus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("+")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Minus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("-")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("additive operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.MultiplicativeExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeExpression(final int yyStart) 
    throws IOException {

    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pUnaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pMultiplicativeExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$4 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$4, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$5.
        final Pair<Action<Node>> v$5 = yyRepValue1.reverse();

        yyValue = apply(v$5, yyValue, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$5.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * xtc.lang.JavaFive.MultiplicativeExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative <Times>.

    yyResult = pMultiplicativeOperator(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$2 = yyResult.semanticValue();

      yyResult = pUnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("MultiplicativeExpression", v$1, v$g$2, v$g$3);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.MultiplicativeOperator.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pMultiplicativeOperator(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Times>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("*")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Over>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("/")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Modulo>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("%")) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("multiplicative operator expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.UnaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnaryExpression(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Plus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("+")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pUnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryExpression", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Minus>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("-")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyResult = pUnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryExpression", v$g$3, v$g$4);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Increment>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("++")) {
      final Node v$g$5 = yyResult.semanticValue();

      yyResult = pUnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$6 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryExpression", v$g$5, v$g$6);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Decrement>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("--")) {
      final Node v$g$7 = yyResult.semanticValue();

      yyResult = pUnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$8 = yyResult.semanticValue();

        yyValue = GNode.create("UnaryExpression", v$g$7, v$g$8);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Base>.

    yyResult = pUnaryExpressionNotPlusMinus(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("unary expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.UnaryExpressionNotPlusMinus.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pUnaryExpressionNotPlusMinus(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("~")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pUnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = GNode.create("BitwiseNegationExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("!")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pUnaryExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = GNode.create("LogicalNegationExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$pt$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pPrimitiveType(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pDimensions(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$1 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
        { // Start scope for v$pt$4.
          final Node v$pt$4 = yyOpValue1;

          yyBase   = yyOption1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
            final Node v$pt$3 = yyResult.semanticValue();
            final Node v$g$2 = Formatting.after1(v$pt$4, v$pt$3);

            yyResult = pUnaryExpression(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("BasicCastExpression", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v$pt$4.
      }

      // Nested alternative 2.

      yyResult = pType(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$3 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          yyResult = pUnaryExpressionNotPlusMinus(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyValue = GNode.create("CastExpression", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative <Base>.

    yyResult = pPostfixExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("unary expression not plus minus expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.PostfixExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostfixExpression(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyRepetition1;
    Pair<Action<Node>> yyRepValue1;
    Node               yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative <Base>.

    yyResult = pPrimaryExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$16 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pPostfixExpression$$Tail1(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          final Action<Node> v$17 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Action<Node>>(v$17, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v$18.
        final Pair<Action<Node>> v$18 = yyRepValue1.reverse();

        yyValue = apply(v$18, v$g$16, yyStart);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$18.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.PostfixExpression$$Tail1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPostfixExpression$$Tail1(final int yyStart) 
    throws IOException {

    Result       yyResult;
    int          yyBase;
    int          yyOption1;
    Node         yyOpValue1;
    Action<Node> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(".")) {
      final Node v$pt$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pTypeArguments(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$pt$2.
        final Node v$pt$2 = yyOpValue1;
        final Node v$g$2 = Formatting.before1(v$pt$1, v$pt$2);

        yyResult = pIdentifier(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyResult = pArguments(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$4 = yyResult.semanticValue();

            yyValue = new Action<Node>() {
              public Node run(Node v$1) {
                return GNode.create("CallExpression", v$1, v$g$2, v$g$3, v$g$4);
              }};

            return yyResult.createValue(yyValue, yyError);
          }
        }
      } // End scope for v$pt$2.

      // Nested alternative 2.
      final Node v$g$5 = Formatting.before1(v$pt$1, null);

      yyBase   = yyChoice1;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("super")) {
        final Node v$g$6 = yyResult.semanticValue();

        yyResult = pArguments(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$7 = yyResult.semanticValue();

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("CallExpression", v$1, v$g$5, v$g$6, v$g$7);
            }};

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'super' expected", yyBase);
      }

      // Nested alternative 3.

      yyBase   = yyChoice1;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("super")) {
        final Node v$pt$4 = yyResult.semanticValue();

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            Node yyValue = GNode.create("SuperExpression", v$1);
            yyValue = Formatting.variable().addNode(yyValue).
              add(v$pt$1).add(v$pt$4);
            return yyValue;
          }};

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'super' expected", yyBase);
      }

      // Nested alternative 4.

      yyResult = pIdentifier(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$5 = yyResult.semanticValue();
        final Node v$g$8 = Formatting.before1(v$pt$1, v$pt$5);

        yyValue = new Action<Node>() {
          public Node run(Node v$1) {
            return GNode.create("SelectionExpression", v$1, v$g$8);
          }};

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("[")) {
      final Node v$pt$6 = yyResult.semanticValue();

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$8 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("]")) {
          final Node v$pt$7 = yyResult.semanticValue();
          final Node v$g$9 = Formatting.round1(v$pt$6, v$pt$8, v$pt$7);

          yyValue = new Action<Node>() {
            public Node run(Node v$1) {
              return GNode.create("SubscriptExpression", v$1, v$g$9);
            }};

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative 3.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("++")) {
      final Node v$g$10 = yyResult.semanticValue();

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          return GNode.create("PostfixExpression", v$1, v$g$10);
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("--")) {
      final Node v$g$11 = yyResult.semanticValue();

      yyValue = new Action<Node>() {
        public Node run(Node v$1) {
          return GNode.create("PostfixExpression", v$1, v$g$11);
        }};

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 5.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(".")) {
      final Node v$pt$9 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("new")) {
        final Node v$pt$10 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pTypeArguments(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$pt$11.
          final Node v$pt$11 = yyOpValue1;
          final Node v$g$12 = Formatting.variable().
            add(v$pt$9).add(v$pt$10).addNode(v$pt$11);

          yyResult = pTypeName(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$13 = yyResult.semanticValue();

            yyResult = pArguments(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$14 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pClassBody(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                final Node v$el$3 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$3;
              }
              { // Start scope for v$g$15.
                final Node v$g$15 = yyOpValue1;

                yyValue = new Action<Node>() {
                  public Node run(Node v$1) {
                    return GNode.create("NewClassExpression", v$1, v$g$12, v$g$13, v$g$14, v$g$15);
                  }};

                return new SemanticValue(yyValue, yyOption1, yyError);
              } // End scope for v$g$15.
            }
          }
        } // End scope for v$pt$11.
      } else {
        yyError = yyError.select("'new' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("postfix expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.PrimaryExpression.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimaryExpression(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Literal>.

    yyResult = pLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Expression>.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pTypeArguments(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$2.
      final Node v$g$2 = yyOpValue1;

      yyResult = pIdentifier(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$3 = yyResult.semanticValue();

        yyResult = pArguments(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$4 = yyResult.semanticValue();

          yyValue = GNode.create("CallExpression", null, v$g$2, v$g$3, v$g$4);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    } // End scope for v$g$2.

    // Alternative <Expression>.

    yyResult = pResultType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$3 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(".")) {
        final Node v$pt$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("class")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.variable().
            addNode(v$pt$3).add(v$pt$1).add(v$pt$2);

          yyValue = GNode.create("ClassLiteralExpression", v$g$1);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'class' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'.' expected", yyBase);
      }
    }

    // Alternative <Expression>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("this")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyResult = pArguments(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        yyValue = GNode.create("CallExpression", null, null, v$g$3, v$g$4);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Expression>.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pQualifiedIdentifier(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(".")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$el$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      } else {
        yyError = yyError.select("'.' expected", yyBase);
      }
    }
    { // Start scope for v$pt$4.
      final Node v$pt$4 = yyOpValue1;

      yyBase   = yyOption1;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("this")) {
        final Node v$pt$3 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$4, v$pt$3);

        yyValue = GNode.create("ThisExpression", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("'this' expected", yyBase);
      }
    } // End scope for v$pt$4.

    // Alternative <Expression>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("super")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyResult = pArguments(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        yyValue = GNode.create("CallExpression", null, null, v$g$3, v$g$4);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Expression>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("super")) {
      final Node v$pt$1 = yyResult.semanticValue();
      final Node v$g$1 = Formatting.after1(null, v$pt$1);

      yyValue = GNode.create("SuperExpression", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("PrimaryIdentifier", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Expression>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("new")) {
      final Node v$pt$1 = yyResult.semanticValue();
      final Node v$g$1 = Formatting.after1(null, v$pt$1);

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pTypeArguments(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyResult = pTypeName(yyOption1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$3 = yyResult.semanticValue();

          yyResult = pArguments(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$4 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = null;

            yyResult = pClassBody(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$5.
              final Node v$g$5 = yyOpValue1;

              yyValue = GNode.create("NewClassExpression", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyOption1, yyError);
            } // End scope for v$g$5.
          }
        }
      } // End scope for v$g$2.
    }

    // Alternative 10.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("new")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pTypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pConcreteDimensions(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pDimensions(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$3.
            final Node v$g$3 = yyOpValue1;

            yyValue = GNode.create("NewArrayExpression", v$g$1, v$g$2, v$g$3, null);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for v$g$3.
        }

        // Nested alternative 2.

        yyOption1  = yyChoice1;
        yyOpValue1 = null;

        yyResult = pDimensions(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$6.
          final Node v$g$6 = yyOpValue1;

          yyResult = pArrayInitializer(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$7 = yyResult.semanticValue();

            yyValue = GNode.create("NewArrayExpression", v$g$1, null, v$g$6, v$g$7);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          }
        } // End scope for v$g$6.
      }
    }

    // Alternative <Nested>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$3 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
          final Node v$pt$2 = yyResult.semanticValue();
          yyValue = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("primary expression expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ConcreteDimensions.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConcreteDimensions(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pConcreteDimension(yyRepetition1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepeated1   = true;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }

    if (yyRepeated1) {
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("ConcreteDimensions", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ConcreteDimension.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pConcreteDimension(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("[")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$3 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("]")) {
          final Node v$pt$2 = yyResult.semanticValue();
          yyValue = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("concrete dimension expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ArrayInitializer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayInitializer(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArrayInitializer$$Split1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      } else {
        yyError = yyError.select("',' expected", yyBase);
      }
      { // Start scope for v$pt$2.
        final Node v$pt$2 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
          final Node v$pt$3 = yyResult.semanticValue();
          yyValue = Formatting.variable().
            addNode(v$pt$1).add(v$pt$2).add(v$pt$3);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      } // End scope for v$pt$2.
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
      final Node v$pt$4 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
        final Node v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      } else {
        yyError = yyError.select("',' expected", yyBase);
      }
      { // Start scope for v$pt$5.
        final Node v$pt$5 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
          final Node v$pt$6 = yyResult.semanticValue();

          yyValue = GNode.create("ArrayInitializer", false);
          yyValue.setLocation(location(yyStart));
          yyValue = Formatting.variable().addNode(yyValue).
            add(v$pt$4).add(v$pt$5).add(v$pt$6);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      } // End scope for v$pt$5.
    }

    // Done.
    yyError = yyError.select("array initializer expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.ArrayInitializer$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArrayInitializer$$Split1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
      final Node v$pt$3 = yyResult.semanticValue();

      yyResult = pVariableInitializer(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$4 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$3, v$pt$4);

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
            final Node v$pt$1 = yyResult.semanticValue();

            yyResult = pVariableInitializer(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$pt$2 = yyResult.semanticValue();
              final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("ArrayInitializer", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("array initializer expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.VariableInitializer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariableInitializer(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fVariableInitializer) 
      yyColumn.chunk2.fVariableInitializer = pVariableInitializer$1(yyStart);
    return yyColumn.chunk2.fVariableInitializer;
  }

  /** Actually parse xtc.lang.JavaFive.VariableInitializer. */
  private Result pVariableInitializer$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Array>.

    yyResult = pArrayInitializer(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Expression>.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.Arguments.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArguments(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pArguments$$Split1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
        final Node v$pt$2 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$1, v$pt$2);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("')' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$pt$3 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
        final Node v$pt$4 = yyResult.semanticValue();

        yyValue = GNode.create("Arguments", false);
        yyValue.setLocation(location(yyStart));
        yyValue = Formatting.variable().addNode(yyValue).
          add(v$pt$3).add(v$pt$4);

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("')' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("arguments expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.Arguments$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pArguments$$Split1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$pt$3 = yyResult.semanticValue();

      yyResult = pExpression(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$4 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$3, v$pt$4);

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
            final Node v$pt$1 = yyResult.semanticValue();

            yyResult = pExpression(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$pt$2 = yyResult.semanticValue();
              final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("Arguments", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("arguments expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.VariableModifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVariableModifier(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Final>.

    yyResult = pFinalModifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Annotation>.

    yyResult = pAnnotation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.Annotations.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAnnotations(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAnnotations) 
      yyColumn.chunk2.fAnnotations = pAnnotations$1(yyStart);
    return yyColumn.chunk2.fAnnotations;
  }

  /** Actually parse xtc.lang.JavaFive.Annotations. */
  private Result pAnnotations$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAnnotations$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("Annotations", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.Annotations$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAnnotations$$Plus1(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAnnotations$$Plus1) 
      yyColumn.chunk2.fAnnotations$$Plus1 = pAnnotations$$Plus1$1(yyStart);
    return yyColumn.chunk2.fAnnotations$$Plus1;
  }

  /** Actually parse xtc.lang.JavaFive.Annotations$$Plus1. */
  private Result pAnnotations$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pAnnotation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pAnnotations$$Plus1(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$2 = yyResult.semanticValue();

        yyValue = new Pair<Node>(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }

      // Nested alternative 2.

      yyValue = new Pair<Node>(v$el$1);

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.Annotation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAnnotation(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("@")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pTypeName(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyResult = pAnnotationValue(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("Annotation", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("annotation expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.AnnotationValue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAnnotationValue(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
      final Node v$pt$1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyOption1  = yyChoice1;
      yyOpValue1 = null;

      yyResult = pElementValuePairs(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$4 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$4;
      }
      { // Start scope for v$pt$3.
        final Node v$pt$3 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
          final Node v$pt$2 = yyResult.semanticValue();
          yyValue = Formatting.round1(v$pt$1, v$pt$3, v$pt$2);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      } // End scope for v$pt$3.

      // Nested alternative 2.

      yyResult = pElementValue(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$5 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
          final Node v$pt$4 = yyResult.semanticValue();
          yyValue = Formatting.round1(v$pt$1, v$pt$5, v$pt$4);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative <Empty>.
    { // Start scope for yyValue.
      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } // End scope for yyValue.
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ElementValuePairs.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElementValuePairs(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pElementValuePair(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyResult = pElementValuePair(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("ElementValuePairs", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ElementValuePair.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElementValuePair(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fElementValuePair) 
      yyColumn.chunk2.fElementValuePair = pElementValuePair$1(yyStart);
    return yyColumn.chunk2.fElementValuePair;
  }

  /** Actually parse xtc.lang.JavaFive.ElementValuePair. */
  private Result pElementValuePair$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("=")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyResult = pElementValue(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyValue = GNode.create("ElementValuePair", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ElementValue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElementValue(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fElementValue) 
      yyColumn.chunk2.fElementValue = pElementValue$1(yyStart);
    return yyColumn.chunk2.fElementValue;
  }

  /** Actually parse xtc.lang.JavaFive.ElementValue. */
  private Result pElementValue$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Expression>.

    yyResult = pExpression(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Annotation>.

    yyResult = pAnnotation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Array>.

    yyResult = pElementArrayInitializer(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.ElementArrayInitializer.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElementArrayInitializer(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pElementArrayInitializer$$Split1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      } else {
        yyError = yyError.select("',' expected", yyBase);
      }
      { // Start scope for v$pt$2.
        final Node v$pt$2 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
          final Node v$pt$3 = yyResult.semanticValue();
          yyValue = Formatting.variable().
            addNode(v$pt$1).add(v$pt$2).add(v$pt$3);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      } // End scope for v$pt$2.
    }

    // Alternative 2.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
      final Node v$pt$4 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
        final Node v$el$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$2;
      } else {
        yyError = yyError.select("',' expected", yyBase);
      }
      { // Start scope for v$pt$5.
        final Node v$pt$5 = yyOpValue1;

        yyBase   = yyOption1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
          final Node v$pt$6 = yyResult.semanticValue();

          yyValue = GNode.create("ArrayInitializer", false);
          yyValue.setLocation(location(yyStart));
          yyValue = Formatting.variable().addNode(yyValue).
            add(v$pt$4).add(v$pt$5).add(v$pt$6);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      } // End scope for v$pt$5.
    }

    // Done.
    yyError = yyError.select("element array initializer expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal 
   * xtc.lang.JavaFive.ElementArrayInitializer$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pElementArrayInitializer$$Split1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
      final Node v$pt$3 = yyResult.semanticValue();

      yyResult = pElementValue(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$4 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$3, v$pt$4);

        yyRepetition1 = yyResult.index;
        yyRepValue1   = Pair.empty();
        while (true) {

          yyBase   = yyRepetition1;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
            final Node v$pt$1 = yyResult.semanticValue();

            yyResult = pElementValue(yyResult.index);
            yyError  = yyResult.select(yyError, yyRepetition1);
            if (yyResult.hasValue()) {
              final Node v$pt$2 = yyResult.semanticValue();
              final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

              yyRepetition1 = yyResult.index;
              yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
              continue;
            }
          } else {
            yyError = yyError.select("',' expected", yyBase);
          }
          break;
        }
        { // Start scope for v$g$2.
          final Pair<Node> v$g$2 = yyRepValue1.reverse();

          yyValue = GNode.createFromPair("ArrayInitializer", v$g$1, v$g$2);
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyRepetition1, yyError);
        } // End scope for v$g$2.
      }
    }

    // Done.
    yyError = yyError.select("element array initializer expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.AnnotationBody.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAnnotationBody(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Body>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pAnnotationBody$$Split1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
          final Node v$pt$3 = yyResult.semanticValue();
          yyValue = Formatting.round1(v$pt$1, v$pt$2, v$pt$3);

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'}' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("annotation body expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.AnnotationBody$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAnnotationBody$$Split1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Body>.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pAnnotationElement(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("ClassBody", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.AnnotationElement.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pAnnotationElement(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pIdentifier(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$3 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals("(")) {
            final Node v$pt$1 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue() &&
                ((Node)yyResult.semanticValue()).getTokenText().equals(")")) {
              final Node v$pt$2 = yyResult.semanticValue();
              final Node v$g$3 = Formatting.variable().
                addNode(v$pt$3).add(v$pt$1).add(v$pt$2);

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pDefaultValue(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                final Node v$el$1 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$1;
              }
              { // Start scope for v$pt$5.
                final Node v$pt$5 = yyOpValue1;

                yyBase   = yyOption1;
                yyResult = pSymbol(yyBase);
                if (yyResult.hasValue() &&
                    ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
                  final Node v$pt$4 = yyResult.semanticValue();
                  final Node v$g$4 = Formatting.after1(v$pt$5, v$pt$4);

                  yyValue = GNode.create("AnnotationMethod", v$g$1, v$g$2, v$g$3, v$g$4);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                } else {
                  yyError = yyError.select("';' expected", yyBase);
                }
              } // End scope for v$pt$5.
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          } else {
            yyError = yyError.select("'(' expected", yyBase);
          }
        }

        // Nested alternative 2.

        yyResult = pDeclarators(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol(yyBase);
          if (yyResult.hasValue() &&
              ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
            final Node v$pt$1 = yyResult.semanticValue();
            final Node v$g$3 = Formatting.after1(v$pt$2, v$pt$1);

            yyValue = GNode.create("FieldDeclaration", v$g$1, v$g$2, v$g$3);
            yyValue.setLocation(location(yyStart));

            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("';' expected", yyBase);
          }
        }
      }
    }

    // Alternative 2.

    yyResult = pModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("class")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyResult = pIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pTypeParameters(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$3.
            final Node v$g$3 = yyOpValue1;

            yyOpValue1 = null;

            yyResult = pExtension(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$4.
              final Node v$g$4 = yyOpValue1;

              yyOpValue1 = null;

              yyResult = pImplementation(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                final Node v$el$3 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$3;
              }
              { // Start scope for v$g$5.
                final Node v$g$5 = yyOpValue1;

                yyResult = pClassBody(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  final Node v$g$6 = yyResult.semanticValue();

                  yyValue = GNode.create("ClassDeclaration", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5, v$g$6);
                  yyValue.setLocation(location(yyStart));

                  return yyResult.createValue(yyValue, yyError);
                }
              } // End scope for v$g$5.
            } // End scope for v$g$4.
          } // End scope for v$g$3.
        }
      } else {
        yyError = yyError.select("'class' expected", yyBase);
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("interface")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyResult = pIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pTypeParameters(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$g$3.
            final Node v$g$3 = yyOpValue1;

            yyOpValue1 = null;

            yyResult = pExtension(yyOption1);
            yyError  = yyResult.select(yyError, yyOption1);
            if (yyResult.hasValue()) {
              final Node v$el$2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;
              yyOpValue1 = v$el$2;
            }
            { // Start scope for v$g$4.
              final Node v$g$4 = yyOpValue1;

              yyResult = pClassBody(yyOption1);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                final Node v$g$5 = yyResult.semanticValue();

                yyValue = GNode.create("InterfaceDeclaration", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);
                yyValue.setLocation(location(yyStart));

                return yyResult.createValue(yyValue, yyError);
              }
            } // End scope for v$g$4.
          } // End scope for v$g$3.
        }
      } else {
        yyError = yyError.select("'interface' expected", yyBase);
      }

      // Nested alternative 3.

      yyBase   = yyChoice1;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("enum")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.after1(v$pt$2, v$pt$1);

        yyResult = pIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$g$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pImplementation(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$1 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$1;
          }
          { // Start scope for v$pt$4.
            final Node v$pt$4 = yyOpValue1;

            yyBase   = yyOption1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue() &&
                ((Node)yyResult.semanticValue()).getTokenText().equals("{")) {
              final Node v$pt$3 = yyResult.semanticValue();
              final Node v$g$3 = Formatting.after1(v$pt$4, v$pt$3);

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pEnumConstants(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                final Node v$el$2 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$2;
              }
              { // Start scope for v$pt$6.
                final Node v$pt$6 = yyOpValue1;

                yyOpValue1 = null;

                yyBase   = yyOption1;
                yyResult = pSymbol(yyBase);
                if (yyResult.hasValue() &&
                    ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
                  final Node v$el$3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = v$el$3;
                } else {
                  yyError = yyError.select("',' expected", yyBase);
                }
                { // Start scope for v$pt$5.
                  final Node v$pt$5 = yyOpValue1;
                  final Node v$g$4 = Formatting.after1(v$pt$6, v$pt$5);

                  yyOpValue1 = null;

                  yyResult = pEnumMembers(yyOption1);
                  yyError  = yyResult.select(yyError, yyOption1);
                  if (yyResult.hasValue()) {
                    final Node v$el$4 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$4;
                  }
                  { // Start scope for v$pt$8.
                    final Node v$pt$8 = yyOpValue1;

                    yyBase   = yyOption1;
                    yyResult = pSymbol(yyBase);
                    if (yyResult.hasValue() &&
                        ((Node)yyResult.semanticValue()).getTokenText().equals("}")) {
                      final Node v$pt$7 = yyResult.semanticValue();
                      final Node v$g$5 = Formatting.after1(v$pt$8, v$pt$7);

                      yyValue = GNode.create("EnumDeclaration", v$g$1, v$g$2, v$g$3, v$g$4, v$g$5);
                      yyValue.setLocation(location(yyStart));

                      return yyResult.createValue(yyValue, yyError);
                    } else {
                      yyError = yyError.select("'}' expected", yyBase);
                    }
                  } // End scope for v$pt$8.
                } // End scope for v$pt$5.
              } // End scope for v$pt$6.
            } else {
              yyError = yyError.select("'{' expected", yyBase);
            }
          } // End scope for v$pt$4.
        }
      } else {
        yyError = yyError.select("'enum' expected", yyBase);
      }
    }

    // Alternative <Declaration>.

    yyResult = pModifiers(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$3 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("@")) {
        final Node v$pt$1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("interface")) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.variable().
            addNode(v$pt$3).add(v$pt$1).add(v$pt$2);

          yyResult = pIdentifier(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            final Node v$g$2 = yyResult.semanticValue();

            yyResult = pAnnotationBody(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              final Node v$g$3 = yyResult.semanticValue();

              yyValue = GNode.create("AnnotationDeclaration", v$g$1, v$g$2, v$g$3);
              yyValue.setLocation(location(yyStart));

              return yyResult.createValue(yyValue, yyError);
            }
          }
        } else {
          yyError = yyError.select("'interface' expected", yyBase);
        }
      } else {
        yyError = yyError.select("'@' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.DefaultValue.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDefaultValue(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Default>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("default")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pElementValue(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = GNode.create("DefaultValue", v$g$1);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("default value expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.EnumConstants.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnumConstants(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Constants>.

    yyResult = pEnumConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyResult = pEnumConstant(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("',' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("EnumConstants", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.EnumConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnumConstant(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyOption1  = yyStart;
    yyOpValue1 = null;

    yyResult = pAnnotations(yyOption1);
    yyError  = yyResult.select(yyError, yyOption1);
    if (yyResult.hasValue()) {
      final Node v$el$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = v$el$1;
    }
    { // Start scope for v$g$1.
      final Node v$g$1 = yyOpValue1;

      yyResult = pIdentifier(yyOption1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = null;

        yyResult = pArguments(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$el$2 = yyResult.semanticValue();

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$2;
        }
        { // Start scope for v$g$3.
          final Node v$g$3 = yyOpValue1;

          yyOpValue1 = null;

          yyResult = pClassBody(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            final Node v$el$3 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$3;
          }
          { // Start scope for v$g$4.
            final Node v$g$4 = yyOpValue1;

            yyValue = GNode.create("EnumConstant", v$g$1, v$g$2, v$g$3, v$g$4);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyOption1, yyError);
          } // End scope for v$g$4.
        } // End scope for v$g$3.
      }
    } // End scope for v$g$1.

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFive.EnumMembers.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnumMembers(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(";")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pEnumMembers$$Split1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        yyValue = Formatting.before1(v$pt$1, v$pt$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("enum members expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.EnumMembers$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEnumMembers$$Split1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepValue1   = Pair.empty();
    while (true) {

      yyResult = pDeclaration(yyRepetition1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
        continue;
      }
      break;
    }
    { // Start scope for v$g$1.
      final Pair<Node> v$g$1 = yyRepValue1.reverse();

      yyValue = GNode.createFromPair("EnumMembers", v$g$1);
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    } // End scope for v$g$1.
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.ResultType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pResultType(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fResultType) 
      yyColumn.chunk2.fResultType = pResultType$1(yyStart);
    return yyColumn.chunk2.fResultType;
  }

  /** Actually parse xtc.lang.JavaFiveType.ResultType. */
  private Result pResultType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Void>.

    yyResult = pVoidType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Regular>.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.VoidType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pVoidType(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Void>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("void")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("VoidType", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("void type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pType(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fType) 
      yyColumn.chunk2.fType = pType$1(yyStart);
    return yyColumn.chunk2.fType;
  }

  /** Actually parse xtc.lang.JavaFiveType.Type. */
  private Result pType$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Type>.

    yyResult = pTypeName(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pDimensions(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("Type", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.TypeName.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeName(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fTypeName) 
      yyColumn.chunk3.fTypeName = pTypeName$1(yyStart);
    return yyColumn.chunk3.fTypeName;
  }

  /** Actually parse xtc.lang.JavaFiveType.TypeName. */
  private Result pTypeName$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Basic>.

    yyResult = pPrimitiveType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Class>.

    yyResult = pClassType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.PrimitiveType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pPrimitiveType(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fPrimitiveType) 
      yyColumn.chunk3.fPrimitiveType = pPrimitiveType$1(yyStart);
    return yyColumn.chunk3.fPrimitiveType;
  }

  /** Actually parse xtc.lang.JavaFiveType.PrimitiveType. */
  private Result pPrimitiveType$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Byte>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("byte")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("PrimitiveType", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Short>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("short")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("PrimitiveType", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Char>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("char")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("PrimitiveType", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Int>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("int")) {
      final Node v$g$4 = yyResult.semanticValue();

      yyValue = GNode.create("PrimitiveType", v$g$4);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Long>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("long")) {
      final Node v$g$5 = yyResult.semanticValue();

      yyValue = GNode.create("PrimitiveType", v$g$5);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Float>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("float")) {
      final Node v$g$6 = yyResult.semanticValue();

      yyValue = GNode.create("PrimitiveType", v$g$6);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Double>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("double")) {
      final Node v$g$7 = yyResult.semanticValue();

      yyValue = GNode.create("PrimitiveType", v$g$7);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Boolean>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("boolean")) {
      final Node v$g$8 = yyResult.semanticValue();

      yyValue = GNode.create("PrimitiveType", v$g$8);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("primitive type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.ClassType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pClassType(final int yyStart) throws IOException {
    int        yyC;
    Result     yyResult;
    boolean    yyPredMatched;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Name>.

    yyResult = pQualifiedIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyPredMatched = false;

      yyC = character(yyResult.index);
      if ('<' == yyC) {

        yyPredMatched = true;
      }

      if (! yyPredMatched) {

        return yyResult.createValue(yyValue, yyError);
      } else {
        yyError = yyError.select("class type expected", yyStart);
      }
    }

    // Alternative <Instantiated>.

    yyResult = pInstantiatedType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.Dimensions.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimensions(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fDimensions) 
      yyColumn.chunk3.fDimensions = pDimensions$1(yyStart);
    return yyColumn.chunk3.fDimensions;
  }

  /** Actually parse xtc.lang.JavaFiveType.Dimensions. */
  private Result pDimensions$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDimensions$$Plus1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Pair<Node> v$g$1 = yyResult.semanticValue();

      yyValue = GNode.createFromPair("Dimensions", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.Dimensions$$Plus1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDimensions$$Plus1(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fDimensions$$Plus1) 
      yyColumn.chunk3.fDimensions$$Plus1 = pDimensions$$Plus1$1(yyStart);
    return yyColumn.chunk3.fDimensions$$Plus1;
  }

  /** Actually parse xtc.lang.JavaFive.Dimensions$$Plus1. */
  private Result pDimensions$$Plus1$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("[")) {
      final Node v$pt$2 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("]")) {
        final Node v$pt$1 = yyResult.semanticValue();
        final Node v$el$1 = Formatting.after1(v$pt$2, v$pt$1);

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pDimensions$$Plus1(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }

        // Nested alternative 2.

        yyValue = new Pair<Node>(v$el$1);

        return new SemanticValue(yyValue, yyChoice1, yyError);
      } else {
        yyError = yyError.select("']' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("dimensions expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.TypeParameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeParameters(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fTypeParameters) 
      yyColumn.chunk3.fTypeParameters = pTypeParameters$1(yyStart);
    return yyColumn.chunk3.fTypeParameters;
  }

  /** Actually parse xtc.lang.JavaFiveType.TypeParameters. */
  private Result pTypeParameters$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Parameters>.

    yyResult = pTypeParameters$$Split1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('>' == yyC) {
        yyIndex = yyResult.index + 1;
        final String v$pt$2 = ">";

        yyResult = pSpacing(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Token v$pt$3 = yyResult.semanticValue();
          yyValue = Formatting.variable().
            addNode(v$pt$1).add(v$pt$2).add(v$pt$3);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'>' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.TypeParameters$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeParameters$$Split1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Parameters>.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;
      final String v$pt$3 = "<";

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$4 = yyResult.semanticValue();

        yyResult = pTypeParameter(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$5 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.variable().
            add(v$pt$3).add(v$pt$4).addNode(v$pt$5);

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyBase   = yyRepetition1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue() &&
                ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
              final Node v$pt$1 = yyResult.semanticValue();

              yyResult = pTypeParameter(yyResult.index);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                final Node v$pt$2 = yyResult.semanticValue();
                final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
                continue;
              }
            } else {
              yyError = yyError.select("',' expected", yyBase);
            }
            break;
          }
          { // Start scope for v$g$2.
            final Pair<Node> v$g$2 = yyRepValue1.reverse();

            yyValue = GNode.createFromPair("TypeParameters", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for v$g$2.
        }
      }
    }

    // Done.
    yyError = yyError.select("type parameters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.TypeParameter.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeParameter(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fTypeParameter) 
      yyColumn.chunk3.fTypeParameter = pTypeParameter$1(yyStart);
    return yyColumn.chunk3.fTypeParameter;
  }

  /** Actually parse xtc.lang.JavaFiveType.TypeParameter. */
  private Result pTypeParameter$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Parameter>.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyBase   = yyOption1;
      yyResult = pWord(yyBase);
      if (yyResult.hasValue() &&
          ((Node)yyResult.semanticValue()).getTokenText().equals("extends")) {
        final Node v$pt$1 = yyResult.semanticValue();

        yyResult = pBound(yyResult.index);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {
          final Node v$pt$2 = yyResult.semanticValue();
          final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

          yyOption1  = yyResult.index;
          yyOpValue1 = v$el$1;
        }
      } else {
        yyError = yyError.select("'extends' expected", yyBase);
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("TypeParameter", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.Bound.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pBound(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Bound>.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals("&")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyResult = pType(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("'&' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("Bound", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.TypeArguments.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeArguments(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fTypeArguments) 
      yyColumn.chunk3.fTypeArguments = pTypeArguments$1(yyStart);
    return yyColumn.chunk3.fTypeArguments;
  }

  /** Actually parse xtc.lang.JavaFiveType.TypeArguments. */
  private Result pTypeArguments$1(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Arguments>.

    yyResult = pTypeArguments$$Split1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyBase = yyResult.index;
      yyC    = character(yyBase);
      if ('>' == yyC) {
        yyIndex = yyResult.index + 1;
        final String v$pt$2 = ">";

        yyResult = pSpacing(yyIndex);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Token v$pt$3 = yyResult.semanticValue();
          yyValue = Formatting.variable().
            addNode(v$pt$1).add(v$pt$2).add(v$pt$3);

          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'>' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.TypeArguments$$Split1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeArguments$$Split1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Arguments>.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;
      final String v$pt$3 = "<";

      yyResult = pSpacing(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$4 = yyResult.semanticValue();

        yyResult = pTypeArgument(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Node v$pt$5 = yyResult.semanticValue();
          final Node v$g$1 = Formatting.variable().
            add(v$pt$3).add(v$pt$4).addNode(v$pt$5);

          yyRepetition1 = yyResult.index;
          yyRepValue1   = Pair.empty();
          while (true) {

            yyBase   = yyRepetition1;
            yyResult = pSymbol(yyBase);
            if (yyResult.hasValue() &&
                ((Node)yyResult.semanticValue()).getTokenText().equals(",")) {
              final Node v$pt$1 = yyResult.semanticValue();

              yyResult = pTypeArgument(yyResult.index);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                final Node v$pt$2 = yyResult.semanticValue();
                final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

                yyRepetition1 = yyResult.index;
                yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
                continue;
              }
            } else {
              yyError = yyError.select("',' expected", yyBase);
            }
            break;
          }
          { // Start scope for v$g$2.
            final Pair<Node> v$g$2 = yyRepValue1.reverse();

            yyValue = GNode.createFromPair("TypeArguments", v$g$1, v$g$2);
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyRepetition1, yyError);
          } // End scope for v$g$2.
        }
      }
    }

    // Done.
    yyError = yyError.select("type arguments expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.TypeArgument.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeArgument(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fTypeArgument) 
      yyColumn.chunk3.fTypeArgument = pTypeArgument$1(yyStart);
    return yyColumn.chunk3.fTypeArgument;
  }

  /** Actually parse xtc.lang.JavaFiveType.TypeArgument. */
  private Result pTypeArgument$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Type>.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Wildcard>.

    yyResult = pWildcard(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.Wildcard.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWildcard(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Wildcard>.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("?")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pWildcardBound(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$pt$2.
        final Node v$pt$2 = yyOpValue1;
        final Node v$g$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyValue = GNode.create("Wildcard", v$g$1);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$pt$2.
    }

    // Done.
    yyError = yyError.select("wildcard expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.WildcardBound.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWildcardBound(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Extends>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("extends")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$2 = yyResult.semanticValue();

        yyValue = GNode.create("WildcardBound", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Super>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("super")) {
      final Node v$g$3 = yyResult.semanticValue();

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$g$4 = yyResult.semanticValue();

        yyValue = GNode.create("WildcardBound", v$g$3, v$g$4);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("wildcard bound expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.InstantiatedType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pInstantiatedType(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyRepetition1;
    Pair<Node> yyRepValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Reference>.

    yyResult = pTypeInstantiation(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyBase   = yyRepetition1;
        yyResult = pSymbol(yyBase);
        if (yyResult.hasValue() &&
            ((Node)yyResult.semanticValue()).getTokenText().equals(".")) {
          final Node v$pt$1 = yyResult.semanticValue();

          yyResult = pTypeInstantiation(yyResult.index);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            final Node v$pt$2 = yyResult.semanticValue();
            final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

            yyRepetition1 = yyResult.index;
            yyRepValue1   = new Pair<Node>(v$el$1, yyRepValue1);
            continue;
          }
        } else {
          yyError = yyError.select("'.' expected", yyBase);
        }
        break;
      }
      { // Start scope for v$g$2.
        final Pair<Node> v$g$2 = yyRepValue1.reverse();

        yyValue = GNode.createFromPair("InstantiatedType", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveType.TypeInstantiation.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pTypeInstantiation(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fTypeInstantiation) 
      yyColumn.chunk3.fTypeInstantiation = pTypeInstantiation$1(yyStart);
    return yyColumn.chunk3.fTypeInstantiation;
  }

  /** Actually parse xtc.lang.JavaFiveType.TypeInstantiation. */
  private Result pTypeInstantiation$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyOption1;
    Node       yyOpValue1;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Instantiation>.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyOption1  = yyResult.index;
      yyOpValue1 = null;

      yyResult = pTypeArguments(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {
        final Node v$el$1 = yyResult.semanticValue();

        yyOption1  = yyResult.index;
        yyOpValue1 = v$el$1;
      }
      { // Start scope for v$g$2.
        final Node v$g$2 = yyOpValue1;

        yyValue = GNode.create("TypeInstantiation", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      } // End scope for v$g$2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.Literal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <FloatingPoint>.

    yyResult = pFloatingPointLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$2 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$1 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$2, v$pt$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Integer>.

    yyResult = pIntegerLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$4 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$3 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$4, v$pt$3);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <Character>.

    yyResult = pCharacterLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$6 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$5 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$6, v$pt$5);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <String>.

    yyResult = pStringLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$pt$8 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$7 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$8, v$pt$7);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative <True>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("true")) {
      final Node v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("BooleanLiteral", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <False>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("false")) {
      final Node v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("BooleanLiteral", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Null>.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals("null")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyValue = GNode.create("NullLiteral", false);
      yyValue.setLocation(location(yyStart));
      yyValue = Formatting.after1(yyValue, v$pt$1);

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.IntegerLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIntegerLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative <Hex>.

    yyResult = pHexLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("IntegerLiteral", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Octal>.

    yyResult = pOctalLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$g$2 = yyResult.semanticValue();

      yyValue = GNode.create("IntegerLiteral", v$g$2);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative <Decimal>.

    yyResult = pDecimalLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$g$3 = yyResult.semanticValue();

      yyValue = GNode.create("IntegerLiteral", v$g$3);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.HexLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pHexNumeral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'L':
        case 'l':
          {
            yyOption1  = yyIndex;
          }
          break;

        default:
          /* No match. */
        }
      }

      yyValue = new TextToken(difference(yyStart, yyOption1));
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("hex literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.OctalLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOctalLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pOctalNumeral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'L':
        case 'l':
          {
            yyOption1  = yyIndex;
          }
          break;

        default:
          /* No match. */
        }
      }

      yyValue = new TextToken(difference(yyStart, yyOption1));
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("octal literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.DecimalLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalLiteral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDecimalNumeral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyOption1  = yyResult.index;

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'L':
        case 'l':
          {
            yyOption1  = yyIndex;
          }
          break;

        default:
          /* No match. */
        }
      }

      yyValue = new TextToken(difference(yyStart, yyOption1));
      yyValue.setLocation(location(yyStart));

      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("decimal literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.DecimalNumeral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDecimalNumeral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyOption1  = yyIndex;

          yyResult = pDigits(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {

            yyOption1  = yyResult.index;
          }

          yyValue = null;

          return new SemanticValue(yyValue, yyOption1, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("decimal numeral expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.Digits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.HexNumeral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexNumeral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if (-1 != yyC) {
        yyIndex = yyIndex + 1;

        switch (yyC) {
        case 'X':
        case 'x':
          {
            yyResult = pHexDigits(yyIndex);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {

              yyValue = null;

              return yyResult.createValue(yyValue, yyError);
            }
          }
          break;

        default:
          /* No match. */
        }
      }
    }

    // Done.
    yyError = yyError.select("hex numeral expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.HexDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pHexDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("hex digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.OctalNumeral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOctalNumeral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('0' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pOctalDigits(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyValue = null;

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("octal numeral expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.OctalDigits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pOctalDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    boolean    yyRepeated1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    yyRepeated1   = false;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
          {
            yyRepetition1 = yyIndex;
            yyRepeated1   = true;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    if (yyRepeated1) {

      yyValue = null;

      return new SemanticValue(yyValue, yyRepetition1, yyError);
    }

    // Done.
    yyError = yyError.select("octal digits expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.FloatingPointLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatingPointLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pFloatingPointString(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("FloatingPointLiteral", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.FloatingPointString.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pFloatingPointString(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDigits(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyC = character(yyResult.index);
      if ('.' == yyC) {
        yyIndex = yyResult.index + 1;

        yyOption1  = yyIndex;

        yyResult = pDigits(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }


        yyResult = pExponent(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }


        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'D':
          case 'F':
          case 'd':
          case 'f':
            {
              yyOption1  = yyIndex;
            }
            break;

          default:
            /* No match. */
          }
        }

        yyValue = new TextToken(difference(yyStart, yyOption1));
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if ('.' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pDigits(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;

        yyResult = pExponent(yyOption1);
        yyError  = yyResult.select(yyError, yyOption1);
        if (yyResult.hasValue()) {

          yyOption1  = yyResult.index;
        }


        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'D':
          case 'F':
          case 'd':
          case 'f':
            {
              yyOption1  = yyIndex;
            }
            break;

          default:
            /* No match. */
          }
        }

        yyValue = new TextToken(difference(yyStart, yyOption1));
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      }
    }

    // Alternative 3.

    yyResult = pDigits(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExponent(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;

        yyC = character(yyOption1);
        if (-1 != yyC) {
          yyIndex = yyOption1 + 1;

          switch (yyC) {
          case 'D':
          case 'F':
          case 'd':
          case 'f':
            {
              yyOption1  = yyIndex;
            }
            break;

          default:
            /* No match. */
          }
        }

        yyValue = new TextToken(difference(yyStart, yyOption1));
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyOption1, yyError);
      }

      // Nested alternative 2.

      yyOption1  = yyChoice1;

      yyResult = pExponent(yyOption1);
      yyError  = yyResult.select(yyError, yyOption1);
      if (yyResult.hasValue()) {

        yyOption1  = yyResult.index;
      }

      yyC = character(yyOption1);
      if (-1 != yyC) {
        yyIndex = yyOption1 + 1;

        switch (yyC) {
        case 'D':
        case 'F':
        case 'd':
        case 'f':
          {
            yyValue = new TextToken(difference(yyStart, yyIndex));
            yyValue.setLocation(location(yyStart));

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

        default:
          /* No match. */
        }
      }
    }

    // Done.
    yyError = yyError.select("floating point string expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.Exponent.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExponent(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyOption1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case 'E':
      case 'e':
        {
          yyOption1  = yyIndex;

          yyC = character(yyOption1);
          if (-1 != yyC) {
            yyIndex = yyOption1 + 1;

            switch (yyC) {
            case '+':
            case '-':
              {
                yyOption1  = yyIndex;
              }
              break;

            default:
              /* No match. */
            }
          }

          yyResult = pDigits(yyOption1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = null;

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("exponent expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.CharacterLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCharacterConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("CharacterLiteral", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.StringLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pStringConstant(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$g$1 = yyResult.semanticValue();

      yyValue = GNode.create("StringLiteral", v$g$1);
      yyValue.setLocation(location(yyStart));

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.CharacterConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterConstant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\'' == yyC) {
      yyIndex = yyStart + 1;

      yyResult = pCharacterConstant$$Choice1(yyIndex);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        yyC = character(yyResult.index);
        if ('\'' == yyC) {
          yyIndex = yyResult.index + 1;

          yyValue = new TextToken(difference(yyStart, yyIndex));
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("character constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.CharacterConstant$$Choice1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pCharacterConstant$$Choice1(final int yyStart) 
    throws IOException {

    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\\':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '\"':
            case '\'':
            case '\\':
            case 'b':
            case 'f':
            case 'n':
            case 'r':
            case 't':
              {
                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case 'u':
              {
                yyC = character(yyIndex);
                if (-1 != yyC) {
                  yyIndex = yyIndex + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                  case '8':
                  case '9':
                  case 'A':
                  case 'B':
                  case 'C':
                  case 'D':
                  case 'E':
                  case 'F':
                  case 'a':
                  case 'b':
                  case 'c':
                  case 'd':
                  case 'e':
                  case 'f':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                        case 'A':
                        case 'B':
                        case 'C':
                        case 'D':
                        case 'E':
                        case 'F':
                        case 'a':
                        case 'b':
                        case 'c':
                        case 'd':
                        case 'e':
                        case 'f':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;

                              switch (yyC) {
                              case '0':
                              case '1':
                              case '2':
                              case '3':
                              case '4':
                              case '5':
                              case '6':
                              case '7':
                              case '8':
                              case '9':
                              case 'A':
                              case 'B':
                              case 'C':
                              case 'D':
                              case 'E':
                              case 'F':
                              case 'a':
                              case 'b':
                              case 'c':
                              case 'd':
                              case 'e':
                              case 'f':
                                {
                                  yyC = character(yyIndex);
                                  if (-1 != yyC) {
                                    yyIndex = yyIndex + 1;

                                    switch (yyC) {
                                    case '0':
                                    case '1':
                                    case '2':
                                    case '3':
                                    case '4':
                                    case '5':
                                    case '6':
                                    case '7':
                                    case '8':
                                    case '9':
                                    case 'A':
                                    case 'B':
                                    case 'C':
                                    case 'D':
                                    case 'E':
                                    case 'F':
                                    case 'a':
                                    case 'b':
                                    case 'c':
                                    case 'd':
                                    case 'e':
                                    case 'f':
                                      {
                                        yyValue = null;

                                        return new SemanticValue(yyValue, yyIndex, yyError);
                                      }

                                    default:
                                      /* No match. */
                                    }
                                  }
                                }
                                break;

                              default:
                                /* No match. */
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }
              }
              break;

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.
          { // Start scope for nested choice.

            final int yyChoice2 = yyChoice1;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
                {
                  yyC = character(yyIndex);
                  if (-1 != yyC) {
                    yyIndex = yyIndex + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                      {
                        yyC = character(yyIndex);
                        if (-1 != yyC) {
                          yyIndex = yyIndex + 1;

                          switch (yyC) {
                          case '0':
                          case '1':
                          case '2':
                          case '3':
                          case '4':
                          case '5':
                          case '6':
                          case '7':
                            {
                              yyValue = null;

                              return new SemanticValue(yyValue, yyIndex, yyError);
                            }

                          default:
                            /* No match. */
                          }
                        }
                      }
                      break;

                    default:
                      /* No match. */
                    }
                  }
                }
                break;

              default:
                /* No match. */
              }
            }

            // Nested alternative 2.

            yyC = character(yyChoice2);
            if (-1 != yyC) {
              yyIndex = yyChoice2 + 1;

              switch (yyC) {
              case '0':
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
                {
                  final int yyChoice3 = yyIndex;

                  // Nested alternative 1.

                  yyC = character(yyChoice3);
                  if (-1 != yyC) {
                    yyIndex = yyChoice3 + 1;

                    switch (yyC) {
                    case '0':
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                    case '5':
                    case '6':
                    case '7':
                      {
                        yyValue = null;

                        return new SemanticValue(yyValue, yyIndex, yyError);
                      }

                    default:
                      /* No match. */
                    }
                  }

                  // Nested alternative 2.

                  yyValue = null;

                  return new SemanticValue(yyValue, yyChoice3, yyError);
                }

              default:
                /* No match. */
              }
            }
          } // End scope for nested choice.
        }
        break;

      default:
        /* No match. */
      }
    }

    // Alternative 2.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\'':
      case '\\':
        /* No match. */
        break;

      default:
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("character constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaConstant.StringConstant.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStringConstant(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('\"' == yyC) {
      yyIndex = yyStart + 1;

      yyRepetition1 = yyIndex;
      while (true) {

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\\':
            {
              final int yyChoice2 = yyIndex;

              // Nested alternative 1.

              yyC = character(yyChoice2);
              if (-1 != yyC) {
                yyIndex = yyChoice2 + 1;

                switch (yyC) {
                case '\"':
                case '\'':
                case '\\':
                case 'b':
                case 'f':
                case 'n':
                case 'r':
                case 't':
                  {
                    yyRepetition1 = yyIndex;
                    continue;
                  }

                case 'u':
                  {
                    yyC = character(yyIndex);
                    if (-1 != yyC) {
                      yyIndex = yyIndex + 1;

                      switch (yyC) {
                      case '0':
                      case '1':
                      case '2':
                      case '3':
                      case '4':
                      case '5':
                      case '6':
                      case '7':
                      case '8':
                      case '9':
                      case 'A':
                      case 'B':
                      case 'C':
                      case 'D':
                      case 'E':
                      case 'F':
                      case 'a':
                      case 'b':
                      case 'c':
                      case 'd':
                      case 'e':
                      case 'f':
                        {
                          yyC = character(yyIndex);
                          if (-1 != yyC) {
                            yyIndex = yyIndex + 1;

                            switch (yyC) {
                            case '0':
                            case '1':
                            case '2':
                            case '3':
                            case '4':
                            case '5':
                            case '6':
                            case '7':
                            case '8':
                            case '9':
                            case 'A':
                            case 'B':
                            case 'C':
                            case 'D':
                            case 'E':
                            case 'F':
                            case 'a':
                            case 'b':
                            case 'c':
                            case 'd':
                            case 'e':
                            case 'f':
                              {
                                yyC = character(yyIndex);
                                if (-1 != yyC) {
                                  yyIndex = yyIndex + 1;

                                  switch (yyC) {
                                  case '0':
                                  case '1':
                                  case '2':
                                  case '3':
                                  case '4':
                                  case '5':
                                  case '6':
                                  case '7':
                                  case '8':
                                  case '9':
                                  case 'A':
                                  case 'B':
                                  case 'C':
                                  case 'D':
                                  case 'E':
                                  case 'F':
                                  case 'a':
                                  case 'b':
                                  case 'c':
                                  case 'd':
                                  case 'e':
                                  case 'f':
                                    {
                                      yyC = character(yyIndex);
                                      if (-1 != yyC) {
                                        yyIndex = yyIndex + 1;

                                        switch (yyC) {
                                        case '0':
                                        case '1':
                                        case '2':
                                        case '3':
                                        case '4':
                                        case '5':
                                        case '6':
                                        case '7':
                                        case '8':
                                        case '9':
                                        case 'A':
                                        case 'B':
                                        case 'C':
                                        case 'D':
                                        case 'E':
                                        case 'F':
                                        case 'a':
                                        case 'b':
                                        case 'c':
                                        case 'd':
                                        case 'e':
                                        case 'f':
                                          {
                                            yyRepetition1 = yyIndex;
                                            continue;
                                          }

                                        default:
                                          /* No match. */
                                        }
                                      }
                                    }
                                    break;

                                  default:
                                    /* No match. */
                                  }
                                }
                              }
                              break;

                            default:
                              /* No match. */
                            }
                          }
                        }
                        break;

                      default:
                        /* No match. */
                      }
                    }
                  }
                  break;

                default:
                  /* No match. */
                }
              }

              // Nested alternative 2.
              { // Start scope for nested choice.

                final int yyChoice3 = yyChoice2;

                // Nested alternative 1.

                yyC = character(yyChoice3);
                if (-1 != yyC) {
                  yyIndex = yyChoice3 + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                    {
                      yyC = character(yyIndex);
                      if (-1 != yyC) {
                        yyIndex = yyIndex + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                          {
                            yyC = character(yyIndex);
                            if (-1 != yyC) {
                              yyIndex = yyIndex + 1;

                              switch (yyC) {
                              case '0':
                              case '1':
                              case '2':
                              case '3':
                              case '4':
                              case '5':
                              case '6':
                              case '7':
                                {
                                  yyRepetition1 = yyIndex;
                                  continue;
                                }

                              default:
                                /* No match. */
                              }
                            }
                          }
                          break;

                        default:
                          /* No match. */
                        }
                      }
                    }
                    break;

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyC = character(yyChoice3);
                if (-1 != yyC) {
                  yyIndex = yyChoice3 + 1;

                  switch (yyC) {
                  case '0':
                  case '1':
                  case '2':
                  case '3':
                  case '4':
                  case '5':
                  case '6':
                  case '7':
                    {
                      final int yyChoice4 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice4);
                      if (-1 != yyC) {
                        yyIndex = yyChoice4 + 1;

                        switch (yyC) {
                        case '0':
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                          {
                            yyRepetition1 = yyIndex;
                            continue;
                          }

                        default:
                          /* No match. */
                        }
                      }

                      // Nested alternative 2.

                      yyRepetition1 = yyChoice4;
                      continue;
                    }

                  default:
                    /* No match. */
                  }
                }
              } // End scope for nested choice.
            }
            break;

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\"':
          case '\\':
            /* No match. */
            break;

          default:
            {
              yyRepetition1 = yyIndex;
              continue;
            }
          }
        }
        break;
      }

      yyC = character(yyRepetition1);
      if ('\"' == yyC) {
        yyIndex = yyRepetition1 + 1;

        yyValue = new TextToken(difference(yyStart, yyIndex));
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyIndex, yyError);
      }
    }

    // Done.
    yyError = yyError.select("string constant expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveIdentifier.QualifiedIdentifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualifiedIdentifier(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fQualifiedIdentifier) 
      yyColumn.chunk3.fQualifiedIdentifier = pQualifiedIdentifier$1(yyStart);
    return yyColumn.chunk3.fQualifiedIdentifier;
  }

  /** Actually parse xtc.lang.JavaFiveIdentifier.QualifiedIdentifier. */
  private Result pQualifiedIdentifier$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Node v$g$1 = yyResult.semanticValue();

      yyResult = pQualifiedIdentifier$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Pair<Node> v$g$2 = yyResult.semanticValue();

        yyValue = GNode.createFromPair("QualifiedIdentifier", v$g$1, v$g$2);
        yyValue.setLocation(location(yyStart));

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal xtc.lang.JavaFive.QualifiedIdentifier$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pQualifiedIdentifier$$Star1(final int yyStart) 
    throws IOException {

    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fQualifiedIdentifier$$Star1) 
      yyColumn.chunk4.fQualifiedIdentifier$$Star1 = pQualifiedIdentifier$$Star1$1(yyStart);
    return yyColumn.chunk4.fQualifiedIdentifier$$Star1;
  }

  /** Actually parse xtc.lang.JavaFive.QualifiedIdentifier$$Star1. */
  private Result pQualifiedIdentifier$$Star1$1(final int yyStart) 
    throws IOException {

    Result     yyResult;
    Pair<Node> yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol(yyStart);
    if (yyResult.hasValue() &&
        ((Node)yyResult.semanticValue()).getTokenText().equals(".")) {
      final Node v$pt$1 = yyResult.semanticValue();

      yyResult = pIdentifier(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Node v$pt$2 = yyResult.semanticValue();
        final Node v$el$1 = Formatting.before1(v$pt$1, v$pt$2);

        yyResult = pQualifiedIdentifier$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          final Pair<Node> v$2 = yyResult.semanticValue();

          yyValue = new Pair<Node>(v$el$1, v$2);

          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyValue = Pair.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveIdentifier.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pIdentifier(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fIdentifier) 
      yyColumn.chunk4.fIdentifier = pIdentifier$1(yyStart);
    return yyColumn.chunk4.fIdentifier;
  }

  /** Actually parse xtc.lang.JavaFiveIdentifier.Identifier. */
  private Result pIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (! contains(JAVA_KEYWORDS, toText(yyValue))) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("identifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveIdentifier.Word.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWord(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fWord) 
      yyColumn.chunk4.fWord = pWord$1(yyStart);
    return yyColumn.chunk4.fWord;
  }

  /** Actually parse xtc.lang.JavaFiveIdentifier.Word. */
  private Result pWord$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWordCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$pt$2 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$1 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$2, v$pt$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveIdentifier.WordCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pWordCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      final char start = (char)yyC;

      if (Character.isJavaIdentifierStart(start)) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            final char part = (char)yyC;

            if (Character.isJavaIdentifierPart(part)) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = new TextToken(difference(yyStart, yyRepetition1));
        yyValue.setLocation(location(yyStart));

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("word characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveSymbol.Symbol.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol(final int yyStart) throws IOException {
    JavaFiveReaderColumn yyColumn = (JavaFiveReaderColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fSymbol) 
      yyColumn.chunk4.fSymbol = pSymbol$1(yyStart);
    return yyColumn.chunk4.fSymbol;
  }

  /** Actually parse xtc.lang.JavaFiveSymbol.Symbol. */
  private Result pSymbol$1(final int yyStart) throws IOException {
    Result     yyResult;
    Node       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbolCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      final Token v$pt$2 = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Token v$pt$1 = yyResult.semanticValue();
        yyValue = Formatting.after1(v$pt$2, v$pt$1);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.lang.JavaFiveSymbol.SymbolCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbolCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '>':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '>':
              {
                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;

                  switch (yyC) {
                  case '>':
                    {
                      final int yyChoice3 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice3);
                      if (-1 != yyC) {
                        yyIndex = yyChoice3 + 1;
                        if ('=' == yyC) {

                          yyValue = new TextToken(">>>=");
                          yyValue.setLocation(location(yyStart));

                          return new SemanticValue(yyValue, yyIndex, yyError);
                        }
                      }

                      // Nested alternative 2.

                      yyValue = new TextToken(">>>");
                      yyValue.setLocation(location(yyStart));

                      return new SemanticValue(yyValue, yyChoice3, yyError);
                    }

                  case '=':
                    {
                      yyValue = new TextToken(">>=");
                      yyValue.setLocation(location(yyStart));

                      return new SemanticValue(yyValue, yyIndex, yyError);
                    }

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyValue = new TextToken(">>");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyChoice2, yyError);
              }

            case '=':
              {
                yyValue = new TextToken(">=");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken(">");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '<':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '<':
              {
                final int yyChoice2 = yyIndex;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;
                  if ('=' == yyC) {

                    yyValue = new TextToken("<<=");
                    yyValue.setLocation(location(yyStart));

                    return new SemanticValue(yyValue, yyIndex, yyError);
                  }
                }

                // Nested alternative 2.

                yyValue = new TextToken("<<");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyChoice2, yyError);
              }

            case '=':
              {
                yyValue = new TextToken("<=");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("<");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '.':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('.' == yyC) {

              yyC = character(yyIndex);
              if (-1 != yyC) {
                yyIndex = yyIndex + 1;
                if ('.' == yyC) {

                  yyValue = new TextToken("...");
                  yyValue.setLocation(location(yyStart));

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken(".");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '+':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = new TextToken("+=");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '+':
              {
                yyValue = new TextToken("++");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("+");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '-':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = new TextToken("-=");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '-':
              {
                yyValue = new TextToken("--");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("-");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '*':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = new TextToken("*=");
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("*");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '/':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = new TextToken("/=");
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("/");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '%':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = new TextToken("%=");
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("%");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '&':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = new TextToken("&=");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '&':
              {
                yyValue = new TextToken("&&");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("&");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '^':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = new TextToken("^=");
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("^");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '|':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = new TextToken("|=");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '|':
              {
                yyValue = new TextToken("||");
                yyValue.setLocation(location(yyStart));

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("|");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '=':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = new TextToken("==");
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("=");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '!':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if (-1 != yyC) {
            yyIndex = yyChoice1 + 1;
            if ('=' == yyC) {

              yyValue = new TextToken("!=");
              yyValue.setLocation(location(yyStart));

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }

          // Nested alternative 2.

          yyValue = new TextToken("!");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case ';':
        {
          yyValue = new TextToken(";");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ':':
        {
          yyValue = new TextToken(":");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ',':
        {
          yyValue = new TextToken(",");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '{':
        {
          yyValue = new TextToken("{");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = new TextToken("}");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '(':
        {
          yyValue = new TextToken("(");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ')':
        {
          yyValue = new TextToken(")");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = new TextToken("[");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = new TextToken("]");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '~':
        {
          yyValue = new TextToken("~");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '@':
        {
          yyValue = new TextToken("@");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '?':
        {
          yyValue = new TextToken("?");
          yyValue.setLocation(location(yyStart));

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("symbol characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.util.Spacing.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSpacing(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    int        yyRepetition2;
    Token      yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\r':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('\n' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }

            // Nested alternative 2.

            yyRepetition1 = yyChoice2;
            continue;
          }

        case '\n':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '/':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;

              switch (yyC) {
              case '*':
                {
                  yyRepetition2 = yyIndex;
                  while (true) {

                    final int yyChoice2 = yyRepetition2;

                    // Nested alternative 1.

                    yyC = character(yyChoice2);
                    if (-1 != yyC) {
                      yyIndex = yyChoice2 + 1;

                      switch (yyC) {
                      case '*':
                        {
                          yyPredMatched = false;

                          yyC = character(yyIndex);
                          if ('/' == yyC) {

                            yyPredMatched = true;
                          }

                          if (! yyPredMatched) {

                            yyRepetition2 = yyIndex;
                            continue;
                          } else {
                            yyError = yyError.select("spacing expected", yyStart);
                          }
                        }
                        break;

                      default:
                        {
                          yyRepetition2 = yyIndex;
                          continue;
                        }
                      }
                    }
                    break;
                  }

                  yyBase = yyRepetition2;
                  yyC    = character(yyBase);
                  if ('*' == yyC) {
                    yyIndex = yyRepetition2 + 1;

                    yyC = character(yyIndex);
                    if ('/' == yyC) {
                      yyIndex = yyIndex + 1;

                      yyRepetition1 = yyIndex;
                      continue;
                    } else {
                      yyError = yyError.select("'*/' expected", yyBase);
                    }
                  } else {
                    yyError = yyError.select("'*/' expected", yyBase);
                  }
                }
                break;

              case '/':
                {
                  yyRepetition2 = yyIndex;
                  while (true) {

                    yyC = character(yyRepetition2);
                    if (-1 != yyC) {
                      yyIndex = yyRepetition2 + 1;

                      switch (yyC) {
                      case '\n':
                      case '\r':
                        /* No match. */
                        break;

                      default:
                        {
                          yyRepetition2 = yyIndex;
                          continue;
                        }
                      }
                    }
                    break;
                  }

                  final int yyChoice2 = yyRepetition2;

                  // Nested alternative 1.

                  yyC = character(yyChoice2);
                  if (-1 != yyC) {
                    yyIndex = yyChoice2 + 1;

                    switch (yyC) {
                    case '\r':
                      {
                        final int yyChoice3 = yyIndex;

                        // Nested alternative 1.

                        yyC = character(yyChoice3);
                        if ('\n' == yyC) {
                          yyIndex = yyChoice3 + 1;

                          yyRepetition1 = yyIndex;
                          continue;
                        }

                        // Nested alternative 2.

                        yyRepetition1 = yyChoice3;
                        continue;
                      }

                    case '\n':
                      {
                        yyRepetition1 = yyIndex;
                        continue;
                      }

                    default:
                      /* No match. */
                    }
                  }

                  // Nested alternative 2.

                  yyPredResult = pEndOfFile(yyChoice2);
                  yyError      = yyPredResult.select(yyError);
                  if (yyPredResult.hasValue()) {

                    yyRepetition1 = yyChoice2;
                    continue;
                  }
                }
                break;

              default:
                /* No match. */
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }
      break;
    }

    yyValue = new TextToken(difference(yyStart, yyRepetition1));
    yyValue.setLocation(location(yyStart));

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal xtc.util.Spacing.EndOfFile.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pEndOfFile(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("end of file expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  static {
    add(JAVA_KEYWORDS, new String[] {
      "abstract",  "continue",  "for",         "new",        "switch",
      "assert",    "default",   "if",          "package",    "synchronized",
      "boolean",   "do",        "goto",        "private",    "this",
      "break",     "double",    "implements",  "protected",  "throw",
      "byte",      "else",      "import",      "public",     "throws",
      "case",                   "instanceof",  "return",     "transient",
      "catch",     "extends",   "int",         "short",      "try",
      "char",      "final",     "interface",   "static",     "void",
      "class",     "finally",   "long",        "strictfp",   "volatile",
      "const",     "float",     "native",      "super",      "while"
    });
  }
  static {
    add(JAVA_KEYWORDS, new String[] { "enum" });
  }

  // =========================================================================

  /**
   * Get the text for the specified annotated token.
   *
   * @param n The annotated token.
   * @return The corresponding text.
   */
  protected static final String toText(Node n) {
    return n.getTokenText();
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
